locations.get(0).setLookupID(lc360LocationId);

ArrayList<uk.co.allianz.rap.lc.model.request.importclient.Location> locations

importClientRequest.setClient(new Client());
Location location = new Location();
location.setLocationID("123");
List<Location> locations = new ArrayList<>();
locations.add(location);
importClientRequest.getClient().setLocations(locations);





@Test
public void testImportClient_Success() throws CustomException, JsonProcessingException {
    ImportClientRequest importClientRequest = new ImportClientRequest();
    Client client = new Client();
    Location location = new Location();
    location.setLocationID("123");
    client.setLocations(Collections.singletonList(location));  // Set the locations list for the client
    importClientRequest.setClient(client);  // Set the client for the importClientRequest

    Map<String, Object> clientResult = new HashMap<>();
    when(lossControlDao.findByClientId(anyString())).thenReturn(clientResult);
    when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
    when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(new ImportClientResponse());

    ImportClientResponse response = importClientServiceImp.importClient("json", "correlationId");

    // Add assertions here based on your implementation and expected behavior
}












@Test
public void testImportClient_Success() throws CustomException, JsonProcessingException {
    ImportClientRequest importClientRequest = new ImportClientRequest();

    // Assuming the structure of ImportClientRequest is like:
    // importClientRequest.setClient(new Client());
    // importClientRequest.getClient().setLocations(Collections.singletonList(location));

    Map<String, Object> clientResult = new HashMap<>();
    when(lossControlDao.findByClientId(anyString())).thenReturn(clientResult);
    when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
    when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(new ImportClientResponse());

    ImportClientResponse response = importClientServiceImp.importClient("json", "correlationId");

    // Add assertions here based on your implementation and expected behavior
}

@Test
public void testImportClient_ClientNotFound() throws CustomException, JsonProcessingException {
    ImportClientRequest importClientRequest = new ImportClientRequest();

    // Assuming the structure of ImportClientRequest is like:
    // importClientRequest.setClient(new Client());
    // importClientRequest.getClient().setLocations(Collections.singletonList(location));

    when(lossControlDao.findByClientId(anyString())).thenReturn(null);
    when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);

    // Add assertions here based on your implementation and expected behavior
}

// Add more test cases for different scenarios


///////////////////////
import static org.mockito.Mockito.*;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testImportClient_Success() throws Exception {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Location location = new Location();
        location.setLocationID("123");
        importClientRequest.setClient(new Client());
        importClientRequest.getClient().setLocations(Collections.singletonList(location));

        Map<String, Object> clientResult = new HashMap<>();
        when(lossControlDao.findByClientId(anyString())).thenReturn(clientResult);
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(new ImportClientResponse());

        ImportClientResponse response = importClientServiceImp.importClient("json", "correlationId");

        // Add assertions here based on your implementation and expected behavior
    }

    @Test
    public void testImportClient_ClientNotFound() throws Exception {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Location location = new Location();
        location.setLocationID("123");
        importClientRequest.setClient(new Client());
        importClientRequest.getClient().setLocations(Collections.singletonList(location));

        when(lossControlDao.findByClientId(anyString())).thenReturn(null);
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);

        // Add assertions here based on your implementation and expected behavior
    }

    // Add more test cases for different scenarios
}










import static org.mockito.Mockito.*;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testImportClient_Success() throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Location location = new Location();
        location.setLocationID("123");
        importClientRequest.setClient(new Client());
        importClientRequest.getClient().setLocations(Collections.singletonList(location));

        Map<String, Object> clientResult = new HashMap<>();
        when(lossControlDao.findByClientId(anyString())).thenReturn(clientResult);
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(new ImportClientResponse());

        ImportClientResponse response = importClientServiceImp.importClient("json", "correlationId");

        // Add assertions here based on your implementation and expected behavior
    }

    @Test
    public void testImportClient_ClientNotFound() throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Location location = new Location();
        location.setLocationID("123");
        importClientRequest.setClient(new Client());
        importClientRequest.getClient().setLocations(Collections.singletonList(location));

        when(lossControlDao.findByClientId(anyString())).thenReturn(null);
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);

        // Add assertions here based on your implementation and expected behavior
    }

    // Add more test cases for different scenarios
}














import static org.mockito.Mockito.*;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testImportClient_Success() throws Exception {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Location location = new Location();
        location.setLocationID("123");
        importClientRequest.setClient(new Client());
        importClientRequest.getClient().setLocations(Collections.singletonList(location));

        Map<String, Object> clientResult = new HashMap<>();
        when(lossControlDao.findByClientId(anyString())).thenReturn(clientResult);
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(new ImportClientResponse());

        ImportClientResponse response = importClientServiceImp.importClient("json", "correlationId");

        // Add assertions here based on your implementation and expected behavior
    }

    @Test
    public void testImportClient_ClientNotFound() throws Exception {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Location location = new Location();
        location.setLocationID("123");
        importClientRequest.setClient(new Client());
        importClientRequest.getClient().setLocations(Collections.singletonList(location));

        when(lossControlDao.findByClientId(anyString())).thenReturn(null);
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);

        // Add assertions here based on your implementation and expected behavior
    }

    // Add more test cases for different scenarios
}














import static org.mockito.Mockito.*;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testImportClient_Success() throws Exception {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Location location = new Location();
        location.setLocationID("123");
        importClientRequest.setClient(new Client());
        importClientRequest.getClient().setLocations(Collections.singletonList(location));

        Map<String, Object> clientResult = new HashMap<>();
        when(lossControlDao.findByClientId(anyString())).thenReturn(clientResult);
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(new ImportClientResponse());

        ImportClientResponse response = importClientServiceImp.importClient("json", "correlationId");

        // Add assertions here based on your implementation and expected behavior
    }

    @Test
    public void testImportClient_ClientNotFound() throws Exception {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Location location = new Location();
        location.setLocationID("123");
        importClientRequest.setClient(new Client());
        importClientRequest.getClient().setLocations(Collections.singletonList(location));

        when(lossControlDao.findByClientId(anyString())).thenReturn(null);
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);

        // Add assertions here based on your implementation and expected behavior
    }

    // Add more test cases for different scenarios
}







//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest801 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        String json = "{...}"; // Your JSON input here
        String correlationId = "123";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client mockClient = mock(Client.class);
        when(importClientRequest.getClient()).thenReturn(mockClient);
        when(mockClient.getLookupID()).thenReturn("C008032810");
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(mock(Location.class));
        when(mockClient.getLocations()).thenReturn(locations);

        Map<String, Object> clientResult = Collections.singletonMap("key", "value");
        when(lossControlDao.findByClientId("C008032810")).thenReturn(clientResult);

        // Execute the method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(response);
        // Add more assertions based on your use case

        // Verify interactions
        verify(objectMapper, times(1)).readValue(json, ImportClientRequest.class);
        verify(lossControlDao, times(1)).findByClientId("C008032810");
        verify(mockClient, times(1)).getLookupID();
        verify(mockClient, times(1)).getLocations();
    }
}









import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest802 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        String json = "{\"client\": {\"LookupID\": \"C008032810\", ...}}"; // Your JSON input here
        String correlationId = "123";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client mockClient = mock(Client.class);
        when(importClientRequest.getClient()).thenReturn(mockClient);
        when(mockClient.getLookupID()).thenReturn("C008032810");
        ArrayList<Location> locations = new ArrayList<>();
        Location mockLocation = mock(Location.class);
        locations.add(mockLocation);
        when(mockClient.getLocations()).thenReturn(locations);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);

        Map<String, Object> mockClientResult = new HashMap<>();
        when(lossControlDao.findByClientId("C008032810")).thenReturn(mockClientResult);

        // Execute the method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions
        assertEquals(mockClientResult, response.getClientResult());
        // Add more assertions based on your use case
    }
}




import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

public class ImportClientServiceImpTest803 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws Exception {
        String json = "{...}"; // Your JSON input here
        String correlationId = "123";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client mockClient = mock(Client.class);
        when(importClientRequest.getClient()).thenReturn(mockClient);
        when(mockClient.getLookupID()).thenReturn("C008032810");
        ArrayList<Location> locations = new ArrayList<>();
        Location mockLocation = mock(Location.class);
        locations.add(mockLocation);
        when(mockClient.getLocations()).thenReturn(locations);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        
        Map<String, Object> mockClientResult = Collections.singletonMap("key", "value");
        when(lossControlDao.findByClientId("C008032810")).thenReturn(mockClientResult);

        // Execute the method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions
        // Add your assertions here
        assertEquals(mockClientResult, response.getClientResult());
    }
}












import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

public class ImportClientServiceImpTest804 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws Exception {
        String json = "{...}"; // Your JSON input here
        String correlationId = "123";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client mockClient = mock(Client.class);
        when(importClientRequest.getClient()).thenReturn(mockClient);
        when(mockClient.getLookupID()).thenReturn("C008032810");
        ArrayList<Location> locations = new ArrayList<>();
        Location mockLocation = mock(Location.class);
        locations.add(mockLocation);
        when(mockClient.getLocations()).thenReturn(locations);

        Map<String, Object> clientResult = new HashMap<>();
        when(lossControlDao.findByClientId("C008032810")).thenReturn(clientResult);

        // Execute the method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions
        // Add your assertions here based on the expected behavior and response
    }
}








import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest805 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws Exception {
        String json = "{...}"; // Your JSON input here
        String correlationId = "123";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client mockClient = mock(Client.class);
        when(importClientRequest.getClient()).thenReturn(mockClient);
        when(mockClient.getLookupID()).thenReturn("C008032810");
        ArrayList<Location> locations = new ArrayList<>();
        Location mockLocation = mock(Location.class);
        locations.add(mockLocation);
        when(mockClient.getLocations()).thenReturn(locations);

        Map<String, Object> clientResult = new HashMap<>();
        when(lossControlDao.findByClientId("C008032810")).thenReturn(clientResult);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);

        // Execute the method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Add your verification/assertions here
        // For example, assert that the response is not null and contains the expected data
        assertNotNull(response);
        // Add more assertions based on your use case
    }

    // Add more test cases for different scenarios if needed
}



//////////////////////////////
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
//import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.Map;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        //finding client id in DB exist or not
        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {


























import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;

import java.util.ArrayList;
import java.util.Collections;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.Mockito.when;

public class ImportClientServiceImpTest401 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientDoesNotExist() throws Exception {
        String json = "{...}"; // Your JSON input here
        String correlationId = "123";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client mockClient = mock(Client.class);
        when(importClientRequest.getClient()).thenReturn(mockClient);
        when(mockClient.getLookupID()).thenReturn("C008032810");
        ArrayList<Location> locations = new ArrayList<>();
        Location mockLocation = mock(Location.class);
        locations.add(mockLocation);
        when(mockClient.getLocations()).thenReturn(locations);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("C008032810")).thenReturn(null);

        // Execute the method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(response);
        // Add more assertions based on your use case
    }
}











importClientService.importClient(json, correlationId);





java.lang.IndexOutOfBoundsException: Index 0 out of bounds for length 0

	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:64)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:70)
	at java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:266)
	at java.base/java.util.Objects.checkIndex(Objects.java:361)
	at java.base/java.util.ArrayList.get(ArrayList.java:427)
	at uk.co.allianz.rap.lc.service.ImportClientServiceImp.getClientResponse(ImportClientServiceImp.java:58)
	at uk.co.allianz.rap.lc.service.ImportClientServiceImp.importClient(ImportClientServiceImp.java:47)
	at uk.co.allianz.rap.lc.service.ImportClientServiceImpTest21.testImportClientWhenClientDoesNotExist(ImportClientServiceImpTest21.java:300)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:727)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:156)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:147)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:86)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(InterceptingExecutableInvoker.java:103)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.lambda$invoke$0(InterceptingExecutableInvoker.java:93)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:92)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:86)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:217)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:213)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:138)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	








@Test
    public void testImportClientWhenClientDoesNotExist() throws Exception {
        String json = "{\n" +
                "  \"divisionLookupID\" : \"AZ_UK\",\n" +
                "  \"client\" : {\n" +
                "    \"LookupID\" : \"C008032810\",\n" +
                "    \"ContactFirstName\" : null,\n" +
                "    \"ContactLastName\" : null,\n" +
                "    \"PolicyNumber\" : \"SP26853149\",\n" +
                "    \"Name\" : \"CLIENT CI Test\",\n" +
                "    \"Phone\" : null,\n" +
                "    \"Email\" : null,\n" +
                "    \"Address\" : {\n" +
                "      \"Country\" : \"United Kingdom\",\n" +
                "      \"OverseasTerritories\" : null,\n" +
                "      \"Street1\" : null,\n" +
                "      \"Street2\" : null,\n" +
                "      \"City\" : null,\n" +
                "      \"Region1\" : null,\n" +
                "      \"Region2\" : null,\n" +
                "      \"Region3\" : null,\n" +
                "      \"Region4\" : null,\n" +
                "      \"ZipCode\" : null\n" +
                "    },\n" +
                "    \"Agent\" : {\n" +
                "      \"AgencyCode\" : \"22576\",\n" +
                "      \"AgencyName\" : \"Arthur J. Gallagher\",\n" +
                "      \"AgentCode\" : \"13332\",\n" +
                "      \"AgentName\" : null,\n" +
                "      \"Email\" : null,\n" +
                "      \"FaxNumber\" : null,\n" +
                "      \"PhoneNumber\" : null,\n" +
                "      \"Address\" : {\n" +
                "        \"Country\" : \"GB\",\n" +
                "        \"OverseasTerritories\" : null,\n" +
                "        \"Street1\" : null,\n" +
                "        \"Street2\" : null,\n" +
                "        \"City\" : null,\n" +
                "        \"Region1\" : null,\n" +
                "        \"Region2\" : null,\n" +
                "        \"Region3\" : null,\n" +
                "        \"Region4\" : null,\n" +
                "        \"ZipCode\" : null\n" +
                "      },\n" +
                "      \"AgentType\" : \"Broker\"\n" +
                "    },\n" +
                "    \"Underwriter\" : null,\n" +
                "    \"Locations\" : [ {\n" +
                "      \"genericFields\" : null,\n" +
                "      \"LookupID\" : \"111810\",\n" +
                "      \"Name\" : null,\n" +
                "      \"PolicyNumber\" : \"SP26853148\",\n" +
                "      \"PolicyEffectiveDate\" : null,\n" +
                "      \"PolicyExpirationDate\" : null,\n" +
                "      \"PolicyRenewalDate\" : null,\n" +
                "      \"Address\" : {\n" +
                "        \"Country\" : \"United Kingdom\",\n" +
                "        \"OverseasTerritories\" : null,\n" +
                "        \"Street1\" : \"NEW CROSS DEWEL\",\n" +
                "        \"Street2\" : \"SD 11 JEW TOWN\",\n" +
                "        \"City\" : \"MM KEMSTONE\",\n" +
                "        \"Region1\" : \"UK\",\n" +
                "        \"Region2\" : null,\n" +
                "        \"Region3\" : null,\n" +
                "        \"Region4\" : null,\n" +
                "        \"ZipCode\" : \"GU1 1DB\"\n" +
                "      },\n" +
                "      \"OriginalEffectiveDate\" : null,\n" +
                "      \"EffectiveDate\" : null,\n" +
                "      \"ExpirationDate\" : null,\n" +
                "      \"RenewalDate\" : \"2024-07-17\",\n" +
                "      \"LastInspectedDate\" : null,\n" +
                "      \"Coverages\" : [ {\n" +
                "        \"CoverageTypeLookup\" : \"PD_TIV\",\n" +
                "        \"CoverageReference\" : \"Coverage 1\",\n" +
                "        \"GenericFields\" : [ {\n" +
                "          \"Number\" : \"1123\",\n" +
                "          \"Key\" : \"01. PD Building\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : \"0\",\n" +
                "          \"Key\" : \"04. PD Other\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : null,\n" +
                "          \"Key\" : \"05. PD Other Description\",\n" +
                "          \"GenericFieldValueType\" : 0,\n" +
                "          \"Text\" : \"\"\n" +
                "        }, {\n" +
                "          \"Number\" : \"1123\",\n" +
                "          \"Key\" : \"06. TIV PD\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : \"332198\",\n" +
                "          \"Key\" : \"07. TIV BI\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : \"\",\n" +
                "          \"Key\" : \"08. BI Base Period (Months)\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : \"332198\",\n" +
                "          \"Key\" : \"09. TIV (PD + BI )\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        } ]\n" +
                "      } ],\n" +
                "      \"Contact\" : null\n" +
                "    } ]\n" +
                "  }\n" +
                "}";
        String correlationId = "123";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        importClientRequest.setClient(new Client()); // Initialize the Client object
        importClientRequest.getClient().setLookupID("C008032810");
        importClientRequest.getClient().setLocations(new ArrayList<>()); // Initialize the Locations list

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("C008032810")).thenReturn(null);

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }





















import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest101 {

    private ImportClientServiceImp importClientService;
    private LossControlDao lossControlDao;
    private TokenCache tokenCache;
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        lossControlDao = mock(LossControlDao.class);
        tokenCache = mock(TokenCache.class);
        objectMapper = new ObjectMapper();
        importClientService = new ImportClientServiceImp(tokenCache, lossControlDao, objectMapper);
    }

    @Test
    public void testImportClientWhenClientIsPresent() throws CustomException, JsonProcessingException {
        String json = "{...}"; // JSON data
        String correlationId = "correlation123";
        
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        Map<String, Object> clientResult = new HashMap<>();
        when(lossControlDao.findByClientId(anyString())).thenReturn(clientResult);
        
        ImportClientResponse importClientResponse = new ImportClientResponse(); // Create expected response
        
        // Call the method under test
        ImportClientResponse actualResponse = importClientService.importClient(json, correlationId);
        
        assertEquals(importClientResponse, actualResponse);
        verify(lossControlDao).findByClientId(anyString());
        // Add more assertions and verifications based on your use case
    }

    @Test
    public void testImportClientWhenClientNotPresent() throws CustomException, JsonProcessingException {
        String json = "{...}"; // JSON data
        String correlationId = "correlation123";
        
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        when(lossControlDao.findByClientId(anyString())).thenReturn(null);
        
        ImportClientResponse importClientResponse = new ImportClientResponse(); // Create expected response
        
        // Call the method under test
        ImportClientResponse actualResponse = importClientService.importClient(json, correlationId);
        
        assertEquals(importClientResponse, actualResponse);
        verify(lossControlDao).findByClientId(anyString());
        // Add more assertions and verifications based on your use case
    }
}






import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest102 {

    private ImportClientServiceImp importClientService;
    private LossControlDao lossControlDao;
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        lossControlDao = new LossControlDao(); // You need to create a real instance or use a test double for LossControlDao
        objectMapper = new ObjectMapper();
        importClientService = new ImportClientServiceImp(new TokenCache(), lossControlDao, new LossControlServiceImpl(), objectMapper);
    }

    @Test
    public void testImportClientWhenClientIsPresent() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "{ ... }"; // Your JSON data here
        String correlationId = "correlation123";

        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        // Mock behavior of lossControlDao
        Map<String, Object> clientResult = new HashMap<>();
        clientResult.put("key", "value");
        lossControlDao.setClientResult(clientResult); // Set the mock result

        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case
    }

    @Test
    public void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "{ ... }"; // Your JSON data here
        String correlationId = "correlation123";

        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        // Mock behavior of lossControlDao
        lossControlDao.setClientResult(null); // Set the mock result as null

        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case
    }
}










import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest103 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Spy
    private ObjectMapper objectMapper = new ObjectMapper();

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientIsPresent() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "{...}"; // Your JSON data here
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        // Mock behavior of lossControlDao
        when(lossControlDao.findByClientId(anyString())).thenReturn(new HashMap<>());

        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case

        // Verify method calls
        verify(lossControlDao).findByClientId(anyString());
        verifyNoMoreInteractions(lossControlDao);
    }

    @Test
    public void testImportClientWhenClientNotPresent() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "{...}"; // Your JSON data here
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        // Mock behavior of lossControlDao
        when(lossControlDao.findByClientId(anyString())).thenReturn(null);

        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case

        // Verify method calls
        verify(lossControlDao).findByClientId(anyString());
        verifyNoMoreInteractions(lossControlDao);
    }
}





import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest104 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Spy
    private ObjectMapper objectMapper = new ObjectMapper();

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientIsPresent() throws CustomException, JsonProcessingException {
        String json = "{\"client\": {\"LookupID\": \"123\"}}";
        String correlationId = "correlation123";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        importClientRequest.setClient(new ImportClientRequest.Client());
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId(anyString())).thenReturn(new HashMap<>());
        when(lossControlServiceImpl.ifClientIsPresent(any(), any(), any(), any())).thenReturn(new ImportClientResponse());

        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);

        assertNotNull(importClientResponse);
        verify(lossControlDao).findByClientId(anyString());
        verify(lossControlServiceImpl).ifClientIsPresent(any(), any(), any(), any());
        verifyNoMoreInteractions(lossControlDao, lossControlServiceImpl);
    }

    @Test
    public void testImportClientWhenClientIsNotPresent() throws CustomException, JsonProcessingException {
        String json = "{\"client\": {\"LookupID\": \"123\"}}";
        String correlationId = "correlation123";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        importClientRequest.setClient(new ImportClientRequest.Client());
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId(anyString())).thenReturn(null);
        when(lossControlServiceImpl.getClientResponse(any(), any(), any(), any())).thenReturn(new ImportClientResponse());

        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);

        assertNotNull(importClientResponse);
        verify(lossControlDao).findByClientId(anyString());
        verify(lossControlServiceImpl).getClientResponse(any(), any(), any(), any());
        verifyNoMoreInteractions(lossControlDao, lossControlServiceImpl);
    }
}














import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest101 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "..."; // Provide JSON data with client details
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = new ImportClientRequest(); // Create a request object
        importClientRequest.setClient(/* Set client details here */);
        ImportClientResponse expectedResponse = new ImportClientResponse(); // Create the expected response object

        // Mock behavior of lossControlDao
        when(lossControlDao.findByClientId(anyString())).thenReturn(new HashMap<>());

        // Mock behavior of objectMapper
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class)))
                .thenReturn(importClientRequest);

        // Execute the method
        ImportClientResponse actualResponse = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(actualResponse);
        // Add more assertions based on your use case

        // Verify method calls
        verify(lossControlDao).findByClientId(anyString());
        verifyNoMoreInteractions(lossControlDao);
        verifyZeroInteractions(lossControlServiceImpl);
    }

    @Test
    public void testImportClientWhenClientDoesNotExist() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "..."; // Provide JSON data with client details
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = new ImportClientRequest(); // Create a request object
        importClientRequest.setClient(/* Set client details here */);
        ImportClientResponse expectedResponse = new ImportClientResponse(); // Create the expected response object

        // Mock behavior of lossControlDao
        when(lossControlDao.findByClientId(anyString())).thenReturn(null);

        // Mock behavior of objectMapper
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class)))
                .thenReturn(importClientRequest);

        // Execute the method
        ImportClientResponse actualResponse = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(actualResponse);
        // Add more assertions based on your use case

        // Verify method calls
        verify(lossControlDao).findByClientId(anyString());
        verifyNoMoreInteractions(lossControlDao);
        verifyZeroInteractions(lossControlServiceImpl);
    }
}


//////////////////////////////////////////////////////////
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
//import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.Map;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        //finding client id in DB exist or not
        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {


            importClientResponse = ifClientIsPresent(importClientResponse, importClientRequest, locations, correlationId);
        } else {
            importClientResponse = getClientResponse(importClientResponse, importClientRequest, locations, correlationId);

        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }






















package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;  // Import the Spy annotation
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;


 

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

 

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.Mockito.*;

 

public class ImportClientServiceImpTest32 {

 

    @InjectMocks
    private ImportClientServiceImp importClientService;

 

    @Mock
    private LossControlDao lossControlDao;

 

    @Mock
    private ImportClientServiceImp clientLocation;

 

    @Spy  // Use the Spy annotation here
    private ObjectMapper objectMapper = new ObjectMapper();

 

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

 

    @Test
    public void testImportClientWhenClientIsPresent() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "{\n" +
                "  \"divisionLookupID\" : \"AZ_UK\",\n" +
                "  \"client\" : {\n" +
                "    \"LookupID\" : \"C008032906\",\n" +
                "    \"ContactFirstName\" : null,\n" +
                "    \"ContactLastName\" : null,\n" +
                "    \"PolicyNumber\" : \"SP26853149\",\n" +
                "    \"Name\" : \"CLIENT CI Test\",\n" +
                "    \"Phone\" : null,\n" +
                "    \"Email\" : null,\n" +
                "    \"Address\" : {\n" +
                "      \"Country\" : \"United Kingdom\",\n" +
                "      \"OverseasTerritories\" : null,\n" +
                "      \"Street1\" : null,\n" +
                "      \"Street2\" : null,\n" +
                "      \"City\" : null,\n" +
                "      \"Region1\" : null,\n" +
                "      \"Region2\" : null,\n" +
                "      \"Region3\" : null,\n" +
                "      \"Region4\" : null,\n" +
                "      \"ZipCode\" : null\n" +
                "    },\n" +
                "    \"Agent\" : {\n" +
                "      \"AgencyCode\" : \"22576\",\n" +
                "      \"AgencyName\" : \"Arthur J. Gallagher\",\n" +
                "      \"AgentCode\" : \"13332\",\n" +
                "      \"AgentName\" : null,\n" +
                "      \"Email\" : null,\n" +
                "      \"FaxNumber\" : null,\n" +
                "      \"PhoneNumber\" : null,\n" +
                "      \"Address\" : {\n" +
                "        \"Country\" : \"GB\",\n" +
                "        \"OverseasTerritories\" : null,\n" +
                "        \"Street1\" : null,\n" +
                "        \"Street2\" : null,\n" +
                "        \"City\" : null,\n" +
                "        \"Region1\" : null,\n" +
                "        \"Region2\" : null,\n" +
                "        \"Region3\" : null,\n" +
                "        \"Region4\" : null,\n" +
                "        \"ZipCode\" : null\n" +
                "      },\n" +
                "      \"AgentType\" : \"Broker\"\n" +
                "    },\n" +
                "    \"Underwriter\" : null,\n" +
                "    \"Locations\" : [ {\n" +
                "      \"genericFields\" : null,\n" +
                "      \"LookupID\" : \"111106\",\n" +
                "      \"Name\" : null,\n" +
                "      \"PolicyNumber\" : \"SP26853148\",\n" +
                "      \"PolicyEffectiveDate\" : null,\n" +
                "      \"PolicyExpirationDate\" : null,\n" +
                "      \"PolicyRenewalDate\" : null,\n" +
                "      \"Address\" : {\n" +
                "        \"Country\" : \"United Kingdom\",\n" +
                "        \"OverseasTerritories\" : null,\n" +
                "        \"Street1\" : \"NEW CROSS DEWEL\",\n" +
                "        \"Street2\" : \"SD 11 JEW TOWN\",\n" +
                "        \"City\" : \"MM KEMSTONE\",\n" +
                "        \"Region1\" : \"UK\",\n" +
                "        \"Region2\" : null,\n" +
                "        \"Region3\" : null,\n" +
                "        \"Region4\" : null,\n" +
                "        \"ZipCode\" : \"GU1 1DB\"\n" +
                "      },\n" +
                "      \"OriginalEffectiveDate\" : null,\n" +
                "      \"EffectiveDate\" : null,\n" +
                "      \"ExpirationDate\" : null,\n" +
                "      \"RenewalDate\" : \"2024-07-17\",\n" +
                "      \"LastInspectedDate\" : null,\n" +
                "      \"Coverages\" : [ {\n" +
                "        \"CoverageTypeLookup\" : \"PD_TIV\",\n" +
                "        \"CoverageReference\" : \"Coverage 1\",\n" +
                "        \"GenericFields\" : [ {\n" +
                "          \"Number\" : \"1123\",\n" +
                "          \"Key\" : \"01. PD Building\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : \"0\",\n" +
                "          \"Key\" : \"04. PD Other\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : null,\n" +
                "          \"Key\" : \"05. PD Other Description\",\n" +
                "          \"GenericFieldValueType\" : 0,\n" +
                "          \"Text\" : \"\"\n" +
                "        }, {\n" +
                "          \"Number\" : \"1123\",\n" +
                "          \"Key\" : \"06. TIV PD\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : \"332198\",\n" +
                "          \"Key\" : \"07. TIV BI\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : \"\",\n" +
                "          \"Key\" : \"08. BI Base Period (Months)\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : \"332198\",\n" +
                "          \"Key\" : \"09. TIV (PD + BI )\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        } ]\n" +
                "      } ],\n" +
                "      \"Contact\" : null\n" +
                "    } ]\n" +
                "  }\n" +
                "}";
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        // Mock behavior of lossControlDao and clientLocation
        when(lossControlDao.findByClientId(anyString())).thenReturn(new HashMap<>());
        when(clientLocation.ifClientIsPresent(any(), any(), any(), any())).thenReturn(new ImportClientResponse());

 

        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case

 

        // Verify method calls
        verify(lossControlDao).findByClientId(anyString());
        verify(clientLocation).ifClientIsPresent(any(), any(), any(), any());
        verifyNoMoreInteractions(lossControlDao, clientLocation);
    }
}





















import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;

class ImportClientServiceImpTest71 {

    private ImportClientServiceImp importClientService;
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        objectMapper = new ObjectMapper();
        LossControlServiceImpl lossControlServiceImpl = new LossControlServiceImpl();
        importClientService = new ImportClientServiceImp();
        importClientService.setLossControlServiceImpl(lossControlServiceImpl);
        importClientService.setObjectMapper(objectMapper);
    }

    @Test
    void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("123"); // Set a valid client lookup ID
        Location location = new Location();
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);
        ImportClientResponse expectedResponse = new ImportClientResponse();

        Map<String, Object> clientResult = new HashMap<>();
        clientResult.put("client_id", "123");

        StubLossControlDao lossControlDao = new StubLossControlDao();
        lossControlDao.setFindByClientIdResult(clientResult);
        importClientService.setLossControlDao(lossControlDao);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    @Test
    void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        Location location = new Location();
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);
        ImportClientResponse expectedResponse = new ImportClientResponse();

        StubLossControlDao lossControlDao = new StubLossControlDao();
        lossControlDao.setFindByClientIdResult(null);
        importClientService.setLossControlDao(lossControlDao);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    private static class StubLossControlDao implements LossControlDao {
        private Map<String, Object> findByClientIdResult;

        public void setFindByClientIdResult(Map<String, Object> findByClientIdResult) {
            this.findByClientIdResult = findByClientIdResult;
        }

        @Override
        public Map<String, Object> findByClientId(String client_id) {
            return findByClientIdResult;
        }

        // ... Implement other methods if necessary
    }
}








import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;

@SpringBootTest
public class ImportClientServiceImpTest72 {

    @Autowired
    private ImportClientServiceImp importClientService;

    @Autowired
    private TokenCache tokenCache;

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;

    @Autowired
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        // You can set up any necessary data or configurations here
    }

    @Test
    public void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        ClientLocation clientLocation = new ClientLocation(); // Create a ClientLocation object
        Location location = new Location();
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        clientLocation.setLocations(locations);
        request.setClient(clientLocation);

        ImportClientResponse expectedResponse = new ImportClientResponse();

        // You need to implement your actual logic for inserting or updating the database
        Map<String, Object> clientResult = new HashMap<>();
        clientResult.put("client_id", "123");
        lossControlDao.insertClientId("123");

        ImportClientResponse actualResponse = importClientService.importClient(objectMapper.writeValueAsString(request), "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    // Similar test case for when the client doesn't exist
}








import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;

class ImportClientServiceImpTest73 {

    private ImportClientServiceImp importClientService;
    private TokenCache tokenCache;
    private LossControlDao lossControlDao;
    private LossControlServiceImpl lossControlServiceImpl;
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        tokenCache = new TokenCache(); // Initialize TokenCache as needed
        lossControlDao = new LossControlDao(); // Initialize LossControlDao as needed
        lossControlServiceImpl = new LossControlServiceImpl(); // Initialize LossControlServiceImpl as needed
        objectMapper = new ObjectMapper(); // Initialize ObjectMapper as needed
        
        importClientService = new ImportClientServiceImp();
        importClientService.setTokenCache(tokenCache);
        importClientService.setLossControlDao(lossControlDao);
        importClientService.setLossControlServiceImpl(lossControlServiceImpl);
        importClientService.setObjectMapper(objectMapper);
    }

    @Test
    void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("123"); // Set a valid client lookup ID
        Location location = new Location();
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);
        ImportClientResponse expectedResponse = new ImportClientResponse();

        Map<String, Object> clientResult = new HashMap<>();
        clientResult.put("client_id", "123");
        lossControlDao.setFindByClientIdResult(clientResult);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    @Test
    void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        Location location = new Location();
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);
        ImportClientResponse expectedResponse = new ImportClientResponse();

        lossControlDao.setFindByClientIdResult(null);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    // Additional test cases can be added for other scenarios
}















import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.ActiveProfiles;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import javax.transaction.Transactional;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;

@SpringBootTest
@DataJpaTest
@ActiveProfiles("test")
@Transactional
class ImportClientServiceImpTest74 {

    @Autowired
    private ImportClientServiceImp importClientService;

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        // Initialize the database with necessary data if needed
    }

    @Test
    void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("123"); // Set a valid client lookup ID
        Location location = new Location();
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);
        ImportClientResponse expectedResponse = new ImportClientResponse();

        String json = objectMapper.writeValueAsString(request);

        lossControlDao.insertClientId("123");

        ImportClientResponse actualResponse = importClientService.importClient(json, "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    // Test cases for other scenarios can be added similarly
}









import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;

@SpringBootTest
class ImportClientServiceImpTest75 {

    @Autowired
    private ImportClientServiceImp importClientService;

    @Autowired
    private TokenCache tokenCache;

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;

    @Autowired
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        // You can perform any necessary setup here if required
    }

    @Test
    void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        String json = "{\"client\": {\"lookupID\": \"123\", \"locations\": []}}"; // Replace with your JSON data
        String correlationId = "correlationId"; // Replace with an appropriate correlation ID
        ImportClientResponse expectedResponse = new ImportClientResponse();

        ImportClientResponse actualResponse = importClientService.importClient(json, correlationId);

        assertEquals(expectedResponse, actualResponse);
    }

    @Test
    void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
        String json = "{\"client\": {\"lookupID\": \"456\", \"locations\": []}}"; // Replace with your JSON data
        String correlationId = "correlationId"; // Replace with an appropriate correlation ID
        ImportClientResponse expectedResponse = new ImportClientResponse();

        ImportClientResponse actualResponse = importClientService.importClient(json, correlationId);

        assertEquals(expectedResponse, actualResponse);
    }

    // Additional test cases can be added for other scenarios
}


////////////////////////////////////////////////////////////////////////////////////
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;

class ImportClientServiceImpTest81 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("123"); // Set a valid client lookup ID
        Location location = new Location();
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);
        ImportClientResponse expectedResponse = new ImportClientResponse();

        when(objectMapper.readValue(anyString(), Mockito.eq(ImportClientRequest.class)))
                .thenReturn(request);

        Map<String, Object> clientResult = new HashMap<>();
        clientResult.put("client_id", "123");
        when(lossControlDao.findByClientId(anyString()))
                .thenReturn(clientResult);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    @Test
    void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        Location location = new Location();
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);
        ImportClientResponse expectedResponse = new ImportClientResponse();

        when(objectMapper.readValue(anyString(), Mockito.eq(ImportClientRequest.class)))
                .thenReturn(request);

        when(lossControlDao.findByClientId(anyString()))
                .thenReturn(null);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    // Additional test cases can be added for other scenarios
}





import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

class ImportClientServiceImpTest82 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        Location location = new Location();
        location.setLookupID("locationId"); // Set a valid lookup ID
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);

        ImportClientResponse expectedResponse = new ImportClientResponse();

        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class)))
                .thenReturn(request);

        when(lossControlDao.findByClientId(anyString()))
                .thenReturn(null);

        when(lossControlServiceImpl.clientPost(eq(request), anyString()))
                .thenReturn(expectedResponse);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    // Additional test cases can be added for other scenarios
}





import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

class ImportClientServiceImpTest83 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("client123");
        request.setClient(client);

        ImportClientResponse expectedResponse = new ImportClientResponse();

        when(objectMapper.readValue(any(), any()))
                .thenReturn(request);

        Map<String, Object> clientResult = new HashMap<>();
        clientResult.put("client_id", "123");
        when(lossControlDao.findByClientId(any()))
                .thenReturn(clientResult);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    @Test
    void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("client123");
        Location location = new Location();
        location.setLookupID("location123");
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);

        ImportClientResponse expectedResponse = new ImportClientResponse();

        when(objectMapper.readValue(any(), any()))
                .thenReturn(request);

        when(lossControlDao.findByClientId(any()))
                .thenReturn(null);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    // Additional test cases can be added for other scenarios
}


//
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;

class ImportClientServiceImpTest84 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(new Location());

        when(objectMapper.readValue(anyString(), Mockito.eq(ImportClientRequest.class)))
                .thenReturn(importClientRequest);

        Map<String, Object> clientResult = new HashMap<>();
        when(lossControlDao.findByClientId(anyString()))
                .thenReturn(clientResult);

        ImportClientResponse expectedResponse = new ImportClientResponse();
        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    @Test
    void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(new Location());
        
        when(objectMapper.readValue(anyString(), Mockito.eq(ImportClientRequest.class)))
                .thenReturn(importClientRequest);

        when(lossControlDao.findByClientId(anyString()))
                .thenReturn(null);

        ImportClientResponse expectedResponse = new ImportClientResponse();
        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }
}





//
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importclient.Result;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;

class ImportClientServiceImpTest85 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        ArrayList<Location> locations = new ArrayList<>();
        Location location = new Location();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);

        Map<String, Object> clientResult = new HashMap<>();
        clientResult.put("client_id", "123");

        ImportClientResponse expectedResponse = new ImportClientResponse();
        Result result = new Result();
        result.setClientLookupID("123");
        expectedResponse.setResult(result);

        when(objectMapper.readValue(anyString(), any()))
                .thenReturn(request);

        when(lossControlDao.findByClientId(anyString()))
                .thenReturn(clientResult);

        when(lossControlServiceImpl.clientPost(any(), anyString()))
                .thenReturn(expectedResponse);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    @Test
    void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        ArrayList<Location> locations = new ArrayList<>();
        Location location = new Location();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);

        Map<String, Object> clientResult = new HashMap<>();

        ImportClientResponse expectedResponse = new ImportClientResponse();
        Result result = new Result();
        result.setClientLookupID("456");
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = new ArrayList<>();
        uk.co.allianz.rap.lc.model.response.importclient.Location locationResponse = new uk.co.allianz.rap.lc.model.response.importclient.Location();
        locationResponse.setLocationLookupID("789");
        locationsResponse.add(locationResponse);
        result.setLocations(locationsResponse);
        expectedResponse.setResult(result);

        when(objectMapper.readValue(anyString(), any()))
                .thenReturn(request);

        when(lossControlDao.findByClientId(anyString()))
                .thenReturn(clientResult);

        when(lossControlServiceImpl.clientPost(any(), anyString()))
                .thenReturn(expectedResponse);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }
}






///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importclient.Result;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;

class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        ArrayList<Location> locations = new ArrayList<>();
        Location location = new Location();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);

        Map<String, Object> clientResult = new HashMap<>();
        clientResult.put("client_id", "123");

        ImportClientResponse expectedResponse = new ImportClientResponse();
        Result result = new Result();
        result.setClientLookupID("123");
        expectedResponse.setResult(result);

        when(objectMapper.readValue(anyString(), any()))
                .thenReturn(request);

        when(lossControlDao.findByClientId(anyString()))
                .thenReturn(clientResult);

        when(lossControlServiceImpl.clientPost(any(), anyString()))
                .thenReturn(expectedResponse);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    @Test
    void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        ArrayList<Location> locations = new ArrayList<>();
        Location location = new Location();
        locations.add(location);
        client.setLocations(locations);
        request.setClient(client);

        Map<String, Object> clientResult = new HashMap<>();

        ImportClientResponse expectedResponse = new ImportClientResponse();
        Result result = new Result();
        result.setClientLookupID("456");
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = new ArrayList<>();
        uk.co.allianz.rap.lc.model.response.importclient.Location locationResponse = new uk.co.allianz.rap.lc.model.response.importclient.Location();
        locationResponse.setLocationLookupID("789");
        locationsResponse.add(locationResponse);
        result.setLocations(locationsResponse);
        expectedResponse.setResult(result);

        when(objectMapper.readValue(anyString(), any()))
                .thenReturn(request);

        when(lossControlDao.findByClientId(anyString()))
                .thenReturn(clientResult);

        when(lossControlServiceImpl.clientPost(any(), anyString()))
                .thenReturn(expectedResponse);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }
}






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


@Test
void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
    ImportClientRequest request = new ImportClientRequest();
    
    // Initialize a Client object with locations
    Client client = new Client();
    Location location = new Location(); // Initialize Location object
    List<Location> locations = new ArrayList<>();
    locations.add(location);
    client.setLocations(locations);
    
    request.setClient(client); // Set the client object in the request
    
    ImportClientResponse expectedResponse = new ImportClientResponse();
    
    when(objectMapper.readValue(anyString(), Mockito.eq(ImportClientRequest.class)))
            .thenReturn(request);

    when(lossControlDao.findByClientId(anyString()))
            .thenReturn(null);

    ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

    assertEquals(expectedResponse, actualResponse);
}





















@Test
void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
    ImportClientRequest request = new ImportClientRequest();
    // Mock the behavior of methods called on ImportClientRequest
    when(request.getClient()).thenReturn(new Client()); // Mock the getClient method to return a non-null Client object
    when(request.getClient().getLocations()).thenReturn(new ArrayList<>()); // Mock the getLocations method to return an empty list
    
    ImportClientResponse expectedResponse = new ImportClientResponse();
    
    when(objectMapper.readValue(anyString(), Mockito.eq(ImportClientRequest.class)))
            .thenReturn(request);

    when(lossControlDao.findByClientId(anyString()))
            .thenReturn(null);

    ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

    assertEquals(expectedResponse, actualResponse);
}



@Test
void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
    ImportClientRequest request = new ImportClientRequest();
    Client client = new Client(); // Replace with your Client class
    Location location = new Location(); // Replace with your Location class
    location.setLookupID("locationId"); // Set appropriate values
    ArrayList<Location> locations = new ArrayList<>();
    locations.add(location);
    client.setLocations(locations);
    request.setClient(client);

    ImportClientResponse expectedResponse = new ImportClientResponse();

    when(objectMapper.readValue(anyString(), Mockito.eq(ImportClientRequest.class)))
            .thenReturn(request);

    when(lossControlDao.findByClientId(anyString()))
            .thenReturn(null);

    ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

    assertEquals(expectedResponse, actualResponse);
}





when(objectMapper.readValue(anyString(), Mockito.eq(ImportClientRequest.class)))
        .thenReturn(request); // Provide the actual ImportClientRequest object here











import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;

class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        request.setClient(new Client()); // Initialize the Client object
        ImportClientResponse expectedResponse = new ImportClientResponse();
        
        when(objectMapper.readValue(anyString(), ImportClientRequest.class))
                .thenReturn(request);

        when(lossControlDao.findByClientId(anyString()))
                .thenReturn(null);

        ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

        assertEquals(expectedResponse, actualResponse);
    }

    // Additional test cases can be added for other methods in the class
}











@Test
void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
    ImportClientRequest request = new ImportClientRequest();
    Client client = new Client(); // Initialize a Client object
    request.setClient(client); // Set the client object in the request
    
    ImportClientResponse expectedResponse = new ImportClientResponse();
    
    when(objectMapper.readValue(anyString(), Mockito.eq(ImportClientRequest.class)))
            .thenReturn(request);

    when(lossControlDao.findByClientId(anyString()))
            .thenReturn(null);

    ImportClientResponse actualResponse = importClientService.importClient("json", "correlationId");

    assertEquals(expectedResponse, actualResponse);
}




















package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
//import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.Map;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        //finding client id in DB exist or not
        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {


            importClientResponse = ifClientIsPresent(importClientResponse, importClientRequest, locations, correlationId);
        } else {
            importClientResponse = getClientResponse(importClientResponse, importClientRequest, locations, correlationId);

        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }

    public ImportClientResponse getClientResponse(ImportClientResponse importClientResponse, ImportClientRequest importClientRequest, ArrayList<uk.co.allianz.rap.lc.model.request.importclient.Location> locations, String correlationId) throws CustomException {
        log.info("Client and Location are not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        lossControlDao.insertLocationId(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        // Lookup ID Response
        lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());

        return importClientResponse;
    }


    public ImportClientResponse ifClientIsPresent(ImportClientResponse importClientResponse, ImportClientRequest importClientRequest, ArrayList<uk.co.allianz.rap.lc.model.request.importclient.Location> locations, String correlationId) throws CustomException, JsonProcessingException {
        //finding LC360 client id in DB exist or not
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        //finding LC360 location id in DB exist or not(combined location lookup ID and client id)
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
            //set client id and location id in pojo
            importClientRequest.getClient().setLookupID(lc360ClientId);
            locations.get(0).setLookupID(lc360LocationId);
            objectMapper.writeValueAsString(importClientRequest);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

        } else {
            log.info("lc360 location id not present");
        }
        return importClientResponse;
    }
}








package uk.co.allianz.rap.lc.dao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Map;

@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    //client methods
    @Override
    public void insertClientId(String client_id) {
        String insert = "insert into client_lookup(client_id) values(?)";
        int update = this.jdbcTemplate.update(insert, client_id);
    }

    @Override
    public void updateLcClientId(String client_id, String lc360_client_id) {
        String update = "update client_lookup set lc360_client_id = ? where client_id = ?";
        this.jdbcTemplate.update(update, lc360_client_id, client_id);
    }

    @Override
    public Map<String, Object> findByClientId(String client_id) {
        String checkClientId = "select * from client_lookup where client_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360ClientID(String client_id) {
        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360ClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    // Locations methods
    @Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}








package uk.co.allianz.rap.lc.cache;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

//1. Implement a  token caching logic within loss-control-service
@Slf4j
@Component
public class TokenCache {

    private static final String TOKEN_CACHE_NAME = "tokens";
    @Autowired
    protected JwtUtil jwtUtil;
    @Autowired
    protected CacheManager cacheManager;

    @Cacheable(value = TOKEN_CACHE_NAME)
    public String getToken() throws CustomException {

        // Retrieve the token from the cache or data source
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            Cache.ValueWrapper valueWrapper = cache.get(TOKEN_CACHE_NAME);
            if (valueWrapper != null) {
                return (String) valueWrapper.get();
            }
        }
        String tokenFromDataSource = retrieveTokenFromDataSource();
        log.info("Generated Token");
        // Cache the token for future use
        cacheToken(tokenFromDataSource);
        return tokenFromDataSource;
    }

    public String retrieveTokenFromDataSource() throws CustomException {
        // Perform the actual retrieval of the token from the jwtUtil class
        String jwtToken = jwtUtil.getAuthToken();
        return jwtToken;
    }

    //token store in cache
    public void cacheToken(final String token) {
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            cache.put(TOKEN_CACHE_NAME, token);
        }
    }

    //retrieve Token From Cache & request contains the correlation id
    public String retrieveTokenFromCache(final String correlationId) throws CustomException {
        if (log.isInfoEnabled()) {
            log.info("Start invoking for token : Correlation ID: " + correlationId);
        }
        String token = getToken();
        log.info("Token fetch from cache");
        if (log.isInfoEnabled()) {
            log.info("Successfully retrieved the token: Correlation ID: " + correlationId);
        }
        return token;
    }
}














package uk.co.allianz.rap.lc.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import uk.co.allianz.rap.lc.model.ServiceCallUrlModel;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importinspections.ImportInspectionsRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importinspections.ImportInspectionResponse;

@Slf4j
@Component
public class LossControlServiceImpl implements LossControlService {
    @Autowired
    private ServiceCallUrlModel seviceCallUrlModel;
    private WebClient webClient = WebClient.create();

    /***
     *     method used for invoke second LC360 api
     *     post http request
     *     input bearer token and related json data
     */
    @Override
    public ImportClientResponse clientPost(final ImportClientRequest importClientRequest, final String bearerToken) {
        //passing jwt bearer token into header
        HttpHeaders headers = new HttpHeaders();
        headers.add("Authorization", "Bearer " + bearerToken);
        log.info("Token set in header.");
        ImportClientResponse importClientResponse =
                webClient.post()
                        .uri(seviceCallUrlModel.getImportClientUrl())
                        .headers(httpHeaders -> httpHeaders.addAll(headers))
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(importClientRequest)
                        .retrieve()
                        .bodyToMono(ImportClientResponse.class)
                        .block();
        return importClientResponse;
    }

    /***
     *     method used for invoke third LC360 api
     *     post http request
     *     input bearer token and related json data
     */
    @Override
    public ImportInspectionResponse inspectionsPost(final ImportInspectionsRequest importInspectionsRequest, final String bearerToken) {
        //passing jwt bearer token into header
        HttpHeaders headers = new HttpHeaders();
        headers.add("Authorization", "Bearer " + bearerToken);
        log.info("Token set in header.");
        ImportInspectionResponse importInspectionResponse =
                webClient.post()
                        .uri(seviceCallUrlModel.getImportInspectionsUrl())
                        .headers(httpHeaders -> httpHeaders.addAll(headers))
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(importInspectionsRequest)
                        .retrieve()
                        .bodyToMono(ImportInspectionResponse.class)
                        .block();
        return importInspectionResponse;
    }
}





package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
//import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.Map;






/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        //finding client id in DB exist or not
        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {


            importClientResponse = ifClientIsPresent(importClientResponse, importClientRequest, locations, correlationId);
        } else {
            importClientResponse = getClientResponse(importClientResponse, importClientRequest, locations, correlationId);

        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }









////////////////////////
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest21 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws Exception {
        String json = "your_json_data_here";
        String correlationId = "your_correlation_id_here";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        importClientRequest.setClient(new Client()); // Initialize the Client object
        importClientRequest.getClient().setLookupID("sampleLookupID");
        importClientRequest.getClient().setLocations(new ArrayList<>()); // Initialize the Locations list

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("sampleLookupID")).thenReturn(new HashMap<>());

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }

    @Test
    public void testImportClientWhenClientDoesNotExist() throws Exception {
        String json = "your_json_data_here";
        String correlationId = "your_correlation_id_here";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        importClientRequest.setClient(new Client()); // Initialize the Client object
        importClientRequest.getClient().setLookupID("sampleLookupID");
        importClientRequest.getClient().setLocations(new ArrayList<>()); // Initialize the Locations list

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("sampleLookupID")).thenReturn(null);

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }

    // Add more test cases as needed
}







import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Collections;

import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest22 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws Exception {
        String json = "your_json_data_here";
        String correlationId = "your_correlation_id_here";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("sampleLookupID");
        client.setLocations(Collections.singletonList(new Location()));
        importClientRequest.setClient(client);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("sampleLookupID")).thenReturn(Collections.singletonMap("key", "value"));

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }

    @Test
    public void testImportClientWhenClientDoesNotExist() throws Exception {
        String json = "your_json_data_here";
        String correlationId = "your_correlation_id_here";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("sampleLookupID");
        client.setLocations(Collections.singletonList(new Location()));
        importClientRequest.setClient(client);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("sampleLookupID")).thenReturn(null);

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }

    // Add more test cases as needed
}









import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Collections;

import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest23 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws Exception {
        String json = "your_json_data_here";
        String correlationId = "your_correlation_id_here";

        ImportClientRequest importClientRequest = new ImportClientRequest(); // Create a sample request
        Client client = new Client();
        client.setLookupID("sampleLookupID");
        client.setLocations(Collections.emptyList());
        importClientRequest.setClient(client);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("sampleLookupID")).thenReturn(Collections.singletonMap("key", "value"));

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }

    @Test
    public void testImportClientWhenClientDoesNotExist() throws Exception {
        String json = "your_json_data_here";
        String correlationId = "your_correlation_id_here";

        ImportClientRequest importClientRequest = new ImportClientRequest(); // Create a sample request
        Client client = new Client();
        client.setLookupID("sampleLookupID");
        client.setLocations(Collections.emptyList());
        importClientRequest.setClient(client);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("sampleLookupID")).thenReturn(null);

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }

    // Add more test cases as needed
}






import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Collections;

import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest24 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws Exception {
        String json = "your_json_data_here";
        String correlationId = "your_correlation_id_here";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("sampleLookupID");
        client.setLocations(Collections.emptyList());
        importClientRequest.setClient(client);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("sampleLookupID")).thenReturn(Collections.singletonMap("key", "value"));

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }

    @Test
    public void testImportClientWhenClientDoesNotExist() throws Exception {
        String json = "your_json_data_here";
        String correlationId = "your_correlation_id_here";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("sampleLookupID");
        client.setLocations(Collections.emptyList());
        importClientRequest.setClient(client);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("sampleLookupID")).thenReturn(null);

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }

    // Add more test cases as needed
}






import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Collections;

import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest25 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws Exception {
        String json = "your_json_data_here";
        String correlationId = "your_correlation_id_here";

        ImportClientRequest importClientRequest = new ImportClientRequest(); // Create a sample request
        Client client = new Client();
        client.setLookupID("sampleLookupID");
        client.setLocations(Collections.emptyList());
        importClientRequest.setClient(client);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("sampleLookupID")).thenReturn(Collections.singletonMap("key", "value"));

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }

    @Test
    public void testImportClientWhenClientDoesNotExist() throws Exception {
        String json = "your_json_data_here";
        String correlationId = "your_correlation_id_here";

        ImportClientRequest importClientRequest = new ImportClientRequest(); // Create a sample request
        Client client = new Client();
        client.setLookupID("sampleLookupID");
        client.setLocations(Collections.emptyList());
        importClientRequest.setClient(client);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("sampleLookupID")).thenReturn(null);

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }

    // Add more test cases as needed
}




/////////////////////////////////////////////////
import static org.mockito.Mockito.*;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

public class ImportClientServiceImpTest11 {

    private ImportClientServiceImp importClientService;

    private TokenCache tokenCache;
    private LossControlDao lossControlDao;
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setup() {
        tokenCache = mock(TokenCache.class);
        lossControlDao = mock(LossControlDao.class);
        objectMapper = mock(ObjectMapper.class);

        importClientService = new ImportClientServiceImp(tokenCache, lossControlDao, objectMapper);
    }

    @Test
    public void testImportClientWhenClientExists() throws Exception {
        // Prepare mock objects and data
        String json = "your_test_json_here";
        String correlationId = "your_correlation_id_here";
        ImportClientRequest importClientRequest = mock(ImportClientRequest.class);
        ImportClientResponse importClientResponse = mock(ImportClientResponse.class);
        Location location = mock(Location.class);
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);

        // Stubbing/mock behavior
        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(importClientRequest.getClient()).thenReturn(client);
        when(client.getLocations()).thenReturn(locations);
        when(lossControlDao.findByClientId(any())).thenReturn(new HashMap<>());
        when(importClientService.ifClientIsPresent(any(), any(), any(), any())).thenReturn(importClientResponse);

        // Perform the test
        ImportClientResponse result = importClientService.importClient(json, correlationId);

        // Verify interactions
        verify(objectMapper).readValue(json, ImportClientRequest.class);
        verify(importClientService).ifClientIsPresent(any(), any(), any(), any());
        // Verify other interactions and assertions as needed
    }

    @Test
    public void testImportClientWhenClientDoesNotExist() throws Exception {
        // Similar setup and verification as the previous test, but with different stubbing and expectations
    }

    // Add more test cases as needed
    
}









import static org.mockito.Mockito.*;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

public class ImportClientServiceImpTest12 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlService;

    @Mock
    private ObjectMapper objectMapper;

    private ImportClientServiceImp importClientService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
        importClientService = new ImportClientServiceImp(tokenCache, lossControlDao, lossControlService, objectMapper);
    }

    @Test
    public void testImportClient_ClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest(/* initialize request data */);
        ImportClientResponse response = new ImportClientResponse(/* initialize response data */);

        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(request);
        when(lossControlDao.findByClientId(anyString())).thenReturn(new HashMap<>());
        when(lossControlService.ifClientIsPresent(any(), any(), anyList(), anyString())).thenReturn(response);

        ImportClientResponse result = importClientService.importClient("dummy_json", "correlationId");

        // Add assertions based on your requirements
    }

    @Test
    public void testImportClient_ClientDoesNotExist() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest(/* initialize request data */);
        ImportClientResponse response = new ImportClientResponse(/* initialize response data */);

        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(request);
        when(lossControlDao.findByClientId(anyString())).thenReturn(null);
        when(lossControlService.getClientResponse(any(), any(), anyList(), anyString())).thenReturn(response);

        ImportClientResponse result = importClientService.importClient("dummy_json", "correlationId");

        // Add assertions based on your requirements
    }

    // Add more test cases as needed

}






import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Collections;

import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest13 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws Exception {
        String json = "your_json_data_here";
        String correlationId = "your_correlation_id_here";

        ImportClientRequest importClientRequest = new ImportClientRequest(); // Create a sample request
        importClientRequest.getClient().setLookupID("sampleLookupID");
        importClientRequest.getClient().setLocations(Collections.emptyList());

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("sampleLookupID")).thenReturn(Collections.singletonMap("key", "value"));

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }

    @Test
    public void testImportClientWhenClientDoesNotExist() throws Exception {
        String json = "your_json_data_here";
        String correlationId = "your_correlation_id_here";

        ImportClientRequest importClientRequest = new ImportClientRequest(); // Create a sample request
        importClientRequest.getClient().setLookupID("sampleLookupID");
        importClientRequest.getClient().setLocations(Collections.emptyList());

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("sampleLookupID")).thenReturn(null);

        importClientService.importClient(json, correlationId);

        // Add your verification/assertion here
    }

    // Add more test cases as needed
}




import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;
import com.fasterxml.jackson.core.JsonProcessingException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest14 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your importClientRequest here

        ImportClientResponse mockResponse = new ImportClientResponse();
        // Set up your mock response here

        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId(anyString())).thenReturn(new HashMap<>());
        when(importClientService.ifClientIsPresent(any(), any(), any(), any())).thenReturn(mockResponse);

        ImportClientResponse result = importClientService.importClient("sampleJson", "correlationId");

        assertNotNull(result);
        assertEquals(mockResponse, result);

        verify(lossControlDao, times(1)).findByClientId(anyString());
        verify(importClientService, times(1)).ifClientIsPresent(any(), any(), any(), any());
    }

    @Test
    public void testImportClientWhenClientDoesNotExist() throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your importClientRequest here

        ImportClientResponse mockResponse = new ImportClientResponse();
        // Set up your mock response here

        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId(anyString())).thenReturn(null);
        when(importClientService.getClientResponse(any(), any(), any(), any())).thenReturn(mockResponse);

        ImportClientResponse result = importClientService.importClient("sampleJson", "correlationId");

        assertNotNull(result);
        assertEquals(mockResponse, result);

        verify(lossControlDao, times(1)).findByClientId(anyString());
        verify(importClientService, times(1)).getClientResponse(any(), any(), any(), any());
    }
}





import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientService;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

class ImportClientServiceImpTest15 {

    @Mock
    private TokenCache tokenCache;
    
    @Mock
    private LossControlDao lossControlDao;
    
    @Mock
    private ObjectMapper objectMapper;
    
    @InjectMocks
    private ImportClientService importClientService = new ImportClientServiceImp();

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testImportClientWhenClientExists() throws CustomException, JsonProcessingException {
        // Mocking input data
        String json = "{\"client\": {\"lookupID\": \"123\", \"locations\": []}}";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        importClientRequest.setClient(new ImportClientRequest.Client());
        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);

        Map<String, Object> clientResult = new HashMap<>();
        when(lossControlDao.findByClientId("123")).thenReturn(clientResult);

        ImportClientResponse response = new ImportClientResponse();
        when(importClientService.ifClientIsPresent(any(), any(), any(), any())).thenReturn(response);

        // Execute the method
        ImportClientResponse result = importClientService.importClient(json, "correlationId");

        // Verify the interactions and assertions
        verify(lossControlDao).findByClientId("123");
        verify(importClientService).ifClientIsPresent(any(), any(), any(), any());
        assertEquals(response, result);
    }

    @Test
    void testImportClientWhenClientNotExists() throws CustomException, JsonProcessingException {
        // Mocking input data
        String json = "{\"client\": {\"lookupID\": \"123\", \"locations\": []}}";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        importClientRequest.setClient(new ImportClientRequest.Client());
        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);

        when(lossControlDao.findByClientId("123")).thenReturn(null);

        ImportClientResponse response = new ImportClientResponse();
        when(importClientService.getClientResponse(any(), any(), any(), any())).thenReturn(response);

        // Execute the method
        ImportClientResponse result = importClientService.importClient(json, "correlationId");

        // Verify the interactions and assertions
        verify(lossControlDao).findByClientId("123");
        verify(importClientService).getClientResponse(any(), any(), any(), any());
        assertEquals(response, result);
    }
}






///////////////////////////////////////////////////////////////
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.Map;

import static org.mockito.Mockito.*;

class ClientLocationTest91 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ImportClientRequest importClientRequest;

    @Mock
    private ImportClientResponse importClientResponse;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ClientLocation clientLocation;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testIfClientIsPresentWithClientIdAndLocationIdInDB() throws CustomException, JsonProcessingException {
        String correlationId = "correlation-id";

        // Mocking required objects and behaviors
        Map<String, Object> mockClientIdMap = mock(Map.class);
        when(mockClientIdMap.keySet()).thenReturn(Set.of("some-key"));
        when(mockClientIdMap.get("some-key")).thenReturn("lc360-client-id");

        Map<String, Object> mockLocationIdMap = mock(Map.class);
        when(mockLocationIdMap.keySet()).thenReturn(Set.of("some-key"));
        when(mockLocationIdMap.get("some-key")).thenReturn("lc360-location-id");

        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(mockClientIdMap);
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(mockLocationIdMap);

        when(importClientRequest.getClient()).thenReturn(new Client());
        ArrayList<uk.co.allianz.rap.lc.model.request.importclient.Location> locations = new ArrayList<>();
        uk.co.allianz.rap.lc.model.request.importclient.Location mockLocation = mock(uk.co.allianz.rap.lc.model.request.importclient.Location.class);
        when(mockLocation.getLookupID()).thenReturn("test-location-lookup-id");
        locations.add(mockLocation);

        ImportClientResponse mockResponse = mock(ImportClientResponse.class);
        when(lossControlServiceImpl.clientPost(importClientRequest, "test-token")).thenReturn(mockResponse);

        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn("test-token");

        // Call the method under test
        ImportClientResponse result = clientLocation.ifClientIsPresent(importClientResponse, importClientRequest, locations, correlationId);

        // Verify the interactions within the method
        verify(lossControlDao, times(1)).findLc360ClientID(anyString());
        verify(lossControlDao, times(1)).findLc360LocationID(anyString());
        verify(mockClientIdMap, times(1)).keySet();
        verify(mockLocationIdMap, times(1)).keySet();
        verify(mockClientIdMap, times(1)).get("some-key");
        verify(mockLocationIdMap, times(1)).get("some-key");
        verify(importClientRequest.getClient(), times(1)).setLookupID("lc360-client-id");
        verify(mockLocation, times(1)).setLookupID("lc360-location-id");
        verify(lossControlServiceImpl, times(1)).clientPost(importClientRequest, "test-token");
        verify(tokenCache, times(1)).retrieveTokenFromCache(correlationId);

        // Verify that the result is returned as expected
        assertEquals(mockResponse, result);
    }

    // Add other test cases here
}













import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importclient.Location;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.mockito.Mockito.*;

class ClientLocationTest92 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ClientLocation clientLocation;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testIfClientIsPresent_ClientIdAndLocationIdPresent() throws CustomException, JsonProcessingException {
        String correlationId = "correlation-id";
        String lc360ClientId = "test-lc360-client-id";
        String lc360LocationId = "test-lc360-location-id";

        ImportClientResponse importClientResponse = mock(ImportClientResponse.class);
        ImportClientRequest importClientRequest = mock(ImportClientRequest.class);
        ArrayList<uk.co.allianz.rap.lc.model.request.importclient.Location> locations = new ArrayList<>();
        uk.co.allianz.rap.lc.model.request.importclient.Location mockLocation = mock(uk.co.allianz.rap.lc.model.request.importclient.Location.class);
        when(mockLocation.getLookupID()).thenReturn("test-location-lookup-id");
        locations.add(mockLocation);

        Map<String, Object> lcClientId = new HashMap<>();
        lcClientId.put("key", lc360ClientId);

        Map<String, Object> lcLocationId = new HashMap<>();
        lcLocationId.put("key", lc360LocationId);

        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(lcClientId);
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(lcLocationId);

        Client mockClient = mock(Client.class);
        when(importClientRequest.getClient()).thenReturn(mockClient);

        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn("test-token");
        when(lossControlServiceImpl.clientPost(importClientRequest, "test-token")).thenReturn(importClientResponse);

        ImportClientResponse result = clientLocation.ifClientIsPresent(importClientResponse, importClientRequest, locations, correlationId);

        verify(importClientRequest.getClient()).setLookupID(lc360ClientId);
        verify(locations.get(0)).setLookupID(lc360LocationId);
        verify(objectMapper).writeValueAsString(importClientRequest);
        verify(lossControlServiceImpl).clientPost(importClientRequest, "test-token");
        verify(lossControlDao, never()).insertClientId(anyString());
        verify(lossControlDao, never()).insertLocationId(anyString());

        // Add more verification/assertions as needed
    }
    
    @Test
    void testIfClientIsPresent_ClientIdNotPresent() throws CustomException, JsonProcessingException {
        // Similar test case for when lcClientId is null
    }

    @Test
    void testIfClientIsPresent_LcLocationIdNotPresent() throws CustomException, JsonProcessingException {
        // Similar test case for when lcLocationId is null
    }

    // Define other test cases here if needed
}





import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importclient.Location;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.mockito.Mockito.*;

class ClientLocationTest93 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ImportClientRequest importClientRequest;

    @Mock
    private ImportClientResponse importClientResponse;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ClientLocation clientLocation;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testIfClientIsPresentWhenLcClientIdExists() throws CustomException, JsonProcessingException {
        String correlationId = "correlation-id";
        String lcClientIdValue = "test-lc360-client-id";
        String lcLocationIdValue = "test-lc360-location-id";

        // Mocking required objects
        Map<String, Object> lcClientIdMap = new HashMap<>();
        lcClientIdMap.put("someKey", lcClientIdValue);
        Map<String, Object> lcLocationIdMap = new HashMap<>();
        lcLocationIdMap.put("someKey", lcLocationIdValue);

        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(lcClientIdMap);
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(lcLocationIdMap);

        // Mock client and location objects
        Client mockClient = mock(Client.class);
        when(importClientRequest.getClient()).thenReturn(mockClient);
        uk.co.allianz.rap.lc.model.request.importclient.Location mockLocation = mock(uk.co.allianz.rap.lc.model.request.importclient.Location.class);
        ArrayList<uk.co.allianz.rap.lc.model.request.importclient.Location> locations = new ArrayList<>();
        locations.add(mockLocation);

        when(mockClient.getLookupID()).thenReturn("test-client-lookup-id");
        when(mockLocation.getLookupID()).thenReturn("test-location-lookup-id");

        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn("test-token");
        when(lossControlServiceImpl.clientPost(importClientRequest, "test-token")).thenReturn(importClientResponse);

        // Call the method under test
        clientLocation.ifClientIsPresent(importClientResponse, importClientRequest, locations, correlationId);

        // Verify the interactions within the method
        verify(importClientRequest.getClient(), times(1)).setLookupID(lcClientIdValue);
        verify(mockLocation, times(1)).setLookupID(lcLocationIdValue);
        verify(lossControlServiceImpl, times(1)).clientPost(importClientRequest, "test-token");
        // Verify other interactions and assertions here
    }
    
    // Define other test cases here if needed
}






import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.mockito.Mockito.*;

class ClientLocationTest94 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ClientLocation clientLocation;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testIfClientIsPresent() throws CustomException, JsonProcessingException {
        String correlationId = "correlation-id";

        ImportClientRequest mockImportClientRequest = mock(ImportClientRequest.class);
        ImportClientResponse importClientResponse = mock(ImportClientResponse.class);

        ArrayList<uk.co.allianz.rap.lc.model.request.importclient.Location> locations = new ArrayList<>();
        uk.co.allianz.rap.lc.model.request.importclient.Location mockLocation = mock(uk.co.allianz.rap.lc.model.request.importclient.Location.class);
        when(mockLocation.getLookupID()).thenReturn("test-location-lookup-id"); // Adjust based on your actual Location class
        locations.add(mockLocation);

        Client mockClient = mock(Client.class);
        when(mockClient.getLookupID()).thenReturn("test-client-lookup-id");

        when(mockImportClientRequest.getClient()).thenReturn(mockClient);

        Map<String, Object> lcClientId = new HashMap<>();
        lcClientId.put("key", "test-lc360-client-id");
        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(lcClientId);

        Map<String, Object> lcLocationId = new HashMap<>();
        lcLocationId.put("key", "test-lc360-location-id");
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(lcLocationId);

        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn("test-token");

        when(lossControlServiceImpl.clientPost(mockImportClientRequest, "test-token")).thenReturn(importClientResponse);

        when(objectMapper.writeValueAsString(mockImportClientRequest)).thenReturn("test-json");

        ImportClientResponse result = clientLocation.ifClientIsPresent(importClientResponse, mockImportClientRequest, locations, correlationId);

        verify(mockClient).setLookupID("test-lc360-client-id");
        verify(mockLocation).setLookupID("test-lc360-location-id");
        verify(objectMapper).writeValueAsString(mockImportClientRequest);
        verify(lossControlServiceImpl).clientPost(mockImportClientRequest, "test-token");
        verify(importClientResponse, never()).getResult(); // Assuming you don't need to access the result in this test case

        // Add assertions as needed for the result
    }

    // Define other test cases here if needed
}






import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importclient.Location;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;
import com.fasterxml.jackson.core.JsonProcessingException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.mockito.Mockito.*;

class ClientLocationTest95 {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ImportClientRequest importClientRequest;

    @Mock
    private ImportClientResponse importClientResponse;

    @Mock
    private Client client;

    @Mock
    private Location location;

    @InjectMocks
    private ClientLocation clientLocation;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testIfClientIsPresentWhenLCClientIdExists() throws CustomException, JsonProcessingException {
        String correlationId = "correlation-id";

        // Mocking required objects
        Map<String, Object> lcClientIdMap = new HashMap<>();
        lcClientIdMap.put("lcClientId", "test-lc-client-id");
        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(lcClientIdMap);

        Map<String, Object> lcLocationIdMap = new HashMap<>();
        lcLocationIdMap.put("lcLocationId", "test-lc-location-id");
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(lcLocationIdMap);

        when(importClientRequest.getClient()).thenReturn(client);
        when(client.getLookupID()).thenReturn("test-client-lookup-id");

        ArrayList<uk.co.allianz.rap.lc.model.request.importclient.Location> locations = new ArrayList<>();
        locations.add(location);
        when(location.getLookupID()).thenReturn("test-location-lookup-id");

        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn("test-token");

        when(lossControlServiceImpl.clientPost(importClientRequest, "test-token")).thenReturn(importClientResponse);

        clientLocation.ifClientIsPresent(importClientResponse, importClientRequest, locations, correlationId);

        verify(client, times(1)).setLookupID("test-lc-client-id");
        verify(location, times(1)).setLookupID("test-lc-location-id");
        verify(lossControlServiceImpl, times(1)).clientPost(importClientRequest, "test-token");
    }

    @Test
    void testIfClientIsPresentWhenLCClientIdDoesNotExist() throws CustomException, JsonProcessingException {
        String correlationId = "correlation-id";

        // Mocking required objects
        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(null);

        ArrayList<uk.co.allianz.rap.lc.model.request.importclient.Location> locations = new ArrayList<>();
        locations.add(location);
        when(location.getLookupID()).thenReturn("test-location-lookup-id");

        ImportClientResponse response = clientLocation.ifClientIsPresent(importClientResponse, importClientRequest, locations, correlationId);

        verifyZeroInteractions(location);
        verifyZeroInteractions(lossControlServiceImpl);

        // Asserting that the method returns the same input response
        assertEquals(importClientResponse, response);
    }

    // Define other test cases here if needed
}


//////////////////////////////////////////////////////////////////////////////////////////
08:57:26.278 [main] INFO uk.co.allianz.rap.lc.util.ClientLocation -- Client and Location are not present

java.lang.NullPointerException: Cannot invoke "uk.co.allianz.rap.lc.model.request.importclient.Client.getLookupID()" because the return value of "uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest.getClient()" is null



        clientLocation.getClientResponse(importClientResponse, importClientRequest, locations, correlationId);
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
































package uk.co.allianz.rap.lc.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import uk.co.allianz.rap.lc.model.ServiceCallUrlModel;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importinspections.ImportInspectionsRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importinspections.ImportInspectionResponse;

@Slf4j
@Component
public class LossControlServiceImpl implements LossControlService {
    @Autowired
    private ServiceCallUrlModel seviceCallUrlModel;
    private WebClient webClient = WebClient.create();

    /***
     *     method used for invoke second LC360 api
     *     post http request
     *     input bearer token and related json data
     */
    @Override
    public ImportClientResponse clientPost(final ImportClientRequest importClientRequest, final String bearerToken) {
        //passing jwt bearer token into header
        HttpHeaders headers = new HttpHeaders();
        headers.add("Authorization", "Bearer " + bearerToken);
        log.info("Token set in header.");
        ImportClientResponse importClientResponse =
                webClient.post()
                        .uri(seviceCallUrlModel.getImportClientUrl())
                        .headers(httpHeaders -> httpHeaders.addAll(headers))
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(importClientRequest)
                        .retrieve()
                        .bodyToMono(ImportClientResponse.class)
                        .block();
        return importClientResponse;
    }

    /***
     *     method used for invoke third LC360 api
     *     post http request
     *     input bearer token and related json data
     */
    @Override
    public ImportInspectionResponse inspectionsPost(final ImportInspectionsRequest importInspectionsRequest, final String bearerToken) {
        //passing jwt bearer token into header
        HttpHeaders headers = new HttpHeaders();
        headers.add("Authorization", "Bearer " + bearerToken);
        log.info("Token set in header.");
        ImportInspectionResponse importInspectionResponse =
                webClient.post()
                        .uri(seviceCallUrlModel.getImportInspectionsUrl())
                        .headers(httpHeaders -> httpHeaders.addAll(headers))
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(importInspectionsRequest)
                        .retrieve()
                        .bodyToMono(ImportInspectionResponse.class)
                        .block();
        return importInspectionResponse;
    }
}










package uk.co.allianz.rap.lc.dao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Map;

@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    //client methods
    @Override
    public void insertClientId(String client_id) {
        String insert = "insert into client_lookup(client_id) values(?)";
        int update = this.jdbcTemplate.update(insert, client_id);
    }

    @Override
    public void updateLcClientId(String client_id, String lc360_client_id) {
        String update = "update client_lookup set lc360_client_id = ? where client_id = ?";
        this.jdbcTemplate.update(update, lc360_client_id, client_id);
    }

    @Override
    public Map<String, Object> findByClientId(String client_id) {
        String checkClientId = "select * from client_lookup where client_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360ClientID(String client_id) {
        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360ClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    // Locations methods
    @Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}













package uk.co.allianz.rap.lc.cache;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

//1. Implement a  token caching logic within loss-control-service
@Slf4j
@Component
public class TokenCache {

    private static final String TOKEN_CACHE_NAME = "tokens";
    @Autowired
    protected JwtUtil jwtUtil;
    @Autowired
    protected CacheManager cacheManager;

    @Cacheable(value = TOKEN_CACHE_NAME)
    public String getToken() throws CustomException {

        // Retrieve the token from the cache or data source
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            Cache.ValueWrapper valueWrapper = cache.get(TOKEN_CACHE_NAME);
            if (valueWrapper != null) {
                return (String) valueWrapper.get();
            }
        }
        String tokenFromDataSource = retrieveTokenFromDataSource();
        log.info("Generated Token");
        // Cache the token for future use
        cacheToken(tokenFromDataSource);
        return tokenFromDataSource;
    }

    public String retrieveTokenFromDataSource() throws CustomException {
        // Perform the actual retrieval of the token from the jwtUtil class
        String jwtToken = jwtUtil.getAuthToken();
        return jwtToken;
    }

    //token store in cache
    public void cacheToken(final String token) {
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            cache.put(TOKEN_CACHE_NAME, token);
        }
    }

    //retrieve Token From Cache & request contains the correlation id
    public String retrieveTokenFromCache(final String correlationId) throws CustomException {
        if (log.isInfoEnabled()) {
            log.info("Start invoking for token : Correlation ID: " + correlationId);
        }
        String token = getToken();
        log.info("Token fetch from cache");
        if (log.isInfoEnabled()) {
            log.info("Successfully retrieved the token: Correlation ID: " + correlationId);
        }
        return token;
    }
}









package uk.co.allianz.rap.lc.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importclient.Location;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.Map;

@Slf4j
@Service
public class ClientLocation {
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse getClientResponse(ImportClientResponse importClientResponse, ImportClientRequest importClientRequest, ArrayList<uk.co.allianz.rap.lc.model.request.importclient.Location> locations, String correlationId) throws CustomException {
        log.info("Client and Location are not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        lossControlDao.insertLocationId(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
        ArrayList<Location> locationsResponse = importClientResponse.getResult().getLocations();
        // Lookup ID Response
        lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());

        return importClientResponse;
    }

    public ImportClientResponse ifClientIsPresent(ImportClientResponse importClientResponse, ImportClientRequest importClientRequest, ArrayList<uk.co.allianz.rap.lc.model.request.importclient.Location> locations, String correlationId) throws CustomException, JsonProcessingException {
        //finding LC360 client id in DB exist or not
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        //finding LC360 location id in DB exist or not(combined location lookup ID and client id)
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
            //set client id and location id in pojo
            importClientRequest.getClient().setLookupID(lc360ClientId);
            locations.get(0).setLookupID(lc360LocationId);
            objectMapper.writeValueAsString(importClientRequest);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

        } else {
            log.info("lc360 location id not present");
        }
        return importClientResponse;
    }
}






































java.lang.NullPointerException: Cannot invoke "com.fasterxml.jackson.databind.ObjectMapper.readValue(String, java.lang.Class)" because "this.objectMapper" is null

        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);


        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);






import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest21 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private ClientLocation clientLocation;

    private final ObjectMapper objectMapper = new ObjectMapper();

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientIsPresent() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "Your JSON String here";
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        // Mock behavior of lossControlDao and clientLocation
        when(lossControlDao.findByClientId(anyString())).thenReturn(new HashMap<>());
        when(clientLocation.ifClientIsPresent(any(), any(), any(), any())).thenReturn(new ImportClientResponse());

        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);
        
        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case

        // Verify method calls
        verify(lossControlDao).findByClientId(anyString());
        verify(clientLocation).ifClientIsPresent(any(), any(), any(), any());
        verifyNoMoreInteractions(lossControlDao, clientLocation);
    }
}



import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest22 {

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private ClientLocation clientLocation;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    private final ObjectMapper objectMapper = new ObjectMapper();

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientIsPresent() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "Your JSON String here";
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        // Stubbing the behavior of mock objects
        when(lossControlDao.findByClientId(anyString())).thenReturn(new HashMap<>());
        when(clientLocation.ifClientIsPresent(any(), any(), any(), any())).thenReturn(new ImportClientResponse());
        
        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);
        
        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case
        
        // Verify interactions
        verify(lossControlDao, times(1)).findByClientId(anyString());
        verify(clientLocation, times(1)).ifClientIsPresent(any(), any(), any(), any());
    }
}



import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.util.ClientLocation;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

public class ImportClientServiceImpTest23 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private ClientLocation clientLocation;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientIsPresent() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "Your JSON String here";
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = new ImportClientRequest(); // Initialize with required data
        ArrayList<Location> locations = new ArrayList<>(); // Initialize with required data
        importClientRequest.getClient().setLocations(locations);
        
        // Mock behavior of lossControlDao
        when(lossControlDao.findByClientId(any())).thenReturn(new HashMap<>());
        
        // Mock behavior of objectMapper
        when(objectMapper.readValue(any(String.class), any(Class.class))).thenReturn(importClientRequest);
        
        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);
        
        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case
    }
    
    // Similar test for the case when client is not present
}


//
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest4 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private ClientLocation clientLocation;

    @Mock
    private LossControlDao lossControlDao;

    private final ObjectMapper objectMapper = new ObjectMapper();

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientIsPresent() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "Your JSON String here";
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        // Mock client data presence in the database
        when(lossControlDao.findByClientId(importClientRequest.getClient().getLookupID()))
                .thenReturn(new HashMap<>());

        // Mock clientLocation behavior
        when(clientLocation.ifClientIsPresent(any(), any(), any(), any()))
                .thenReturn(new ImportClientResponse());

        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case

        // Verify interactions
        verify(lossControlDao, times(1)).findByClientId(importClientRequest.getClient().getLookupID());
        verify(clientLocation, times(1)).ifClientIsPresent(any(), any(), any(), any());
    }

    // Similar test case for when client is not present
}





///
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest5 {

    @Mock
    private ClientLocation clientLocation;

    @Mock
    private LossControlDao lossControlDao;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    private final ObjectMapper objectMapper = new ObjectMapper();

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClientWhenClientIsPresent() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "Your JSON String here";
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        // Mock behavior of lossControlDao
        when(lossControlDao.findByClientId(any())).thenReturn(new HashMap<>());

        // Mock behavior of clientLocation
        ImportClientResponse mockedResponse = new ImportClientResponse(); // Create a mocked response
        when(clientLocation.ifClientIsPresent(any(), any(), any(), any())).thenReturn(mockedResponse);

        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case

        // Verify that the methods were called as expected
        verify(lossControlDao, times(1)).findByClientId(any());
        verify(clientLocation, times(1)).ifClientIsPresent(any(), any(), any(), any());
    }
    
    // Similar test for testImportClientWhenClientIsNotPresent
}







//////////////////////
@Test
    public void testImportClientWhenClientIsPresent() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "{\n" +
                "  \"divisionLookupID\" : \"AZ_UK\",\n" +
                "  \"client\" : {\n" +
                "    \"LookupID\" : \"C008032905\",\n" +
                "    \"ContactFirstName\" : null,\n" +
                "    \"ContactLastName\" : null,\n" +
                "    \"PolicyNumber\" : \"SP26853149\",\n" +
                "    \"Name\" : \"CLIENT CI Test\",\n" +
                "    \"Phone\" : null,\n" +
                "    \"Email\" : null,\n" +
                "    \"Address\" : {\n" +
                "      \"Country\" : \"United Kingdom\",\n" +
                "      \"OverseasTerritories\" : null,\n" +
                "      \"Street1\" : null,\n" +
                "      \"Street2\" : null,\n" +
                "      \"City\" : null,\n" +
                "      \"Region1\" : null,\n" +
                "      \"Region2\" : null,\n" +
                "      \"Region3\" : null,\n" +
                "      \"Region4\" : null,\n" +
                "      \"ZipCode\" : null\n" +
                "    },\n" +
                "    \"Agent\" : {\n" +
                "      \"AgencyCode\" : \"22576\",\n" +
                "      \"AgencyName\" : \"Arthur J. Gallagher\",\n" +
                "      \"AgentCode\" : \"13332\",\n" +
                "      \"AgentName\" : null,\n" +
                "      \"Email\" : null,\n" +
                "      \"FaxNumber\" : null,\n" +
                "      \"PhoneNumber\" : null,\n" +
                "      \"Address\" : {\n" +
                "        \"Country\" : \"GB\",\n" +
                "        \"OverseasTerritories\" : null,\n" +
                "        \"Street1\" : null,\n" +
                "        \"Street2\" : null,\n" +
                "        \"City\" : null,\n" +
                "        \"Region1\" : null,\n" +
                "        \"Region2\" : null,\n" +
                "        \"Region3\" : null,\n" +
                "        \"Region4\" : null,\n" +
                "        \"ZipCode\" : null\n" +
                "      },\n" +
                "      \"AgentType\" : \"Broker\"\n" +
                "    },\n" +
                "    \"Underwriter\" : null,\n" +
                "    \"Locations\" : [ {\n" +
                "      \"genericFields\" : null,\n" +
                "      \"LookupID\" : \"111105\",\n" +
                "      \"Name\" : null,\n" +
                "      \"PolicyNumber\" : \"SP26853148\",\n" +
                "      \"PolicyEffectiveDate\" : null,\n" +
                "      \"PolicyExpirationDate\" : null,\n" +
                "      \"PolicyRenewalDate\" : null,\n" +
                "      \"Address\" : {\n" +
                "        \"Country\" : \"United Kingdom\",\n" +
                "        \"OverseasTerritories\" : null,\n" +
                "        \"Street1\" : \"NEW CROSS DEWEL\",\n" +
                "        \"Street2\" : \"SD 11 JEW TOWN\",\n" +
                "        \"City\" : \"MM KEMSTONE\",\n" +
                "        \"Region1\" : \"UK\",\n" +
                "        \"Region2\" : null,\n" +
                "        \"Region3\" : null,\n" +
                "        \"Region4\" : null,\n" +
                "        \"ZipCode\" : \"GU1 1DB\"\n" +
                "      },\n" +
                "      \"OriginalEffectiveDate\" : null,\n" +
                "      \"EffectiveDate\" : null,\n" +
                "      \"ExpirationDate\" : null,\n" +
                "      \"RenewalDate\" : \"2024-07-17\",\n" +
                "      \"LastInspectedDate\" : null,\n" +
                "      \"Coverages\" : [ {\n" +
                "        \"CoverageTypeLookup\" : \"PD_TIV\",\n" +
                "        \"CoverageReference\" : \"Coverage 1\",\n" +
                "        \"GenericFields\" : [ {\n" +
                "          \"Number\" : \"1123\",\n" +
                "          \"Key\" : \"01. PD Building\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : \"0\",\n" +
                "          \"Key\" : \"04. PD Other\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : null,\n" +
                "          \"Key\" : \"05. PD Other Description\",\n" +
                "          \"GenericFieldValueType\" : 0,\n" +
                "          \"Text\" : \"\"\n" +
                "        }, {\n" +
                "          \"Number\" : \"1123\",\n" +
                "          \"Key\" : \"06. TIV PD\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : \"332198\",\n" +
                "          \"Key\" : \"07. TIV BI\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : \"\",\n" +
                "          \"Key\" : \"08. BI Base Period (Months)\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        }, {\n" +
                "          \"Number\" : \"332198\",\n" +
                "          \"Key\" : \"09. TIV (PD + BI )\",\n" +
                "          \"GenericFieldValueType\" : 1,\n" +
                "          \"Text\" : null\n" +
                "        } ]\n" +
                "      } ],\n" +
                "      \"Contact\" : null\n" +
                "    } ]\n" +
                "  }\n" +
                "}";
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        // Insert mock client data in the database
//        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        
        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);
        
        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case
    }














//////////////////////
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest1 {

    private ImportClientServiceImp importClientService;
    private ClientLocation clientLocation;
    private LossControlDao lossControlDao;
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        clientLocation = new ClientLocation();
        lossControlDao = mock(LossControlDao.class);
        objectMapper = new ObjectMapper();
        importClientService = new ImportClientServiceImp();
        importClientService.setClientLocation(clientLocation);
        importClientService.setLossControlDao(lossControlDao);
        importClientService.setObjectMapper(objectMapper);
    }

    @Test
    public void testImportClient_ClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        importClientRequest.getClient().setLookupID("existingClientId");
        ArrayList<Location> locations = new ArrayList<>();
        importClientRequest.getClient().setLocations(locations);

        Map<String, Object> clientResult = new HashMap<>();
        clientResult.put("lc360_client_id", "existingLc360ClientId");
        when(lossControlDao.findByClientId("existingClientId")).thenReturn(clientResult);

        ImportClientResponse response = new ImportClientResponse();
        when(clientLocation.ifClientIsPresent(any(), any(), any(), any())).thenReturn(response);

        ImportClientResponse importClientResponse = importClientService.importClient("json", "correlationId");

        verify(clientLocation, times(1)).ifClientIsPresent(any(), any(), any(), any());
        assertEquals(response, importClientResponse);
    }

    @Test
    public void testImportClient_ClientNotExists() throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = new ImportClientRequest();
        importClientRequest.getClient().setLookupID("newClientId");
        ArrayList<Location> locations = new ArrayList<>();
        importClientRequest.getClient().setLocations(locations);

        when(lossControlDao.findByClientId("newClientId")).thenReturn(null);

        ImportClientResponse response = new ImportClientResponse();
        when(clientLocation.getClientResponse(any(), any(), any(), any())).thenReturn(response);

        ImportClientResponse importClientResponse = importClientService.importClient("json", "correlationId");

        verify(clientLocation, times(1)).getClientResponse(any(), any(), any(), any());
        assertEquals(response, importClientResponse);
    }
}










import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.context.SpringBootTest;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

@SpringBootTest
@AutoConfigureTestDatabase
public class ImportClientServiceImpTest2 {

    @Autowired
    private ImportClientServiceImp importClientService;

    @Autowired
    private LossControlDao lossControlDao;

    @BeforeEach
    public void setup() {
        // Initialize your in-memory database or perform any setup here
    }

    @Test
    public void testImportClientExistingClient() throws CustomException, JsonProcessingException {
        // Create a test ImportClientRequest
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("existingClientId");
        importClientRequest.setClient(client);
        ArrayList<Location> locations = new ArrayList<>();
        Location location = new Location();
        location.setLookupID("locationId");
        locations.add(location);
        client.setLocations(locations);

        // Insert a mock client entry into the database
        lossControlDao.insertClientId("existingClientId");

        // Call the importClient method
        ImportClientResponse importClientResponse = importClientService.importClient("testJson", "correlationId");

        // Assertions
        assertNotNull(importClientResponse);
        assertEquals("expectedValue", importClientResponse.getSomeValue()); // Adjust as needed
    }

    @Test
    public void testImportClientNewClient() throws CustomException, JsonProcessingException {
        // Create a test ImportClientRequest
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("newClientId");
        importClientRequest.setClient(client);
        ArrayList<Location> locations = new ArrayList<>();
        Location location = new Location();
        location.setLookupID("locationId");
        locations.add(location);
        client.setLocations(locations);

        // Call the importClient method
        ImportClientResponse importClientResponse = importClientService.importClient("testJson", "correlationId");

        // Assertions
        assertNotNull(importClientResponse);
        assertEquals("expectedValue", importClientResponse.getSomeValue()); // Adjust as needed
    }
}


//
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.context.SpringBootTest;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@AutoConfigureTestDatabase
public class ImportClientServiceIntegrationTest3 {

    @Autowired
    private ImportClientServiceImp importClientService;

    @Autowired
    private LossControlDao lossControlDao;

    @Test
    public void testImportClientNewClient() throws Exception {
        String json = "{\"client\": {\"lookupID\": \"newClientID\", \"locations\": [{\"lookupID\": \"loc1\"}]}}";
        ImportClientResponse response = importClientService.importClient(json, "correlationId");

        assertNotNull(response);
        assertNotNull(response.getResult());
        assertNotNull(response.getResult().getClientLookupID());
    }

    @Test
    public void testImportClientExistingClient() throws Exception {
        // Assuming an existing client in the database
        lossControlDao.insertClientId("existingClientID");
        
        String json = "{\"client\": {\"lookupID\": \"existingClientID\", \"locations\": [{\"lookupID\": \"loc1\"}]}}";
        ImportClientResponse response = importClientService.importClient(json, "correlationId");

        assertNotNull(response);
        assertNotNull(response.getResult());
        assertNotNull(response.getResult().getClientLookupID());
    }
}


//
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

@SpringBootTest
@ActiveProfiles("test")
public class ImportClientServiceImpTest4 {

    @Autowired
    private ImportClientServiceImp importClientService;

    @Autowired
    private LossControlDao lossControlDao;

    private final ObjectMapper objectMapper = new ObjectMapper();

    @BeforeEach
    public void setUp() {
        // Setup any necessary data or configurations
    }

    @Test
    public void testImportClientWhenClientIsPresent() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "Your JSON String here";
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        // Insert mock client data in the database
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        
        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);
        
        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case
    }

    @Test
    public void testImportClientWhenClientIsNotPresent() throws CustomException, JsonProcessingException {
        // Prepare test data
        String json = "Your JSON String here";
        String correlationId = "correlation123";
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        // No mock client data in the database
        
        // Execute the method
        ImportClientResponse importClientResponse = importClientService.importClient(json, correlationId);
        
        // Assertions
        assertNotNull(importClientResponse);
        // Add more assertions based on your use case
    }
}



//

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.util.ClientLocation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest5 {

    private ImportClientServiceImp importClientService;
    private ClientLocation clientLocation;
    private LossControlDao lossControlDao;
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        clientLocation = new ClientLocation();
        lossControlDao = new LossControlDaoImpl(); // Use actual implementation for testing
        objectMapper = new ObjectMapper();

        importClientService = new ImportClientServiceImp();
        importClientService.clientLocation = clientLocation;
        importClientService.lossControlDao = lossControlDao;
        importClientService.objectMapper = objectMapper;
    }

    @Test
    void testImportClient_ExistingClient() throws CustomException, JsonProcessingException {
        // Arrange
        String json = "{\"client\": {\"lookupID\": \"123\", \"locations\": []}}";
        String correlationId = "correlationId";
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

        Map<String, Object> clientResult = new HashMap<>();
        clientResult.put("lc360_client_id", "lc123");
        when(lossControlDao.findByClientId("123")).thenReturn(clientResult);

        ImportClientResponse expectedResponse = new ImportClientResponse();
        when(clientLocation.ifClientIsPresent(any(), eq(importClientRequest), any(), eq(correlationId)))
                .thenReturn(expectedResponse);

        // Act
        ImportClientResponse actualResponse = importClientService.importClient(json, correlationId);

        // Assert
        assertEquals(expectedResponse, actualResponse);
        verify(lossControlDao).findByClientId("123");
        verify(clientLocation).ifClientIsPresent(any(), eq(importClientRequest), any(), eq(correlationId));
    }

    @Test
    void testImportClient_NewClient() throws CustomException, JsonProcessingException {
        // Arrange
        String json = "{\"client\": {\"lookupID\": \"456\", \"locations\": []}}";
        String correlationId = "correlationId";
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

        when(lossControlDao.findByClientId("456")).thenReturn(null);

        ImportClientResponse expectedResponse = new ImportClientResponse();
        when(clientLocation.getClientResponse(any(), eq(importClientRequest), any(), eq(correlationId)))
                .thenReturn(expectedResponse);

        // Act
        ImportClientResponse actualResponse = importClientService.importClient(json, correlationId);

        // Assert
        assertEquals(expectedResponse, actualResponse);
        verify(lossControlDao).findByClientId("456");
        verify(clientLocation).getClientResponse(any(), eq(importClientRequest), any(), eq(correlationId));
    }
}





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        //finding client id in DB exist or not
        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {
            //finding LC360 client id in DB exist or not
            Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            //finding LC360 location id in DB exist or not(combined location lookup ID and policy number)
            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            if (lcClientId != null) {
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                //set client id and location id in pojo
                importClientRequest.getClient().setLookupID(lc360ClientId);
                locations.get(0).setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Client and Location are not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            lossControlDao.insertLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
             // Lookup ID Response
            lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber(), locationsResponse.get(0).getLocationLookupID());
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}



































if (lcClientId != null) {
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                //set client id and location id in pojo
                importClientRequest.getClient().setLookupID(lc360ClientId);
                locations.get(0).setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Client and Location are not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            lossControlDao.insertLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
             // Lookup ID Response
            lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber(), locationsResponse.get(0).getLocationLookupID());
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }






////////////////////////

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.HashMap;
import java.util.Map;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlService;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    void testImportClientClientExists() throws Exception {
        // Mock behavior for lossControlDao.findByClientId
        Map<String, Object> clientResult = new HashMap<>();
        when(lossControlDao.findByClientId(any())).thenReturn(clientResult);

        // Call the method to test
        importClientService.importClient("json", "correlationId");

        // Verify interactions
        verify(lossControlDao).findByClientId(any());
        // Add more verification as needed
    }

    @Test
    void testImportClientClientNotExists() throws Exception {
        // Mock behavior for lossControlDao.findByClientId
        when(lossControlDao.findByClientId(any())).thenReturn(null);

        // Mock behavior for objectMapper.readValue
        ImportClientRequest importClientRequest = new ImportClientRequest();
        when(objectMapper.readValue(any(), eq(ImportClientRequest.class)))
                .thenReturn(importClientRequest);

        // Mock behavior for lossControlDao.findLc360ClientID
        when(lossControlDao.findLc360ClientID(any())).thenReturn(null);

        // Mock behavior for lossControlService.clientPost
        ImportClientResponse importClientResponse = new ImportClientResponse();
        when(lossControlService.clientPost(any(), any())).thenReturn(importClientResponse);

        // Call the method to test
        importClientService.importClient("json", "correlationId");

        // Verify interactions
        verify(lossControlDao).findByClientId(any());
        verify(objectMapper).readValue(any(), eq(ImportClientRequest.class));
        verify(lossControlDao).findLc360ClientID(any());
        verify(lossControlService).clientPost(any(), any());
        verify(lossControlDao).insertClientId(any());
        verify(lossControlDao).updateLcClientId(any(), any());
        // Add more verification as needed
    }

    // Add more test methods to cover different scenarios
}















import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImpl;

import java.util.HashMap;
import java.util.Map;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlService;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImpl importClientService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    void testImportClient_Success() throws CustomException, JsonProcessingException {
        String json = "{...}"; // Your JSON data
        String correlationId = "123";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up importClientRequest properties

        // Mock behaviors
        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId(any())).thenReturn(new HashMap<>());
        when(lossControlService.clientPost(any(), any())).thenReturn(new ImportClientResponse());

        // Call the method
        importClientService.importClient(json, correlationId);

        // Verify interactions
        verify(lossControlDao).findByClientId(any());
        verify(lossControlService).clientPost(any(), any());
        // Verify other interactions

        // Verify no more interactions
        verifyNoMoreInteractions(lossControlDao, lossControlService);
    }

    @Test
    void testImportClient_ClientNotFound() throws CustomException, JsonProcessingException {
        String json = "{...}"; // Your JSON data
        String correlationId = "123";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up importClientRequest properties

        // Mock behaviors
        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId(any())).thenReturn(null);
        when(lossControlService.clientPost(any(), any())).thenReturn(new ImportClientResponse());

        // Call the method
        importClientService.importClient(json, correlationId);

        // Verify interactions
        verify(lossControlDao).findByClientId(any());
        verify(lossControlDao).insertClientId(any());
        verify(lossControlService).clientPost(any(), any());
        verify(lossControlDao).updateLcClientId(any(), any());
        // Verify other interactions

        // Verify no more interactions
        verifyNoMoreInteractions(lossControlDao, lossControlService);
    }

    // Add more test cases for different scenarios
}























package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if(result != null){
            Map<String,Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            if(lcClientId != null){
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());

              
                importClientRequest.getClient().setLookupID(lc360ClientId);
                objectMapper.writeValueAsString(importClientRequest);
                System.out.println(importClientRequest);
                

                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            }
            else {
                log.info("lc360 client id not present");
            }
        }
        else {
            log.info("Client is not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest,tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(),importClientResponse.getResult().getClientLookupID());
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}






/////////////////////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.mockito.Mockito.*;

class YourTestClassTest {

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlService;

    @InjectMocks
    private YourTestClass yourTestClass;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    void testProcessImport() {
        // Create mock objects
        ImportClientRequest importClientRequest = mock(ImportClientRequest.class);
        ImportClientResponse importClientResponse = mock(ImportClientResponse.class);
        Location location = mock(Location.class);
        // ... Initialize other necessary mock objects

        // Set up mock behaviors
        when(importClientRequest.getClient().getLookupID()).thenReturn("clientLookupID");
        // ... Set up behaviors for other methods and objects

        // Mock the behavior of lossControlService.clientPost
        when(lossControlService.clientPost(eq(importClientRequest), any()))
                .thenReturn(importClientResponse);

        // Mock the behavior of importClientResponse.getResult()
        ImportClientResult importClientResult = mock(ImportClientResult.class);
        when(importClientResponse.getResult()).thenReturn(importClientResult);

        // Mock the behavior of importClientResult.getLocations()
        List<Location> locationsResponse = new ArrayList<>();
        locationsResponse.add(location);
        when(importClientResult.getLocations()).thenReturn(locationsResponse);

        // Call the method you want to test
        yourTestClass.processImport(importClientRequest, location);

        // Verify interactions with lossControlDao
        verify(lossControlDao).insertClientId("clientLookupID");
        // ... Verify other interactions with lossControlDao

        verify(lossControlDao).updateLcClientId(eq("clientLookupID"), any());

        // Verify interactions with lossControlService
        verify(lossControlService).clientPost(eq(importClientRequest), any());

        // Verify interactions with lossControlDao again
        verify(lossControlDao).updateLcLocationId(eq("locationLookupID"), any());

        // Verify no more interactions
        verifyNoMoreInteractions(lossControlDao, lossControlService);
    }
}

///
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.mockito.Mockito.*;

class YourTestClassTest {

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlService;

    @InjectMocks
    private YourTestClass yourTestClass;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    void testProcessImportClient() {
        // Create mock objects
        ImportClientRequest importClientRequest = mock(ImportClientRequest.class);
        ImportClientResponse importClientResponse = mock(ImportClientResponse.class);
        Location location = mock(Location.class);
        // ... Initialize other necessary mock objects

        // Set up mock behaviors
        when(importClientRequest.getClient().getLookupID()).thenReturn("clientLookupID");
        // ... Set up behaviors for other methods and objects

        // Mock lossControlService.clientPost() behavior
        when(lossControlService.clientPost(any(), any())).thenReturn(importClientResponse);
        when(importClientResponse.getResult().getClientLookupID()).thenReturn("newClientLookupID");
        // ... Set up behaviors for other methods and objects

        // Call the method under test
        yourTestClass.processImportClient(importClientRequest, location);

        // Verify interactions with lossControlDao
        verify(lossControlDao).insertClientId("clientLookupID");
        verify(lossControlDao).insertLocationId(anyString());
        verify(lossControlDao).updateLcClientId(eq("clientLookupID"), eq("newClientLookupID"));
        verify(lossControlDao).updateLcLocationId(anyString(), anyString());

        // Verify interactions with lossControlService
        verify(lossControlService).clientPost(eq(importClientRequest), any());

        // Verify no more interactions
        verifyNoMoreInteractions(lossControlDao, lossControlService);
    }
}

////////////////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.mockito.Mockito.*;

class LossControlServiceTest {

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private TokenCache tokenCache;

    private LossControlService lossControlService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        lossControlService = new LossControlService(lossControlDao, tokenCache);
    }

    @Test
    void testImportClient() {
        // Create mock data for testing
        ImportClientRequest importClientRequest = new ImportClientRequest();
        ImportClientResponse importClientResponse = new ImportClientResponse();
        importClientResponse.setResult(new ImportClientResult());

        // Configure mock behavior
        when(lossControlDao.insertClientId(any())).thenReturn(1L);
        when(lossControlDao.insertLocationId(any())).thenReturn(1L);
        when(lossControlDao.updateLcClientId(any(), any())).thenReturn(true);
        when(lossControlDao.updateLcLocationId(any(), any())).thenReturn(true);
        when(tokenCache.retrieveTokenFromCache(any())).thenReturn("dummyToken");

        // Perform the method call
        lossControlService.importClient(importClientRequest);

        // Verify interactions with the mock objects
        verify(lossControlDao, times(1)).insertClientId(any());
        verify(lossControlDao, times(1)).insertLocationId(any());
        verify(lossControlDao, times(1)).updateLcClientId(any(), any());
        verify(lossControlDao, times(1)).updateLcLocationId(any(), any());
        verify(tokenCache, times(1)).retrieveTokenFromCache(any());
    }
}






import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.mockito.Mockito.*;

class YourTestClassTest {

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlService;

    @InjectMocks
    private YourTestClass yourTestClass;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    void testYourMethod() {
        // Create mock objects
        ImportClientRequest importClientRequest = mock(ImportClientRequest.class);
        ImportClientResponse importClientResponse = mock(ImportClientResponse.class);
        Location location = mock(Location.class);
        // ... Initialize other necessary mock objects

        // Set up mock behaviors
        when(importClientRequest.getClient().getLookupID()).thenReturn("clientLookupID");
        // ... Set up behaviors for other methods and objects

        // Call your method that contains the code snippet
        yourTestClass.yourMethod(importClientRequest, location);

        // Verify interactions
        verify(lossControlDao).insertClientId("clientLookupID");
        // ... Verify other interactions with lossControlDao

        verify(lossControlService).clientPost(eq(importClientRequest), any());
        // ... Verify other interactions with lossControlService

        verify(lossControlDao).updateLcClientId(eq("clientLookupID"), any());

        // Verify more interactions
        // ...

        // Verify no more interactions
        verifyNoMoreInteractions(lossControlDao, lossControlService);
    }
}












log.info("Client and Location are not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            lossControlDao.insertLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
             // Lookup ID Response
            lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber(), locationsResponse.get(0).getLocationLookupID());
      



















import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testImportClient_LcLocationIdExists() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"locations\": [{ \"lookupID\": \"123\", \"policyNumber\": \"456\" }] }}";
        String correlationId = "12345";
        String combineLocationID = "123+456";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up your ImportClientResponse with appropriate data

        // Mocking behavior for the scenario where LC360 location ID exists
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByLocationId(anyString())).thenReturn(Collections.singletonMap("1", "1234"));
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(Collections.singletonMap("1", "lc360LocationId"));
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions or verifications based on expected behavior
        assertNotNull(response);
        // Add more assertions based on your expected behavior
    }

    @Test
    public void testImportClient_LcLocationIdNotExists() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"locations\": [{ \"lookupID\": \"123\", \"policyNumber\": \"456\" }] }}";
        String correlationId = "12345";
        String combineLocationID = "123+456";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up your ImportClientResponse with appropriate data

        // Mocking behavior for the scenario where LC360 location ID doesn't exist
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByLocationId(anyString())).thenReturn(Collections.singletonMap("1", "1234"));
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(null);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions or verifications based on expected behavior
        assertNotNull(response);
        // Add more assertions based on your expected behavior
    }

    @Test
    public void testImportClient_LocationNotPresent() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"locations\": [{ \"lookupID\": \"123\", \"policyNumber\": \"456\" }] }}";
        String correlationId = "12345";
        String combineLocationID = "123+456";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up your ImportClientResponse with appropriate data

        // Mocking behavior for the scenario where location is not present
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByLocationId(anyString())).thenReturn(null);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(Collections.singletonMap("1", "lc360LocationId"));

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions or verifications based on expected behavior
        assertNotNull(response);
        // Add more assertions based on your expected behavior
    }

    // Add more test cases to cover different scenarios

    // ... more test methods ...

    // End of the class
}




import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testImportClient_LocationExists() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"locations\": [{ \"lookupID\": \"123\", \"policyNumber\": \"456\" }] }}";
        String correlationId = "12345";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data
        Location location = new Location();
        location.setLookupID("123");
        location.setPolicyNumber("456");
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        importClientRequest.setClient(new Client());
        importClientRequest.getClient().setLocations(locations);

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up your ImportClientResponse with appropriate data

        // Mocking behavior for the existing location scenario
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByLocationId(anyString())).thenReturn(new HashMap<>());
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(new HashMap<>());
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions or verifications based on the expected behavior
        assertNotNull(response);
        // Verify other method calls, assertions, etc.
    }

    @Test
    public void testImportClient_NewLocation() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"locations\": [{ \"lookupID\": \"123\", \"policyNumber\": \"456\" }] }}";
        String correlationId = "12345";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data
        Location location = new Location();
        location.setLookupID("123");
        location.setPolicyNumber("456");
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        importClientRequest.setClient(new Client());
        importClientRequest.getClient().setLocations(locations);

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up your ImportClientResponse with appropriate data

        // Mocking behavior for the new location scenario
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByLocationId(anyString())).thenReturn(null);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);
        when(lossControlDao.insertLocationId(anyString())).thenReturn(new HashMap<>());
        when(lossControlDao.updateLcLocationId(anyString(), anyString())).thenReturn(new HashMap<>());

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions or verifications based on the expected behavior
        assertNotNull(response);
        // Verify other method calls, assertions, etc.
    }

    // Add more test cases to cover other scenarios

    // ... more test methods ...

    // End of the class
}





















package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String location_LookupID = locations.get(0).getLookupID();


//        Policy number
        String policyNumber = locations.get(0).getPolicyNumber();

        //combination of Location ID + Policy number
        String combineLocationID = location_LookupID + "+" + policyNumber;

        Map<String, Object> result = lossControlDao.findByLocationId(combineLocationID);
        if (result != null) {

            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
            if (lcLocationId != null) {
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                locations.get(0).setLookupID(lc360LocationId);


                //If LC-360 Location Id exists use that id to the request to LC360
                String updatedJson = objectMapper.writeValueAsString(importClientRequest);
                System.out.println(updatedJson);


                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Location is not present");
            lossControlDao.insertLocationId(combineLocationID);
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();

//        Lookup ID Response
            String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();

            lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest {

    private TokenCache tokenCache;
    private LossControlServiceImpl lossControlServiceImpl;
    private ObjectMapper objectMapper;
    private ImportClientServiceImp importClientService;

    @BeforeEach
    public void setUp() {
        tokenCache = mock(TokenCache.class);
        lossControlServiceImpl = mock(LossControlServiceImpl.class);
        objectMapper = mock(ObjectMapper.class);
        importClientService = new ImportClientServiceImp(tokenCache, lossControlServiceImpl, objectMapper);
    }

    @Test
    public void testImportClient_SuccessfulImport() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { ... }}";
        String correlationId = "12345";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        ImportClientResponse importClientResponse = new ImportClientResponse();

        // Mock behavior
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);
        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn("testToken");

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions or verifications based on expected behavior
        // For example:
        verify(objectMapper, times(1)).readValue(json, ImportClientRequest.class);
        verify(lossControlServiceImpl, times(1)).clientPost(importClientRequest, "testToken");
        // Add more assertions based on your expected behavior
    }

    @Test
    public void testImportClient_JsonProcessingException() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { ... }}";
        String correlationId = "12345";

        // Mocking behavior to simulate JsonProcessingException
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class)))
                .thenThrow(new JsonProcessingException("Test JsonProcessingException") {});

        // Call the actual method and handle the exception
        try {
            ImportClientResponse response = importClientService.importClient(json, correlationId);
            // Add assertions or verifications if needed
        } catch (JsonProcessingException e) {
            // Handle the exception and perform necessary assertions
        }
    }

    // Add more test cases to cover different scenarios

    // ... more test methods ...

    // End of the class
}




import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import static org.junit.Assert.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@Slf4j
public class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testImportClient_SuccessfulImport() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"name\": \"John Doe\" }}";
        String correlationId = "12345";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up your ImportClientResponse with appropriate data

        // Mock behavior
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(response);
        // Additional assertions based on your expected behavior
    }

    @Test(expected = CustomException.class)
    public void testImportClient_JsonProcessingException() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"name\": \"John Doe\" }}";
        String correlationId = "12345";

        // Mock behavior to throw a JsonProcessingException
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenThrow(new JsonProcessingException("Test Exception") {});

        // Call the actual method and expect a CustomException
        importClientService.importClient(json, correlationId);
    }

    @Test(expected = CustomException.class)
    public void testImportClient_CustomExceptionFromService() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"name\": \"John Doe\" }}";
        String correlationId = "12345";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data

        // Mock behavior
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlServiceImpl.clientPost(any(), any())).thenThrow(new CustomException("Test Exception"));

        // Call the actual method and expect a CustomException
        importClientService.importClient(json, correlationId);
    }

    // Add more test cases to cover different scenarios

    // ... existing test methods ...

    // End of the class
}






///////////
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        objectMapper.writeValueAsString(importClientRequest);
        //Implement a  token caching logic within loss-control-service.
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        log.info("Received JSON");
        log.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}

































package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        objectMapper.writeValueAsString(importClientRequest);
        //Implement a  token caching logic within loss-control-service.
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        log.info("Received JSON");
        log.info("importClientResponse Successfully Received");
        return importClientResponse;
    }








///////////////////////////////////////////////////////////////
package uk.co.allianz.rap.lc.dao;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Map;

@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;


    @Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}



//////

package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String location_LookupID = locations.get(0).getLookupID();


//        Policy number
        String policyNumber = locations.get(0).getPolicyNumber();

        //combination of Location ID + Policy number
        String combineLocationID = location_LookupID + "+" + policyNumber;

        Map<String, Object> result = lossControlDao.findByLocationId(combineLocationID);
        if (result != null) {

            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
            if (lcLocationId != null) {
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                locations.get(0).setLookupID(lc360LocationId);


                //If LC-360 Location Id exists use that id to the request to LC360
                String updatedJson = objectMapper.writeValueAsString(importClientRequest);
                System.out.println(updatedJson);


                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Location is not present");
            lossControlDao.insertLocationId(combineLocationID);
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();

//        Lookup ID Response
            String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();

            lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}




////////////////////////////package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        //finding client id in DB exist or not
        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {
            //finding LC360 client id in DB exist or not
            Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            //finding LC360 location id in DB exist or not(combined location lookup ID and policy number)
            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            if (lcClientId != null) {
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                //set client id and location id in pojo
                importClientRequest.getClient().setLookupID(lc360ClientId);
                locations.get(0).setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Client and Location are not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            lossControlDao.insertLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
             // Lookup ID Response
            lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber(), locationsResponse.get(0).getLocationLookupID());
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@Repository
@Qualifier("datasource")
public class MainDatabaseRepository implements MyRepository {
    // Implementation for the main data source
}

@Repository
@Qualifier("test-datasource")
public class TestDatabaseRepository implements MyRepository {
    // Implementation for the test data source
}




test-datasource: # This is a custom name for your test data source
    url: jdbc:postgresql://localhost:5432/testdb
    username: testuser
    password: testpassword
// above //
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/testdb  # Replace with your PostgreSQL URL
    username: testuser
    password: testpassword

# Other configuration properties...

///
spring:
  h2:
    console:
      enabled: true  # Enable H2 console for debugging (optional)
    datasource:
      url: jdbc:h2:mem:testdb  # In-memory database URL
      driver-class-name: org.h2.Driver
      username: sa
      password:

# Other configuration properties...


//
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.jdbc.JdbcTestUtils;
import uk.co.allianz.rap.lc.dao.LossControlDao;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@Sql(scripts = { "classpath:schema.sql" }) // Use your schema creation script here
class LossControlDaoImplLocationTests {

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    void testInsertLocationId() {
        String locationId = "location123";
        lossControlDao.insertLocationId(locationId);

        int rowCount = JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "location_lookup", "location_id = '" + locationId + "'");
        assertEquals(1, rowCount);
    }

    @Test
    void testUpdateLcLocationId() {
        String locationId = "location123";
        String lc360LocationId = "lc360location123";

        // Insert a location row first
        jdbcTemplate.update("INSERT INTO location_lookup (location_id) VALUES (?)", locationId);

        lossControlDao.updateLcLocationId(locationId, lc360LocationId);

        String fetchedLc360LocationId = jdbcTemplate.queryForObject(
            "SELECT lc360_location_id FROM location_lookup WHERE location_id = ?", String.class, locationId
        );

        assertEquals(lc360LocationId, fetchedLc360LocationId);
    }
}

///////
CREATE TABLE client_lookup (
    client_id VARCHAR(255) PRIMARY KEY,
    lc360_client_id VARCHAR(255)
);

CREATE TABLE location_lookup (
    location_id VARCHAR(255) PRIMARY KEY,
    lc360_location_id VARCHAR(255)
);

-- Add more tables and columns as needed

//////////////
-- src/test/resources/schema.sql
CREATE TABLE location_lookup (
    id SERIAL PRIMARY KEY,
    location_id VARCHAR(255)
);

-- Add more schema definitions as needed


///
@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }
    }
////
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.jdbc.Sql;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

@SpringBootTest
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class LossControlDaoImplLocationTest {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private LossControlDao lossControlDao;

    @Test
    @Sql("/location_lookup_cleanup.sql") // SQL script to clean up test data before running the test
    public void testInsertLocationId() {
        String locationId = "test_location_id";
        
        lossControlDao.insertLocationId(locationId);

        Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM location_lookup WHERE location_id = ?", locationId);

        assertNotNull(result);
        assertEquals(locationId, result.get("location_id"));
    }

    @Test
    @Sql("/location_lookup_cleanup.sql") // SQL script to clean up test data before running the test
    public void testUpdateLcLocationId() {
        String locationId = "test_location_id";
        String lc360LocationId = "test_lc360_location_id";

        // Insert a test location before updating
        jdbcTemplate.update("INSERT INTO location_lookup(location_id) VALUES (?)", locationId);

        lossControlDao.updateLcLocationId(locationId, lc360LocationId);

        Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM location_lookup WHERE location_id = ?", locationId);

        assertNotNull(result);
        assertEquals(lc360LocationId, result.get("lc360_location_id"));
    }
}


//
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.jdbc.JdbcTestUtils;
import uk.co.allianz.rap.lc.dao.LossControlDao;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@Sql(scripts = { "classpath:schema.sql" }) // Use your schema creation script here
class LossControlDaoImplLocationTests {

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    void testInsertLocationId() {
        String locationId = "location123";
        lossControlDao.insertLocationId(locationId);

        int rowCount = JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "location_lookup", "location_id = '" + locationId + "'");
        assertEquals(1, rowCount);
    }

    @Test
    void testUpdateLcLocationId() {
        String locationId = "location123";
        String lc360LocationId = "lc360location123";

        // Insert a location row first
        jdbcTemplate.update("INSERT INTO location_lookup (location_id) VALUES (?)", locationId);

        lossControlDao.updateLcLocationId(locationId, lc360LocationId);

        String fetchedLc360LocationId = jdbcTemplate.queryForObject(
            "SELECT lc360_location_id FROM location_lookup WHERE location_id = ?", String.class, locationId
        );

        assertEquals(lc360LocationId, fetchedLc360LocationId);
    }
}

////
@Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
//
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ActiveProfiles;

import javax.sql.DataSource;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@ActiveProfiles("test")
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class ImportClientServiceTest {

    @Autowired
    private ImportClientService importClientService;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private DataSource dataSource;

    @Test
    public void testImportClient() throws Exception {
        String json = "your_test_json_here";
        String correlationId = "your_test_correlation_id_here";

        ImportClientResponse response = importClientService.importClient(json, correlationId);

        assertNotNull(response);
        assertNotNull(response.getResult());
        assertNotNull(response.getResult().getClientLookupID());
        // Add more assertions as needed
    }

    // Add more test cases for edge cases and scenarios
}

@SpringBootTest
@ActiveProfiles("test")
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class LossControlDaoTest {

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private DataSource dataSource;

    @Test
    public void testInsertClientId() {
        String clientId = "test_client_id";
        lossControlDao.insertClientId(clientId);

        Integer count = jdbcTemplate.queryForObject("SELECT COUNT(*) FROM client_lookup", Integer.class);
        assertEquals(1, count);
    }

    // Add more test cases for other methods in LossControlDaoImpl
}

//
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.jdbc.JdbcTestUtils;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class ImportClientServiceTest {

    @Autowired
    private ImportClientService importClientService;

    @Autowired
    private LossControlDao lossControlDao;

    @Test
    public void testImportClient() {
        String json = "{\"client\": {\"lookupID\": \"123\", ...}, ...}"; // Sample JSON
        String correlationId = "correlation123";

        // Clear the database before running the test
        JdbcTestUtils.deleteFromTables(lossControlDao.getJdbcTemplate(), "client_lookup", "location_lookup");

        try {
            ImportClientResponse response = importClientService.importClient(json, correlationId);
            assertNotNull(response);
            assertNotNull(response.getResult());
            assertNotNull(response.getResult().getClientLookupID());

            // Check if the client was inserted into the database
            assertTrue(JdbcTestUtils.countRowsInTableWhere(lossControlDao.getJdbcTemplate(), "client_lookup", "client_id = '123'") > 0);

            // Check if the location was inserted into the database
            ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
            Location location = importClientRequest.getClient().getLocations().get(0);
            assertTrue(JdbcTestUtils.countRowsInTableWhere(lossControlDao.getJdbcTemplate(), "location_lookup", "location_id = '" + location.getLookupID() + "+" + location.getPolicyNumber() + "'") > 0);

            // Test existing client scenario
            response = importClientService.importClient(json, correlationId);
            assertNotNull(response);
            assertNotNull(response.getResult());
            assertNotNull(response.getResult().getClientLookupID());
        } catch (Exception e) {
            fail("Exception occurred: " + e.getMessage());
        }
    }
}

//
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.jdbc.JdbcTestUtils;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
class ImportClientServiceImpTest {

    @Autowired
    private ImportClientService importClientService;

    @Test
    void testImportClient() throws Exception {
        String json = "{\"client\": { ... }}"; // Sample JSON data
        String correlationId = "123456";

        ImportClientResponse response = importClientService.importClient(json, correlationId);

        assertNotNull(response);
        assertNotNull(response.getResult());
        assertNotNull(response.getResult().getClientLookupID());
        // Add more assertions as needed
    }
}

@SpringBootTest
class LossControlDaoImplTest {

    @Autowired
    private LossControlDao lossControlDao;

    @Test
    void testInsertAndFindClient() {
        String clientId = "client123";
        lossControlDao.insertClientId(clientId);
        Map<String, Object> result = lossControlDao.findByClientId(clientId);
        
        assertNotNull(result);
        assertEquals(clientId, result.get("client_id"));
    }

    @Test
    void testInsertAndUpdateClient() {
        String clientId = "client123";
        String lc360ClientId = "lc360client123";
        lossControlDao.insertClientId(clientId);
        lossControlDao.updateLcClientId(clientId, lc360ClientId);
        Map<String, Object> result = lossControlDao.findLc360ClientID(clientId);
        
        assertNotNull(result);
        assertEquals(lc360ClientId, result.get("lc360_client_id"));
    }

    @Test
    void testInsertAndFindLocation() {
        String locationId = "location123";
        lossControlDao.insertLocationId(locationId);
        Map<String, Object> result = lossControlDao.findByLocationId(locationId);
        
        assertNotNull(result);
        assertEquals(locationId, result.get("location_id"));
    }

    @Test
    void testInsertAndUpdateLocation() {
        String locationId = "location123";
        String lc360LocationId = "lc360location123";
        lossControlDao.insertLocationId(locationId);
        lossControlDao.updateLcLocationId(locationId, lc360LocationId);
        Map<String, Object> result = lossControlDao.findLc360LocationID(locationId);
        
        assertNotNull(result);
        assertEquals(lc360LocationId, result.get("lc360_location_id"));
    }
}

////above without mock include dao and service////
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        //finding client id in DB exist or not
        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {
            //finding LC360 client id in DB exist or not
            Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            //finding LC360 location id in DB exist or not(combined location lookup ID and policy number)
            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            if (lcClientId != null) {
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                //set client id and location id in pojo
                importClientRequest.getClient().setLookupID(lc360ClientId);
                locations.get(0).setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Client and Location are not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            lossControlDao.insertLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
             // Lookup ID Response
            lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber(), locationsResponse.get(0).getLocationLookupID());
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}



//
package uk.co.allianz.rap.lc.dao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Map;

@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    //client methods
    @Override
    public void insertClientId(String client_id) {
        String insert = "insert into client_lookup(client_id) values(?)";
        int update = this.jdbcTemplate.update(insert, client_id);
    }

    @Override
    public void updateLcClientId(String client_id, String lc360_client_id) {
        String update = "update client_lookup set lc360_client_id = ? where client_id = ?";
        this.jdbcTemplate.update(update, lc360_client_id, client_id);
    }

    @Override
    public Map<String, Object> findByClientId(String client_id) {
        String checkClientId = "select * from client_lookup where client_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360ClientID(String client_id) {
        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360ClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    // Locations methods
    @Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}




//
package uk.co.allianz.rap.lc.dao;

import java.util.Map;

public interface LossControlDao {

    //client
    Map<String, Object> findByClientId(String client_id);

    void updateLcClientId(String client_id, String lc360_client_id);

    void insertClientId(String client_id);

    Map<String, Object> findLc360ClientID(String client_id);


    //location
    Map<String, Object> findByLocationId(String location_id);

    void updateLcLocationId(String location_id, String lc360_location_id);

    void insertLocationId(String location_id);

    Map<String, Object> findLc360LocationID(String location_id);

}
////////////////////////////////////////////////////////////////Dao layer class above//////////////////////////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
import org.springframework.transaction.annotation.Transactional;
import uk.co.allianz.rap.lc.dao.LossControlDao;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;

@SpringBootTest
@SpringJUnitConfig
@AutoConfigureTestDatabase
@Transactional
public class LossControlDaoImplTest {

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @BeforeEach
    public void setUp() {
        // Create necessary tables or data for testing (if needed)
        // For simplicity, this example assumes the tables already exist
    }

    @Test
    public void testClientOperations() {
        // Insert a client
        lossControlDao.insertClientId("testClientId");
        Map<String, Object> insertedClient = lossControlDao.findByClientId("testClientId");
        assertEquals("testClientId", insertedClient.get("client_id"));

        // Update client LC360 ID
        lossControlDao.updateLcClientId("testClientId", "lc360TestClientId");
        Map<String, Object> updatedClient = lossControlDao.findLc360ClientID("testClientId");
        assertEquals("lc360TestClientId", updatedClient.get("lc360_client_id"));
    }

    @Test
    public void testLocationOperations() {
        // Insert a location
        lossControlDao.insertLocationId("testLocationId");
        Map<String, Object> insertedLocation = lossControlDao.findByLocationId("testLocationId");
        assertEquals("testLocationId", insertedLocation.get("location_id"));

        // Update location LC360 ID
        lossControlDao.updateLcLocationId("testLocationId", "lc360TestLocationId");
        Map<String, Object> updatedLocation = lossControlDao.findLc360LocationID("testLocationId");
        assertEquals("lc360TestLocationId", updatedLocation.get("lc360_location_id"));
    }

    @Test
    public void testNonExistentClientAndLocation() {
        // Attempt to find non-existent client and location
        Map<String, Object> nonExistentClient = lossControlDao.findByClientId("nonExistentClientId");
        assertNull(nonExistentClient);

        Map<String, Object> nonExistentLocation = lossControlDao.findByLocationId("nonExistentLocationId");
        assertNull(nonExistentLocation);
    }
}



//
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.jdbc.Sql;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@Sql(scripts = {"/schema.sql", "/data.sql"}) // Load initial data into the H2 database
public class LossControlDaoImplTest {

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @BeforeEach
    public void setUp() {
        // Clear data before each test
        jdbcTemplate.update("DELETE FROM client_lookup");
        jdbcTemplate.update("DELETE FROM location_lookup");
    }

    @Test
    public void testInsertClientId() {
        String clientId = "sampleClientId";
        lossControlDao.insertClientId(clientId);

        Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM client_lookup WHERE client_id = ?", clientId);
        assertNotNull(result);
    }

    @Test
    public void testUpdateLcClientId() {
        String clientId = "sampleClientId";
        String lc360ClientId = "sampleLc360ClientId";
        jdbcTemplate.update("INSERT INTO client_lookup(client_id) VALUES (?)", clientId);

        lossControlDao.updateLcClientId(clientId, lc360ClientId);

        Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM client_lookup WHERE client_id = ?", clientId);
        assertEquals(lc360ClientId, result.get("lc360_client_id"));
    }

    @Test
    public void testFindByClientId() {
        String clientId = "sampleClientId";
        jdbcTemplate.update("INSERT INTO client_lookup(client_id) VALUES (?)", clientId);

        Map<String, Object> result = lossControlDao.findByClientId(clientId);
        assertNotNull(result);
    }

    @Test
    public void testFindLc360ClientID() {
        String clientId = "sampleClientId";
        String lc360ClientId = "sampleLc360ClientId";
        jdbcTemplate.update("INSERT INTO client_lookup(client_id, lc360_client_id) VALUES (?, ?)", clientId, lc360ClientId);

        Map<String, Object> result = lossControlDao.findLc360ClientID(clientId);
        assertEquals(lc360ClientId, result.get("lc360_client_id"));
    }

    @Test
    public void testInsertLocationId() {
        String locationId = "sampleLocationId";
        lossControlDao.insertLocationId(locationId);

        Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM location_lookup WHERE location_id = ?", locationId);
        assertNotNull(result);
    }

    @Test
    public void testUpdateLcLocationId() {
        String locationId = "sampleLocationId";
        String lc360LocationId = "sampleLc360LocationId";
        jdbcTemplate.update("INSERT INTO location_lookup(location_id) VALUES (?)", locationId);

        lossControlDao.updateLcLocationId(locationId, lc360LocationId);

        Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM location_lookup WHERE location_id = ?", locationId);
        assertEquals(lc360LocationId, result.get("lc360_location_id"));
    }

    @Test
    public void testFindByLocationId() {
        String locationId = "sampleLocationId";
        jdbcTemplate.update("INSERT INTO location_lookup(location_id) VALUES (?)", locationId);

        Map<String, Object> result = lossControlDao.findByLocationId(locationId);
        assertNotNull(result);
    }

    @Test
    public void testFindLc360LocationID() {
        String locationId = "sampleLocationId";
        String lc360LocationId = "sampleLc360LocationId";
        jdbcTemplate.update("INSERT INTO location_lookup(location_id, lc360_location_id) VALUES (?, ?)", locationId, lc360LocationId);

        Map<String, Object> result = lossControlDao.findLc360LocationID(locationId);
        assertEquals(lc360LocationId, result.get("lc360_location_id"));
    }
}


/////Junit test cases above
package uk.co.allianz.rap.lc.dao;

import java.util.Map;

public interface LossControlDao {

    //client
    Map<String, Object> findByClientId(String client_id);

    void updateLcClientId(String client_id, String lc360_client_id);

    void insertClientId(String client_id);

    Map<String, Object> findLc360ClientID(String client_id);


    //location
    Map<String, Object> findByLocationId(String location_id);

    void updateLcLocationId(String location_id, String lc360_location_id);

    void insertLocationId(String location_id);

    Map<String, Object> findLc360LocationID(String location_id);

}

////
package uk.co.allianz.rap.lc.dao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Map;

@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    //client methods
    @Override
    public void insertClientId(String client_id) {
        String insert = "insert into client_lookup(client_id) values(?)";
        int update = this.jdbcTemplate.update(insert, client_id);
    }

    @Override
    public void updateLcClientId(String client_id, String lc360_client_id) {
        String update = "update client_lookup set lc360_client_id = ? where client_id = ?";
        this.jdbcTemplate.update(update, lc360_client_id, client_id);
    }

    @Override
    public Map<String, Object> findByClientId(String client_id) {
        String checkClientId = "select * from client_lookup where client_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360ClientID(String client_id) {
        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360ClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    // Locations methods
    @Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}

/////JUNIT for DAO layer/////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class TokenCacheTest {

    private TokenCache tokenCache;
    private JwtUtil jwtUtil;
    private CacheManager cacheManager;

    @BeforeEach
    public void setUp() {
        // Initialize the TokenCache instance
        tokenCache = new TokenCache();

        // Create a mock JwtUtil and CacheManager
        jwtUtil = mock(JwtUtil.class);
        cacheManager = mock(CacheManager.class);

        // Set the dependencies using reflection (for simplicity, don't use this in production code)
        try {
            tokenCache.getClass().getDeclaredField("jwtUtil").set(tokenCache, jwtUtil);
            tokenCache.getClass().getDeclaredField("cacheManager").set(tokenCache, cacheManager);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        // Arrange
        String correlationId = "sampleCorrelationId";
        String expectedToken = "sampleToken";

        // Mock behavior of JwtUtil to return a token
        when(jwtUtil.getAuthToken()).thenReturn(expectedToken);

        // Mock behavior of CacheManager and Cache
        Cache cache = mock(Cache.class);
        when(cacheManager.getCache("tokens")).thenReturn(cache);
        when(cache.get("tokens")).thenReturn(null); // Simulate cache miss

        // Act
        String retrievedToken = tokenCache.retrieveTokenFromCache(correlationId);

        // Assert
        assertEquals(expectedToken, retrievedToken);

        // Verify log statements
        // Ideally, you would use a logging framework that captures log output for testing
    }
}


///
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class TokenCacheTest {

    private TokenCache tokenCache;
    private JwtUtil jwtUtil;

    @BeforeEach
    public void setUp() {
        jwtUtil = new JwtUtil(); // You may need to initialize JwtUtil appropriately
        tokenCache = new TokenCache();
        tokenCache.jwtUtil = jwtUtil; // Inject the JwtUtil instance manually
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        // Arrange
        String correlationId = "123456";
        String expectedToken = "testToken";

        // Act
        String token = tokenCache.retrieveTokenFromCache(correlationId);

        // Assert
        assertEquals(expectedToken, token);
    }

    @Test
    public void testRetrieveTokenFromCacheWithDifferentCorrelationId() throws CustomException {
        // Arrange
        String correlationId1 = "123456";
        String correlationId2 = "789012";

        // Act
        String token1 = tokenCache.retrieveTokenFromCache(correlationId1);
        String token2 = tokenCache.retrieveTokenFromCache(correlationId2);

        // Assert
        assertEquals(token1, token2);
    }
}


///
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class TokenCacheTest {

    private TokenCache tokenCache;

    @BeforeEach
    public void setUp() {
        tokenCache = new TokenCache();
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        String correlationId = "testCorrelationId";

        String token = tokenCache.retrieveTokenFromCache(correlationId);

        assertTrue(token != null && !token.isEmpty(), "Token should not be null or empty");
    }

    @Test
    public void testRetrieveTokenFromCacheLogs() throws CustomException {
        String correlationId = "testCorrelationId";

        String token = tokenCache.retrieveTokenFromCache(correlationId);

        // Assuming log.info() statements output to console or log files, you can check these manually.
        assertEquals(token, tokenCache.getToken(), "Token should be fetched from the cache");
    }
}



/////////////////////////Not used MOCK/////////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class TokenCacheTest {

    private TokenCache tokenCache;
    private JwtUtil jwtUtil;
    private CacheManager cacheManager;

    @BeforeEach
    public void setUp() {
        // Initialize the TokenCache instance
        tokenCache = new TokenCache();

        // Create a mock JwtUtil and CacheManager
        jwtUtil = mock(JwtUtil.class);
        cacheManager = mock(CacheManager.class);

        // Set the dependencies using reflection (for simplicity, don't use this in production code)
        try {
            tokenCache.getClass().getDeclaredField("jwtUtil").set(tokenCache, jwtUtil);
            tokenCache.getClass().getDeclaredField("cacheManager").set(tokenCache, cacheManager);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        // Arrange
        String correlationId = "sampleCorrelationId";
        String expectedToken = "sampleToken";

        // Mock behavior of JwtUtil to return a token
        when(jwtUtil.getAuthToken()).thenReturn(expectedToken);

        // Mock behavior of CacheManager and Cache
        Cache cache = mock(Cache.class);
        when(cacheManager.getCache("tokens")).thenReturn(cache);
        when(cache.get("tokens")).thenReturn(null); // Simulate cache miss

        // Act
        String retrievedToken = tokenCache.retrieveTokenFromCache(correlationId);

        // Assert
        assertEquals(expectedToken, retrievedToken);

        // Verify log statements
        // Ideally, you would use a logging framework that captures log output for testing
    }
}

///
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class TokenCacheTest {

    private TokenCache tokenCache;
    private JwtUtil jwtUtil;

    @BeforeEach
    public void setUp() {
        jwtUtil = new JwtUtil(); // You may need to initialize JwtUtil appropriately
        tokenCache = new TokenCache();
        tokenCache.jwtUtil = jwtUtil; // Inject the JwtUtil instance manually
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        // Arrange
        String correlationId = "123456";
        String expectedToken = "testToken";

        // Act
        String token = tokenCache.retrieveTokenFromCache(correlationId);

        // Assert
        assertEquals(expectedToken, token);
    }

    @Test
    public void testRetrieveTokenFromCacheWithDifferentCorrelationId() throws CustomException {
        // Arrange
        String correlationId1 = "123456";
        String correlationId2 = "789012";

        // Act
        String token1 = tokenCache.retrieveTokenFromCache(correlationId1);
        String token2 = tokenCache.retrieveTokenFromCache(correlationId2);

        // Assert
        assertEquals(token1, token2);
    }
}

//
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class TokenCacheTest {

    private TokenCache tokenCache;

    @BeforeEach
    public void setUp() {
        tokenCache = new TokenCache();
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        String correlationId = "testCorrelationId";

        String token = tokenCache.retrieveTokenFromCache(correlationId);

        assertTrue(token != null && !token.isEmpty(), "Token should not be null or empty");
    }

    @Test
    public void testRetrieveTokenFromCacheLogs() throws CustomException {
        String correlationId = "testCorrelationId";

        String token = tokenCache.retrieveTokenFromCache(correlationId);

        // Assuming log.info() statements output to console or log files, you can check these manually.
        assertEquals(token, tokenCache.getToken(), "Token should be fetched from the cache");
    }
}


without MOCK
///
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

public class TokenCacheTest {

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CacheManager cacheManager;

    @Mock
    private Cache cache;

    @InjectMocks
    private TokenCache tokenCache;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        String correlationId = "12345";
        String expectedToken = "sampleToken";

        // Mock cache behavior
        when(cacheManager.getCache(anyString())).thenReturn(cache);
        when(cache.get(any())).thenReturn(expectedToken);

        // Mock JwtUtil behavior
        when(jwtUtil.getAuthToken()).thenReturn(expectedToken);

        // Call the method under test
        String actualToken = tokenCache.retrieveTokenFromCache(correlationId);

        // Verify behavior
        verify(cacheManager).getCache(TokenCache.TOKEN_CACHE_NAME);
        verify(cache).get(TokenCache.TOKEN_CACHE_NAME);
        verify(jwtUtil).getAuthToken();
        verify(cache).put(eq(TokenCache.TOKEN_CACHE_NAME), eq(expectedToken));

        // Verify the returned token
        assertEquals(expectedToken, actualToken);
    }

    @Test
    public void testRetrieveTokenFromCache_NoCacheEntry() throws CustomException {
        String correlationId = "12345";
        String expectedToken = "sampleToken";

        // Mock cache behavior
        when(cacheManager.getCache(anyString())).thenReturn(cache);
        when(cache.get(any())).thenReturn(null);

        // Mock JwtUtil behavior
        when(jwtUtil.getAuthToken()).thenReturn(expectedToken);

        // Call the method under test
        String actualToken = tokenCache.retrieveTokenFromCache(correlationId);

        // Verify behavior
        verify(cacheManager).getCache(TokenCache.TOKEN_CACHE_NAME);
        verify(cache).get(TokenCache.TOKEN_CACHE_NAME);
        verify(jwtUtil).getAuthToken();
        verify(cache).put(eq(TokenCache.TOKEN_CACHE_NAME), eq(expectedToken));

        // Verify the returned token
        assertEquals(expectedToken, actualToken);
    }
}


//
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class TokenCacheTest {

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CacheManager cacheManager;

    @InjectMocks
    private TokenCache tokenCache;

    @Mock
    private Cache cache;

    @Test
    void testRetrieveTokenFromCache_WithCachedToken() throws CustomException {
        String correlationId = "correlation-123";
        String cachedToken = "cached-token";

        when(cacheManager.getCache("tokens")).thenReturn(cache);
        when(cache.get("tokens")).thenReturn(new Cache.ValueWrapper() {
            @Override
            public Object get() {
                return cachedToken;
            }
        });

        String result = tokenCache.retrieveTokenFromCache(correlationId);

        verify(cacheManager).getCache("tokens");
        verify(cache).get("tokens");
        verify(jwtUtil, never()).getAuthToken(); // Token should not be fetched from JwtUtil
        // Ensure logs are generated and correlationId is mentioned
        // Verify if the returned token matches the cached token
        // Verify log statements

        assertEquals(cachedToken, result);
    }

    @Test
    void testRetrieveTokenFromCache_WithoutCachedToken() throws CustomException {
        String correlationId = "correlation-456";
        String fetchedToken = "fetched-token";

        when(cacheManager.getCache("tokens")).thenReturn(cache);
        when(cache.get("tokens")).thenReturn(null); // Simulating cache miss
        when(jwtUtil.getAuthToken()).thenReturn(fetchedToken);

        String result = tokenCache.retrieveTokenFromCache(correlationId);

        verify(cacheManager).getCache("tokens");
        verify(cache).get("tokens");
        verify(jwtUtil).getAuthToken(); // Token should be fetched from JwtUtil
        // Ensure logs are generated and correlationId is mentioned
        // Verify if the returned token matches the fetched token
        // Verify log statements

        assertEquals(fetchedToken, result);
    }
}


/////////
@Test
    public void testRetrieveTokenFromCache() throws CustomException {
        String correlationId = "testCorrelationId";
        String mockToken = "mockToken";

        when(cacheManager.getCache(TokenCache.TOKEN_CACHE_NAME)).thenReturn(cache);
        when(cache.get(TokenCache.TOKEN_CACHE_NAME)).thenReturn(Mockito.mock(Cache.ValueWrapper.class));
        when(cache.get(TokenCache.TOKEN_CACHE_NAME).get()).thenReturn(mockToken);

        when(tokenCache.getToken()).thenReturn(mockToken);

        String resultToken = tokenCache.retrieveTokenFromCache(correlationId);

        assertEquals(mockToken, resultToken);

        verify(cacheManager, times(1)).getCache(TokenCache.TOKEN_CACHE_NAME);
        verify(cache, times(1)).get(TokenCache.TOKEN_CACHE_NAME);
        verify(tokenCache, times(1)).getToken();

        verify(cache, never()).put(any(), any());
    }
}
In this test class, we are using JUnit 5 along with Mockito to mock the necessary dependencies. The test case ensures that all lines in the retrieveTokenFromCache method are covered. The flow includes mocking the cache manager, cache, and token retrieval using the getToken method. The verify statements at the end ensure that the relevant methods were called the expected number of times.

Please note that you might need to adjust the imports and adapt the test case to your project's specific configuration and version of Spring and Mockito.









/////////
package uk.co.allianz.rap.lc.cache;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

//1. Implement a  token caching logic within loss-control-service
@Slf4j
@Component
public class TokenCache {

    private static final String TOKEN_CACHE_NAME = "tokens";
    @Autowired
    protected JwtUtil jwtUtil;
    @Autowired
    protected CacheManager cacheManager;

    @Cacheable(value = TOKEN_CACHE_NAME)
    public String getToken() throws CustomException {

        // Retrieve the token from the cache or data source
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            Cache.ValueWrapper valueWrapper = cache.get(TOKEN_CACHE_NAME);
            if (valueWrapper != null) {
                return (String) valueWrapper.get();
            }
        }
        String tokenFromDataSource = retrieveTokenFromDataSource();
        log.info("Generated Token");
        // Cache the token for future use
        cacheToken(tokenFromDataSource);
        return tokenFromDataSource;
    }

    public String retrieveTokenFromDataSource() throws CustomException {
        // Perform the actual retrieval of the token from the jwtUtil class
        String jwtToken = jwtUtil.getAuthToken();
        return jwtToken;
    }

    //token store in cache
    public void cacheToken(final String token) {
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            cache.put(TOKEN_CACHE_NAME, token);
        }
    }

    //retrieve Token From Cache & request contains the correlation id
    public String retrieveTokenFromCache(final String correlationId) throws CustomException {
        if (log.isInfoEnabled()) {
            log.info("Start invoking for token : Correlation ID: " + correlationId);
        }
        String token = getToken();
        log.info("Token fetch from cache");
        if (log.isInfoEnabled()) {
            log.info("Successfully retrieved the token: Correlation ID: " + correlationId);
        }
        return token;
    }
}

///////////////////////
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class CacheConfigTest {

    @InjectMocks
    private CacheConfig cacheConfig;

    @Test
    public void testCacheManagerConfiguration() {
        CacheManager cacheManager = cacheConfig.cacheManager();

        assertNotNull(cacheManager);

        Caffeine<Object, Object> caffeineCache = cacheConfig.caffeineCacheBuilder();
        assertNotNull(caffeineCache);

        caffeineCache.expireAfterWrite(123, TimeUnit.SECONDS);
        caffeineCache.maximumSize(456);

        assertEquals(123, caffeineCache.getExpiresAfterWrite());
        assertEquals(456, caffeineCache.getMaximumSize());
    }
}


//

import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class TokenCacheTest {

    @InjectMocks
    private TokenCache tokenCache;

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CacheManager cacheManager;

    @Mock
    private Cache cache;

    private static final String TOKEN_CACHE_NAME = "tokens";  // Define the private constant here

    @Before
    public void setup() {
        when(cacheManager.getCache(TOKEN_CACHE_NAME)).thenReturn(cache); // Use the constant here
    }

    // ... Rest of the test methods remain the same
}

////////////////1////////////////
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.test.context.junit4.SpringRunner;

import static org.junit.Assert.assertNotNull;

@RunWith(SpringRunner.class)
public class CacheConfigTest {

    @Configuration
    static class TestConfiguration {
        @Bean
        public CacheManager cacheManager() {
            return new CaffeineCacheManager();
        }
    }

    @Autowired
    private CacheManager cacheManager;

    @Test
    public void testCacheManagerBean() {
        Cache cache = cacheManager.getCache("tokens");
        assertNotNull(cache);
    }
}


//
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class TokenCacheTest {

    @InjectMocks
    private TokenCache tokenCache;

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CacheManager cacheManager;

    @Mock
    private Cache cache;

    @Before
    public void setup() {
        when(cacheManager.getCache(TokenCache.TOKEN_CACHE_NAME)).thenReturn(cache);
    }

    @Test
    public void testRetrieveTokenFromDataSource() throws CustomException {
        when(jwtUtil.getAuthToken()).thenReturn("testToken");
        String token = tokenCache.retrieveTokenFromDataSource();
        assertEquals("testToken", token);
    }

    @Test
    public void testCacheToken() {
        tokenCache.cacheToken("cachedToken");
        verify(cache, times(1)).put(eq(TokenCache.TOKEN_CACHE_NAME), eq("cachedToken"));
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        when(cache.get(TokenCache.TOKEN_CACHE_NAME)).thenReturn(new SimpleValueWrapper("cachedToken"));
        String token = tokenCache.retrieveTokenFromCache("correlationId");
        assertEquals("cachedToken", token);
    }

    @Test
    public void testGetTokenFromCache() throws CustomException {
        when(cache.get(TokenCache.TOKEN_CACHE_NAME)).thenReturn(null);
        when(jwtUtil.getAuthToken()).thenReturn("newToken");
        String token = tokenCache.getToken();
        assertEquals("newToken", token);
        verify(cache, times(1)).put(eq(TokenCache.TOKEN_CACHE_NAME), eq("newToken"));
    }
}


////2/////
package uk.co.allianz.rap.lc.cache;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.junit.jupiter.api.Test;
import org.springframework.cache.CacheManager;
import org.springframework.cache.caffeine.CaffeineCacheManager;

import static org.junit.jupiter.api.Assertions.*;

class CacheConfigTest {

    @Test
    void testCacheManagerBean() {
        CacheManager cacheManager = new CacheConfig().cacheManager();

        assertNotNull(cacheManager);
        assertTrue(cacheManager instanceof CaffeineCacheManager);

        CaffeineCacheManager caffeineCacheManager = (CaffeineCacheManager) cacheManager;
        Caffeine<Object, Object> caffeine = caffeineCacheManager.getCaffeine();

        assertNotNull(caffeine);
        assertEquals(CacheConfig.CACHE_DURATION, caffeine.getExpiresAfterWrite());
        assertEquals(CacheConfig.CACHE_SIZE, caffeine.getMaximumSize());
    }
}


//
package uk.co.allianz.rap.lc.cache;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

class TokenCacheTest {

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CacheManager cacheManager;

    @Mock
    private Cache cache;

    @InjectMocks
    private TokenCache tokenCache;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        when(cacheManager.getCache(TokenCache.TOKEN_CACHE_NAME)).thenReturn(cache);
    }

    @Test
    void testGetTokenFromCache() throws CustomException {
        String token = "testToken";
        when(cache.get(TokenCache.TOKEN_CACHE_NAME)).thenReturn(mock(Cache.ValueWrapper.class));
        when(cache.get(TokenCache.TOKEN_CACHE_NAME).get()).thenReturn(token);

        String result = tokenCache.getToken();

        assertEquals(token, result);
        verify(cache, times(1)).get(TokenCache.TOKEN_CACHE_NAME);
    }

    @Test
    void testGetTokenFromDataSource() throws CustomException {
        String jwtToken = "testJwtToken";
        when(jwtUtil.getAuthToken()).thenReturn(jwtToken);

        String result = tokenCache.retrieveTokenFromDataSource();

        assertEquals(jwtToken, result);
        verify(jwtUtil, times(1)).getAuthToken();
    }

    @Test
    void testCacheToken() {
        String token = "testToken";
        tokenCache.cacheToken(token);

        verify(cache, times(1)).put(TokenCache.TOKEN_CACHE_NAME, token);
    }

    @Test
    void testRetrieveTokenFromCache() throws CustomException {
        String correlationId = "testCorrelationId";
        String token = "testToken";
        when(cache.get(TokenCache.TOKEN_CACHE_NAME)).thenReturn(mock(Cache.ValueWrapper.class));
        when(cache.get(TokenCache.TOKEN_CACHE_NAME).get()).thenReturn(token);

        String result = tokenCache.retrieveTokenFromCache(correlationId);

        assertEquals(token, result);
        verify(cache, times(1)).get(TokenCache.TOKEN_CACHE_NAME);
    }
}


/////1//////
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class CacheConfigTest {

    @InjectMocks
    private CacheConfig cacheConfig;

    @Test
    public void testCacheManagerConfiguration() {
        CacheManager cacheManager = cacheConfig.cacheManager();

        assertNotNull(cacheManager);

        Caffeine<Object, Object> caffeineCache = cacheConfig.caffeineCacheBuilder();
        assertNotNull(caffeineCache);

        assertEquals(123, caffeineCache.expireAfterWrite(123, TimeUnit.SECONDS).getExpiresAfterWrite());
        assertEquals(456, caffeineCache.maximumSize(456).maximumSize());
    }
}

//
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class TokenCacheTest {

    @InjectMocks
    private TokenCache tokenCache;

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CacheManager cacheManager;

    @Mock
    private Cache cache;

    @Test
    public void testGetTokenFromCache() throws CustomException {
        when(cacheManager.getCache(eq(TokenCache.TOKEN_CACHE_NAME))).thenReturn(cache);
        when(cache.get(eq(TokenCache.TOKEN_CACHE_NAME))).thenReturn(new SimpleValueWrapper("cachedToken"));

        String token = tokenCache.getToken();

        assertEquals("cachedToken", token);
        verify(jwtUtil, never()).getAuthToken(); // Make sure the jwtUtil is not called
    }

    @Test
    public void testGetTokenFromDataSource() throws CustomException {
        when(cacheManager.getCache(eq(TokenCache.TOKEN_CACHE_NAME))).thenReturn(cache);
        when(cache.get(eq(TokenCache.TOKEN_CACHE_NAME))).thenReturn(null);
        when(jwtUtil.getAuthToken()).thenReturn("newToken");

        String token = tokenCache.getToken();

        assertEquals("newToken", token);
        verify(cache).put(eq(TokenCache.TOKEN_CACHE_NAME), eq("newToken"));
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        when(cacheManager.getCache(eq(TokenCache.TOKEN_CACHE_NAME))).thenReturn(cache);
        when(cache.get(eq(TokenCache.TOKEN_CACHE_NAME))).thenReturn(new SimpleValueWrapper("cachedToken"));

        String token = tokenCache.retrieveTokenFromCache("correlationId");

        assertEquals("cachedToken", token);
    }
}

///////////////
package uk.co.allianz.rap.lc.cache;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

//1. Implement a  token caching logic within loss-control-service
@Slf4j
@Component
public class TokenCache {

    private static final String TOKEN_CACHE_NAME = "tokens";
    @Autowired
    protected JwtUtil jwtUtil;
    @Autowired
    protected CacheManager cacheManager;

    @Cacheable(value = TOKEN_CACHE_NAME)
    public String getToken() throws CustomException {

        // Retrieve the token from the cache or data source
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            Cache.ValueWrapper valueWrapper = cache.get(TOKEN_CACHE_NAME);
            if (valueWrapper != null) {
                return (String) valueWrapper.get();
            }
        }
        String tokenFromDataSource = retrieveTokenFromDataSource();
        log.info("Generated Token");
        // Cache the token for future use
        cacheToken(tokenFromDataSource);
        return tokenFromDataSource;
    }

    public String retrieveTokenFromDataSource() throws CustomException {
        // Perform the actual retrieval of the token from the jwtUtil class
        String jwtToken = jwtUtil.getAuthToken();
        return jwtToken;
    }

    //token store in cache
    public void cacheToken(final String token) {
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            cache.put(TOKEN_CACHE_NAME, token);
        }
    }

    //retrieve Token From Cache & request contains the correlation id
    public String retrieveTokenFromCache(final String correlationId) throws CustomException {
        if (log.isInfoEnabled()) {
            log.info("Start invoking for token : Correlation ID: " + correlationId);
        }
        String token = getToken();
        log.info("Token fetch from cache");
        if (log.isInfoEnabled()) {
            log.info("Successfully retrieved the token: Correlation ID: " + correlationId);
        }
        return token;
    }
}
.........
package uk.co.allianz.rap.lc.cache;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.TimeUnit;

import static uk.co.allianz.rap.lc.constant.LCConstants.CACHE_DURATION;
import static uk.co.allianz.rap.lc.constant.LCConstants.CACHE_SIZE;

@Configuration
@EnableCaching
public class CacheConfig {

    //This method for Manage the cache
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(caffeineCacheBuilder());
        return cacheManager;
    }

    @Bean
    public Caffeine<Object, Object> caffeineCacheBuilder() {
        return Caffeine.newBuilder().expireAfterWrite(CACHE_DURATION, TimeUnit.SECONDS) // Set the expiration time for the tokens
                .maximumSize(CACHE_SIZE); // Set the maximum number of tokens to store in the cache
    }
}
///////////////// JUNIT-Test Cases ////////////////////////////////////////////////////////
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
    
    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
    Map<String, Object> locationResult = lossControlDao.findByLocationId(combineLocationID);

    if (clientResult != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
            importClientRequest.getClient().setLookupID(lc360ClientId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        String lc360_Lookup_ID = importClientResponse.getResult().getClientLookupID();
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), lc360_Lookup_ID);
    }

    if (locationResult == null) {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    } else {
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationId != null) {
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
            locations.get(0).setLookupID(lc360LocationId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    }
    
    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}


//
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());

    if (result != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get("lc360_client_id"); // Replace with the correct key
            importClientRequest.getClient().setLookupID(lc360ClientId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        String lc360_Lookup_ID = importClientResponse.getResult().getClientLookupID();
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), lc360_Lookup_ID);
    }

    if (result == null) {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    } else {
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationId != null) {
            String lc360LocationId = (String) lcLocationId.get("lc360_location_id"); // Replace with the correct key
            locations.get(0).setLookupID(lc360LocationId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    }

    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}


//
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
    
    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
    
    if (result != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
            importClientRequest.getClient().setLookupID(lc360ClientId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            String lc360_Lookup_ID = importClientResponse.getResult().getClientLookupID();
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), lc360_Lookup_ID);
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        String lc360_Lookup_ID = importClientResponse.getResult().getClientLookupID();
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), lc360_Lookup_ID);
    }
    
    if (result == null) {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    } else {
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationId != null) {
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
            locations.get(0).setLookupID(lc360LocationId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    }
    
    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}


////11111//
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

    Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
    Map<String, Object> locationResult = lossControlDao.findByLocationId(importClientRequest.getClient().getLookupID());

    if (clientResult != null) {
        Map<String, Object> lcClientIds = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientIds != null) {
            String lc360ClientId = (String) lcClientIds.get(lcClientIds.keySet().iterator().next());
            importClientRequest.getClient().setLookupID(lc360ClientId);
            log.info("Received JSON for client");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        String lc360ClientId = importClientResponse.getResult().getClientLookupID();
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), lc360ClientId);
    }

    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String locationLookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = locationLookupID + "+" + policyNumber;

    if (locationResult != null) {
        Map<String, Object> lcLocationIds = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationIds != null) {
            String lc360LocationId = (String) lcLocationIds.get(lcLocationIds.keySet().iterator().next());
            locations.get(0).setLookupID(lc360LocationId);
            log.info("Received JSON for location");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    } else {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        String lc360LocationId = importClientResponse.getResult().getLocations().get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360LocationId);
    }

    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}


...
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());

    if (result != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
            importClientRequest.getClient().setLookupID(lc360ClientId);

            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

        // Only update lcLocationId if it's not already set
        if (locations.get(0).getLookupID() == null) {
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
            String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
            locations.get(0).setLookupID(lc360_Lookup_ID);
            lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
        }
    }

    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}


.........
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
    
    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
    
    if (result != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
            importClientRequest.getClient().setLookupID(lc360ClientId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        String lc360_Lookup_ID = importClientResponse.getResult().getClientLookupID();
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), lc360_Lookup_ID);
    }
    
    if (result == null) {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    } else {
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationId != null) {
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
            locations.get(0).setLookupID(lc360LocationId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    }
    
    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}

//1 ..below1
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
    
    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());

    if (result == null) {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
    }

    Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
    if (lcClientId != null) {
        String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
        importClientRequest.getClient().setLookupID(lc360ClientId);
        objectMapper.writeValueAsString(importClientRequest);
        System.out.println(importClientRequest);
        log.info("Received JSON");
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
    } else {
        log.info("lc360 client id not present");
    }

    Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
    if (lcLocationId != null) {
        String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
        locations.get(0).setLookupID(lc360LocationId);

        String updatedJson = objectMapper.writeValueAsString(importClientRequest);
        System.out.println(updatedJson);
        log.info("Received JSON");
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
    } else {
        log.info("lc360 location id not present");
    }

    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package uk.co.allianz.rap.lc.service; //onlyClientLC:+!

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());

        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String location_LookupID = locations.get(0).getLookupID();
        String policyNumber = locations.get(0).getPolicyNumber();
        String combineLocationID = location_LookupID + "+" + policyNumber;

        if (result != null) {
            Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            if (lcClientId != null) {
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
                importClientRequest.getClient().setLookupID(lc360ClientId);
                objectMapper.writeValueAsString(importClientRequest);
                System.out.println(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 client id not present");
            }
        } else {
            log.info("Client is not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(),importClientResponse.getResult().getClientLookupID());
        }

        if (result == null) {
            log.info("Location is not present");
            lossControlDao.insertLocationId(combineLocationID);
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
            String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
            lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
        } else {
            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
            if (lcLocationId != null) {
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                locations.get(0).setLookupID(lc360LocationId);
                String updatedJson = objectMapper.writeValueAsString(importClientRequest);
                System.out.println(updatedJson);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        }

        log.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}


/////
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String locationID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = locationID + "+" + policyNumber;

    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
    if (result != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());

            importClientRequest.getClient().setLookupID(lc360ClientId);

            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest,tokenCache.retrieveTokenFromCache(correlationId));
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(),importClientResponse.getResult().getClientLookupID());
    }

    if (result == null) {
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationId != null) {
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
            locations.get(0).setLookupID(lc360LocationId);

            String updatedJson = objectMapper.writeValueAsString(importClientRequest);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    } else {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();

        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    }

    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}

//
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
    
    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    if (result != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
            importClientRequest.getClient().setLookupID(lc360ClientId);
            objectMapper.writeValueAsString(importClientRequest);
            System.out.println(importClientRequest);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    }
    
    if (result == null) {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    } else {
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationId != null) {
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
            locations.get(0).setLookupID(lc360LocationId);
            String updatedJson = objectMapper.writeValueAsString(importClientRequest);
            System.out.println(updatedJson);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    }
    
    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}

//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String location_LookupID = locations.get(0).getLookupID();
        String policyNumber = locations.get(0).getPolicyNumber();
        String combineLocationID = location_LookupID + "+" + policyNumber;

        Map<String, Object> result = lossControlDao.findByLocationId(combineLocationID);
        if (result != null) {
            Map<String,Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
            if (lcLocationId != null) {
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                locations.get(0).setLookupID(lc360LocationId);
                String updatedJson = objectMapper.writeValueAsString(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Location is not present");
            lossControlDao.insertLocationId(combineLocationID);
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
            String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
            lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
        }

        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {
            Map<String,Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            if (lcClientId != null) {
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
                importClientRequest.getClient().setLookupID(lc360ClientId);
                objectMapper.writeValueAsString(importClientRequest);
                System.out.println(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 client id not present");
            }
        } else {
            log.info("Client is not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
        }

        log.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}



//////////package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if(result != null){
            Map<String,Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            if(lcClientId != null){
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());

           importClientRequest.getClient().setLookupID(lc360ClientId);
                objectMapper.writeValueAsString(importClientRequest);
                System.out.println(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            }
            else {
                log.info("lc360 client id not present");
            }
        }
        else {
            log.info("Client is not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest,tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(),importClientResponse.getResult().getClientLookupID());
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}















//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String location_LookupID = locations.get(0).getLookupID();


//        Policy number
        String policyNumber = locations.get(0).getPolicyNumber();

        //combination of Location ID + Policy number
        String combineLocationID = location_LookupID + "+" + policyNumber;

        Map<String, Object> result = lossControlDao.findByLocationId(combineLocationID);
        if (result != null) {

            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
            if (lcLocationId != null) {
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                locations.get(0).setLookupID(lc360LocationId);


                //If LC-360 Location Id exists use that id to the request to LC360
                String updatedJson = objectMapper.writeValueAsString(importClientRequest);
                System.out.println(updatedJson);


                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Location is not present");
            lossControlDao.insertLocationId(combineLocationID);
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();

//        Lookup ID Response
            String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();

            lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}





/////package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String locationID = locations.get(0).getLookupID();
        //
//
//        //Location ID:LookupID
        System.out.println("LocationID:" + locationID);
//        //Policy number
        String policyNumber = locations.get(0).getPolicyNumber();
        System.out.println("policyNumber:" + policyNumber);
//
//        //combination of Location ID + Policy number
        String combineLocationID = locationID + "+" + policyNumber;
        System.out.println("combination of Location ID + Policy number:" + combineLocationID);
//
        //
        Map<String, Object> result = lossControlDao.findByLocationId(combineLocationID);
        if(result != null){

            Map<String,Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
            if(lcLocationId != null){
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                System.out.println(lc360LocationId);
//
package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;

@SuppressWarnings("unused")
@Data
public class Location {
    @JsonProperty("LocationID")
    private String locationID;
    @JsonProperty("ClientID")
    private String clientID;
    @JsonProperty("LocationLookupID")
    private String locationLookupID;
    @JsonProperty("IsDeleted")
    private boolean isDeleted;
    @JsonProperty("Success")
    private boolean success;
    @JsonProperty("CommercialCoverages")
    private ArrayList<CommercialCoverage> commercialCoverages;
}

//
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;
import java.util.Date;

@SuppressWarnings("unused")
@Data
public class Location {
    @JsonProperty("LookupID")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String lookupID;
    @JsonProperty("PolicyNumber")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String policyNumber;
    @JsonProperty("RenewalDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    @JsonFormat(pattern = "yyyy-MM-dd")
    private Date renewalDate;
    @JsonProperty("Address")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Address address;
    @JsonProperty("Coverages")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private ArrayList<Coverage> coverages;
    @JsonProperty("Contact")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Contact contact;
    @JsonProperty("Name")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String name;

    @JsonProperty("PolicyEffectiveDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date policyEffectiveDate;

    @JsonProperty("PolicyExpirationDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date policyExpirationDate;

    @JsonProperty("PolicyRenewalDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date policyRenewalDate;

    @JsonProperty("OriginalEffectiveDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date originalEffectiveDate;

    @JsonProperty("EffectiveDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date effectiveDate;
    @JsonProperty("ExpirationDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date expirationDate;

    @JsonProperty("LastInspectedDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date lastInspectedDate;
    private ArrayList<GenericField> genericFields;

}



///
package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;
@SuppressWarnings("unused")
@Data
public class Result {
    @JsonProperty("ClientID")
    private String clientID;
    @JsonProperty("ClientLookupID")
    private String clientLookupID;
    @JsonProperty("IsDeleted")
    private boolean isDeleted;
    @JsonProperty("Errors")
    private ArrayList<Object> errors;
    @JsonProperty("Warnings")
    private Object warnings;
    @JsonProperty("Success")
    private boolean success;
    @JsonProperty("Locations")
    private ArrayList<Location> locations;
    @JsonProperty("CommercialCoverages")
    private ArrayList<Object> commercialCoverages;
    @JsonProperty("Messages")
    private ArrayList<Object> messages;
}


..

package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@SuppressWarnings("unused")
@Data
public class ImportClientResponse {
    @JsonProperty("Result")
    private Result result;
    @JsonProperty("ImportRequestID")
    private String importRequestID;
}



.............
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;
@SuppressWarnings("unused")
@Data
public class Client {
    @JsonProperty("LookupID")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String lookupID;
    @JsonProperty("ContactFirstName")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String contactFirstName;
    @JsonProperty("ContactLastName")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String contactLastName;
    @JsonProperty("PolicyNumber")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String policyNumber;
    @JsonProperty("Name")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String name;
    @JsonProperty("Phone")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String phone;
    @JsonProperty("Email")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String email;
    @JsonProperty("Address")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Address address;
    @JsonProperty("Agent")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Agent agent;
    @JsonProperty("Underwriter")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Underwriter underwriter;

    @JsonProperty("Locations")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private ArrayList<Location> locations;

}


................


package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Data;
import com.fasterxml.jackson.annotation.JsonProperty;

@SuppressWarnings("unused")
@Data
public class ImportClientRequest {
    @JsonProperty("divisionLookupID")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String divisionLookupID;
    @JsonProperty("client")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Client client;

}



///////////

package uk.co.allianz.rap.lc.util;



import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.client.WebClient;
import uk.co.allianz.rap.lc.model.JwtTokenModel;
import uk.co.allianz.rap.lc.model.response.AuthTokenResponse;

@Component
public class JwtUtil {

    @Autowired
    private JwtTokenModel jwtTokenModel;

    //method used for invoke first LC360 api
    //post http request
    //input clientid,granttype,clientsecret,authtokenurl
    //generate jwt bearer token
    public String getAuthToken() {
         WebClient webClient = WebClient.create();
        MultiValueMap<String, String> requestBody = new LinkedMultiValueMap<>(); //added in try catch using custome exception
        requestBody.add("grant_type", jwtTokenModel.getGrantType());
        requestBody.add("client_id", jwtTokenModel.getClientId());
        requestBody.add("client_secret", jwtTokenModel.getClientSecret());
        AuthTokenResponse authTokenResponse = webClient.post()
                .uri(jwtTokenModel.getAuthTokenUrl())
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .bodyValue(requestBody)
                .retrieve()
                .bodyToMono(AuthTokenResponse.class)
                .block();

        return authTokenResponse.getAccessToken();
    }
}

//provide log 

if (log.isErrorEnabled()) {
    log.error("Invalid JSON: " + e.getMessage());
}

.............
if (log.isInfoEnabled()) {
    log.info("Information message: " + someInfo);
}

if (log.isDebugEnabled()) {
    log.debug("Debug message: " + someDebugInfo);
}

if (log.isWarnEnabled()) {
    log.warn("Warning message: " + someWarning);
}


//////////////////package uk.co.allianz.rap.lc.rest;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;


@Slf4j
@RestController
public class ValidationRest {
    @Autowired
    private TokenCache tokenCache;

    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    //Build the end point/Resource path: POST: surveySubmission
    //Build standard JSON validation on incoming data

    //Implement a  token caching logic within loss-control-service.
    //Consume the correlation id we receive is available for further business logic to log it.
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<?> processJson(@RequestBody(required = false) final String json, @RequestHeader("Correlation-ID") final String correlationId) {

        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            log.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");

        }
        try {
            //for validate JSON
            String validateinput = validationServiceImpl.processJson(json);
            //For import only client
            ImportClientResponse processedJson = importClientServiceImp.importClient(validateinput, correlationId);
            log.info("JSON received successfully");
            return ResponseEntity.ok(processedJson);

        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            log.error("Invalid JSON: " + e.getMessage());
            return ResponseEntity.badRequest().body("Invalid JSON: " + e.getMessage());

        } catch (Exception e) {
            // Other exceptions
            log.error("Invalid JSON format");
            return ResponseEntity.badRequest().body("Invalid JSON format");

        }
    }
}




/////////////////

@Service
public class SomeOtherService {
    private final LocationService locationService;

    @Autowired
    public SomeOtherService(LocationService locationService) {
        this.locationService = locationService;
    }

    public void someMethod() {
        String locationIDToCheck = "your_location_id_here";
        boolean isLocationIDPresent = locationService.isLocationIDPresentInDB(locationIDToCheck);

        if (isLocationIDPresent) {
            System.out.println("Location ID exists in the database.");
        } else {
            System.out.println("Location ID does not exist in the database.");
        }
    }
}



import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class LocationService {
    private final LocationRepository locationRepository;

    @Autowired
    public LocationService(LocationRepository locationRepository) {
        this.locationRepository = locationRepository;
    }

    public boolean isLocationIDPresentInDB(String locationID) {
        return locationRepository.existsByLocationID(locationID);
    }
}



import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface LocationRepository extends JpaRepository<LocationEntity, String> {
    // Custom query to check if a locationID exists in the database
    boolean existsByLocationID(String locationID);
}



import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "location_table") // Replace "location_table" with the actual table name in your database
@Data
public class LocationEntity {
    @Id
    private String locationID;
    // Add other attributes as needed
}

////////////////////
package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;

@SuppressWarnings("unused")
@Data//
public class Location {
    @JsonProperty("LocationID")
    private String locationID;
    @JsonProperty("ClientID")
    private String clientID;
    @JsonProperty("LocationLookupID")
    private String locationLookupID;
    @JsonProperty("IsDeleted")
    private boolean isDeleted;
    @JsonProperty("Success")
    private boolean success;
    @JsonProperty("CommercialCoverages")
    private ArrayList<CommercialCoverage> commercialCoverages;
}





package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;
@SuppressWarnings("unused")
@Data//
public class Result {
    @JsonProperty("ClientID")
    private String clientID;
    @JsonProperty("ClientLookupID")
    private String clientLookupID;
    @JsonProperty("IsDeleted")
    private boolean isDeleted;
    @JsonProperty("Errors")
    private ArrayList<Object> errors;
    @JsonProperty("Warnings")
    private Object warnings;
    @JsonProperty("Success")
    private boolean success;
    @JsonProperty("Locations")
    private ArrayList<Location> locations;
    @JsonProperty("CommercialCoverages")
    private ArrayList<Object> commercialCoverages;
    @JsonProperty("Messages")
    private ArrayList<Object> messages;
}



package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@SuppressWarnings("unused")
@Data
public class ImportClientResponse {
    @JsonProperty("Result")
    private Result result;
    @JsonProperty("ImportRequestID")
    private String importRequestID;
}


//////////////////
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import org.junit.Before;
import org.junit.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import static org.junit.Assert.assertEquals;

public class ImportClientServiceImpTest {

    private TokenCache tokenCache;
    private LossControlServiceImpl lossControlServiceImpl;
    private Gson gson;
    private ObjectMapper objectMapper;
    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        tokenCache = new TokenCache(); // Instantiate the real TokenCache if needed
        lossControlServiceImpl = new LossControlServiceImpl(); // Instantiate the real LossControlServiceImpl if needed
        gson = new Gson(); // Instantiate the real Gson if needed
        objectMapper = new ObjectMapper(); // Instantiate the real ObjectMapper if needed

        importClientService = new ImportClientServiceImp();
        importClientService.setTokenCache(tokenCache);
        importClientService.setLossControlService(lossControlServiceImpl);
        importClientService.setGson(gson);
        importClientService.setObjectMapper(objectMapper);
    }

    @Test
    public void testImportClient_Success() throws CustomException, JsonProcessingException {
        // Prepare the JSON input
        String jsonInput = "{\"divisionLookupID\": \"123\", \"client\": {\"Name\": \"John Doe\"}}";

        // Call the method under test
        ImportClientResponse result = importClientService.importClient(jsonInput);

        // Assert the result based on your expectations
        assertEquals("SUCCESS", result.getStatus());
        // ... Assert other properties of the result if needed
    }
}

//
import static org.junit.Assert.assertEquals;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import org.junit.Before;
import org.junit.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

public class ImportClientServiceImpTest {

    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        importClientService = new ImportClientServiceImp();
        importClientService.tokenCache = new TokenCache(); // You may need to initialize tokenCache with appropriate data
        importClientService.lossControlServiceImpl = new LossControlServiceImpl(); // You may need to initialize lossControlServiceImpl with appropriate data
        importClientService.gson = new Gson();
        importClientService.objectMapper = new ObjectMapper();
    }

    @Test
    public void testImportClient_Success() throws CustomException, JsonProcessingException {
        // Test data
        String jsonInput = "{\"divisionLookupID\": \"123\", \"client\": {\"Name\": \"John Doe\"}}";

        // Call the method under test
        ImportClientResponse result = importClientService.importClient(jsonInput);

        // Assert the result (Replace the expected values with the actual expected output)
        assertEquals("EXPECTED_STATUS", result.getStatus());
        // ... Assert other properties of the response
    }
}

//
import static org.junit.Assert.assertEquals;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import org.junit.Before;
import org.junit.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

public class ImportClientServiceImpTest {

    private TokenCache tokenCache;
    private LossControlServiceImpl lossControlServiceImpl;
    private Gson gson;
    private ObjectMapper objectMapper;
    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        // Initialize test instances
        tokenCache = new TokenCache();
        lossControlServiceImpl = new LossControlServiceImpl();
        gson = new Gson();
        objectMapper = new ObjectMapper();
        importClientService = new ImportClientServiceImp(tokenCache, lossControlServiceImpl, gson, objectMapper);
    }

    @Test
    public void testImportClient_Success() throws CustomException, JsonProcessingException {
        // Prepare test data
        String jsonInput = "{\"divisionLookupID\": \"123\", \"client\": {\"Name\": \"John Doe\"}}";
        ImportClientRequest request = new ImportClientRequest();
        request.setDivisionLookupID("123");
        // ... Set other properties

        ImportClientResponse expectedResponse = new ImportClientResponse();
        expectedResponse.setStatus("SUCCESS");
        // ... Set other properties

        // Call the method under test
        ImportClientResponse result = importClientService.importClient(jsonInput);

        // Assert the result
        assertEquals(expectedResponse, result);
    }

    // Add more test cases as needed for other scenarios and error cases
}



//
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import org.junit.Before;
import org.junit.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import static org.junit.Assert.assertEquals;

public class ImportClientServiceImpTest {

    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        TokenCache tokenCache = new TokenCache();
        LossControlServiceImpl lossControlServiceImpl = new LossControlServiceImpl();
        Gson gson = new Gson();
        ObjectMapper objectMapper = new ObjectMapper();
        importClientService = new ImportClientServiceImp(tokenCache, lossControlServiceImpl, gson, objectMapper);
    }

    @Test
    public void testImportClient_Success() throws CustomException, JsonProcessingException {
        // Prepare the JSON input
        String jsonInput = "{\"divisionLookupID\": \"123\", \"client\": {\"Name\": \"John Doe\"}}";

        // Call the method under test
        ImportClientResponse result = importClientService.importClient(jsonInput);

        // Verify the behavior and the result
        assertEquals("SUCCESS", result.getStatus());
        // ... Add other assertions based on the expected response properties
    }
}


//
import static org.junit.Assert.assertEquals;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import org.junit.Before;
import org.junit.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

public class ImportClientServiceImpTest {

    private TokenCache tokenCache;
    private LossControlServiceImpl lossControlService;
    private Gson gson;
    private ObjectMapper objectMapper;
    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        tokenCache = new TokenCache(); // Initialize tokenCache as needed
        lossControlService = new LossControlServiceImpl(); // Initialize lossControlService as needed
        gson = new Gson();
        objectMapper = new ObjectMapper();
        importClientService = new ImportClientServiceImp(tokenCache, lossControlService, gson, objectMapper);
    }

    @Test
    public void testImportClient_Success() throws CustomException, JsonProcessingException {
        // Prepare the JSON input
        String jsonInput = "{\"divisionLookupID\": \"123\", \"client\": {\"Name\": \"John Doe\"}}";

        // Call the method under test
        ImportClientResponse result = importClientService.importClient(jsonInput);

        // Prepare the expected ImportClientRequest
        ImportClientRequest expectedRequest = new ImportClientRequest();
        expectedRequest.setDivisionLookupID("123");
        // ... Set other properties

        // Prepare the expected ImportClientResponse
        ImportClientResponse expectedResponse = new ImportClientResponse();
        expectedResponse.setStatus("SUCCESS");
        // ... Set other properties

        // Convert the result and expectedResponse to JSON strings for comparison
        String resultJson = gson.toJson(result);
        String expectedResponseJson = gson.toJson(expectedResponse);

        // Compare the JSON strings
        assertEquals(expectedResponseJson, resultJson);
    }
}



///
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;

    @Autowired
    private Gson gson;

    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(String json) throws CustomException, JsonProcessingException {

        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        String processedJson = objectMapper.writeValueAsString(importClientRequest);
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache1());
        log.info("Received JSON: " + processedJson);

        log.info("importClientResponse:" + importClientResponse);
        return importClientResponse;

    }
}



//

package uk.co.allianz.rap.lc.rest;

import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;


@Slf4j
@RestController
public class ValidationRest {


    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    //2. Build the end point/Resource path: POST: surveySubmission
    //3. Build standard JSON validation on incoming data
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<String> processJson(@RequestBody(required = false) final String json) {

        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            log.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");

        }
        try {
            //for validate JSON
           String validateinput=validationServiceImpl.processJson(json);
            //For import only client
            ImportClientResponse processedJson=importClientServiceImp.importClient(validateinput);
            log.info("JSON received successfully");
            return ResponseEntity.ok(processedJson);

        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            log.error("Invalid JSON: " + e.getMessage());
            return ResponseEntity.badRequest().body("Invalid JSON: " + e.getMessage());

        } catch (Exception e) {
            // Other exceptions
            log.error("Invalid JSON format");
            return ResponseEntity.badRequest().body("Invalid JSON format");

        }
    }
}






// Configure the date format for deserialization
        objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);

     // Configure the ObjectMapper to include non-null properties during serialization
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);



        ImportClientRequest importClientRequest = objectMapper.readValue(jsonDataWithoutInspection, ImportClientRequest.class);

        log.info("importClientRequest:"+importClientRequest);
        // access the data using the POJO classes(checking)
        log.info("Client Name:" + importClientRequest.getClient().getName());

        log.info("importClientRequest: " + importClientRequest);
        // Serialize the Java object back to JSON with non-null properties included
        String processedJson = objectMapper.writeValueAsString(importClientRequest);


//        String processedJson = gson.toJson(importClientRequest);
       // ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache1());


    //    log.info("importClientResponse:" + importClientResponse);

        log.info("Received JSON: " + processedJson);
        return processedJson;



//

{
    "client": {
        "lookupID": "C008032993",
        "policyNumber": "SP26853148",
        "address": {
            "country": "United Kingdom"
        },
        "agent": {
            "agencyCode": "22576",
            "agencyName": "Arthur J. Gallagher",
            "agentCode": "13332",
            "address": {
                "country": "United Kingdom"
            },
            "agentType": "Broker"
        },
        "locations": [
            {
                "lookupID": "",
                "policyNumber": "SP26853148",
                "renewalDate": "Jul 17, 2024, 5:30:00 AM",
                "address": {
                    "country": "United Kingdom",
                    "street1": "NEW CROSS DEWEL",
                    "street2": "SD 11 JEW TOWN",
                    "city": "MM KEMSTONE",
                    "region1": "UK",
                    "zipCode": "GU1 1DB"
                },
                "coverages": [
                    {
                        "coverageReference": "Coverage 1",
                        "coverageTypeLookup": "PD_TIV",
                        "genericFields": [
                            {
                                "number": "1123",
                                "key": "01. PD Building",
                                "genericFieldValueType": 1
                            },
                            {
                                "number": "0",
                                "key": "04. PD Other",
                                "genericFieldValueType": 1
                            },
                            {
                                "key": "05. PD Other Description",
                                "genericFieldValueType": 0,
                                "text": ""
                            },
                            {
                                "number": "1123",
                                "key": "06. TIV PD",
                                "genericFieldValueType": 1
                            },
                            {
                                "number": "332198",
                                "key": "07. TIV BI",
                                "genericFieldValueType": 1
                            },
                            {
                                "number": "",
                                "key": "08. BI Base Period (Months)",
                                "genericFieldValueType": 1
                            },
                            {
                                "number": "332198",
                                "key": "09. TIV (PD + BI )",
                                "genericFieldValueType": 1
                            }
                        ]
                    }
                ]
            }
        ]
    }
}
//
{
  "divisionLookupID" : "AZ_UK",
  "client" : {
    "LookupID" : "C008032993",
    "ContactFirstName" : null,
    "ContactLastName" : null,
    "PolicyNumber" : "SP26853148",
    "Name" : null,
    "Phone" : null,
    "Email" : null,
    "Address" : {
      "Country" : "United Kingdom",
      "OverseasTerritories" : null,
      "Street1" : null,
      "Street2" : null,
      "City" : null,
      "Region1" : null,
      "Region2" : null,
      "Region3" : null,
      "Region4" : null,
      "ZipCode" : null
    },
    "Agent" : {
      "AgencyCode" : "22576",
      "AgencyName" : "Arthur J. Gallagher",
      "AgentCode" : "13332",
      "AgentName" : null,
      "Email" : null,
      "FaxNumber" : null,
      "PhoneNumber" : null,
      "Address" : {
        "Country" : "United Kingdom",
        "OverseasTerritories" : null,
        "Street1" : null,
        "Street2" : null,
        "City" : null,
        "Region1" : null,
        "Region2" : null,
        "Region3" : null,
        "Region4" : null,
        "ZipCode" : null
      },
      "AgentType" : "Broker"
    },
    "Underwriter" : null,
    "Locations" : [ {
      "genericFields" : null,
      "LookupID" : "",
      "Name" : null,
      "PolicyNumber" : "SP26853148",
      "PolicyEffectiveDate" : null,
      "PolicyExpirationDate" : null,
      "PolicyRenewalDate" : null,
      "Address" : {
        "Country" : "United Kingdom",
        "OverseasTerritories" : null,
        "Street1" : "NEW CROSS DEWEL",
        "Street2" : "SD 11 JEW TOWN",
        "City" : "MM KEMSTONE",
        "Region1" : "UK",
        "Region2" : null,
        "Region3" : null,
        "Region4" : null,
        "ZipCode" : "GU1 1DB"
      },
      "OriginalEffectiveDate" : null,
      "EffectiveDate" : null,
      "ExpirationDate" : null,
      "RenewalDate" : "2024-07-17",
      "LastInspectedDate" : null,
      "Coverages" : [ {
        "CoverageTypeLookup" : "PD_TIV",
        "CoverageReference" : "Coverage 1",
        "GenericFields" : [ {
          "Number" : "1123",
          "Key" : "01. PD Building",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "0",
          "Key" : "04. PD Other",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : null,
          "Key" : "05. PD Other Description",
          "GenericFieldValueType" : 0,
          "Text" : ""
        }, {
          "Number" : "1123",
          "Key" : "06. TIV PD",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "332198",
          "Key" : "07. TIV BI",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "",
          "Key" : "08. BI Base Period (Months)",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "332198",
          "Key" : "09. TIV (PD + BI )",
          "GenericFieldValueType" : 1,
          "Text" : null
        } ]
      } ],
      "Contact" : null
    } ]
  }
}


//package uk.co.allianz.rap.lc.rest;

import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;


@Slf4j
@RestController
public class ValidationRest {

    private static final Logger LOGGER = LoggerFactory.getLogger(ValidationRest.class);

    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    //2. Build the end point/Resource path: POST: surveySubmission
    //3. Build standard JSON validation on incoming data
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<String> processJson(@RequestBody(required = false) final String json) {

        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            LOGGER.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");

        }
        try {
            //for validate JSON
           String validateinput=validationServiceImpl.processJson(json);
            // Return a response indicating success
            //For import only client and remove inspection
            String processedJson=importClientServiceImp.importClient(validateinput);
            LOGGER.info("JSON received successfully");
            return ResponseEntity.ok(processedJson);

        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            LOGGER.error("Invalid JSON: " + e.getMessage());
            return ResponseEntity.badRequest().body("Invalid JSON: " + e.getMessage());

        } catch (Exception e) {
            // Other exceptions
            LOGGER.error("Invalid JSON format");
            return ResponseEntity.badRequest().body("Invalid JSON format");

        }
    }
}



//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import com.google.json.JsonSanitizer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.exception.CustomException;

//3. Build standard JSON validation on incoming data
@Service
public class ValidationServiceImpl implements ValidationService {

    @Autowired
    private ImportClientServiceImp importClientServiceImp;
    private static final Logger LOGGER = LoggerFactory.getLogger(ValidationServiceImpl.class);

    public String processJson(final String json) throws CustomException, JsonProcessingException {
        // Parse the JSON string into a JsonElement

        JsonElement jsonElement;
        jsonElement = JsonParser.parseString(json);

        // Check if the JSON is a single value (string or number) or empty object/array
        if (isSingleValue(jsonElement)) {
            throw new CustomException("JSON is a single value. ");
        } else if (isEmptyObject(jsonElement) || isEmptyArray(jsonElement)) {
            throw new CustomException("JSON is empty object/array. ");
        }

        // Print the received JSON
        String sanitizedJson = JsonSanitizer.sanitize(json);


        return sanitizedJson;
    }

    // Helper method to check if the JSON element is a single value
    private boolean isSingleValue(final JsonElement jsonElement) {
        return !jsonElement.isJsonObject() && !jsonElement.isJsonArray();
    }

    // Helper method to check if the JSON element is an empty object ({})
    private boolean isEmptyObject(final JsonElement jsonElement) {
        return jsonElement.isJsonObject() && jsonElement.getAsJsonObject().entrySet().isEmpty();
    }

    // Helper method to check if the JSON element is an empty array ([])
    private boolean isEmptyArray(final JsonElement jsonElement) {
        return jsonElement.isJsonArray() && jsonElement.getAsJsonArray().size() == 0;
    }
}
//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.gson.Gson;
import com.google.json.JsonSanitizer;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;

    @Autowired
    private Gson gson;

    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public String importClient(String json) throws CustomException, JsonProcessingException {

        // Remove the "inspection" field from the JSON string
        JsonNode rootNode = new ObjectMapper().readTree(json);

        ((ObjectNode) rootNode).remove("inspection");
        String jsonDataWithoutInspection = rootNode.toString();


        //Data Mapping into Model(POJO) class
        ImportClientRequest importClientRequest = objectMapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT).readValue(jsonDataWithoutInspection, ImportClientRequest.class);

        log.info("importClientRequest:"+importClientRequest);
        // access the data using the POJO classes(checking)
        log.info("Client Name:" + importClientRequest.getClient().getName());

        log.info("importClientRequest: " + importClientRequest);

        String processedJson = gson.toJson(importClientRequest);
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache1());


        log.info("importClientResponse:" + importClientResponse);

        log.info("Received JSON: " + processedJson);
        return processedJson;

    }
}



///////////
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

@WebMvcTest(ImportClientController.class)
public class ImportClientControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testImportClient1_NullData() throws Exception {
        // Given
        String jsonData = null;

        // When-Then
        mockMvc.perform(post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content(jsonData))
                .andExpect(status().isBadRequest());
    }
}

//
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;

@WebMvcTest(ImportClientController.class)
public class ImportClientControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private Gson gson;

    @MockBean
    private ObjectMapper objectMapper;

    @Test
    public void testImportClient1_Success() throws Exception {
        // Given
        String jsonData = "{\"client\": {\"name\": \"John Doe\"}, \"inspection\": \"data\"}";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client client = new Client();
        client.setName("John Doe");
        importClientRequest.setClient(client);

        // Mock the behavior of ObjectMapper and Gson
        when(objectMapper.readTree(anyString())).thenReturn(new ObjectMapper().readTree(jsonData));
        when(gson.toJson(any(ImportClientRequest.class))).thenReturn("{\"client\":{\"name\":\"John Doe\"}}");

        // When-Then
        mockMvc.perform(post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content(jsonData))
                .andExpect(status().isOk());
    }
}


//
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;

// Add the necessary annotations
@SpringBootTest
@ContextConfiguration(classes = {ImportClientController.class})
@WebMvcTest
public class ImportClientControllerTest {

    @Autowired
    private MockMvc mockMvc;

    // Sample JSON data for testing
    private static final String SAMPLE_JSON_DATA = "{\"client\": {\"name\": \"John Doe\"}, \"inspection\": {\"field\": \"value\"}}";

    @Test
    public void testImportClient1_ValidData_Success() throws Exception {
        // Perform the POST request to "/import-client"
        mockMvc.perform(post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content(SAMPLE_JSON_DATA))
                .andExpect(status().isOk());
        // Add more assertions as needed based on the expected behavior
    }

    @Test
    public void testImportClient1_NullData_BadRequest() throws Exception {
        // Perform the POST request with null data
        mockMvc.perform(post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content((String) null))
                .andExpect(status().isBadRequest());
        // Add more assertions as needed based on the expected behavior
    }

    @Test
    public void testImportClient1_InvalidData_BadRequest() throws Exception {
        // Sample JSON data with invalid format to trigger an exception
        String invalidData = "invalid_json_data";

        // Perform the POST request with invalid data
        mockMvc.perform(post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content(invalidData))
                .andExpect(status().isBadRequest());
        // Add more assertions as needed based on the expected behavior
    }

    // Add more test cases as needed to cover different scenarios and edge cases
}


//
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.gson.Gson;
import com.google.json.JsonSanitizer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(ImportClientController.class)
@ContextConfiguration(classes = {ImportClientController.class})
public class ImportClientControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private Gson gson;

    @Autowired
    private ObjectMapper objectMapper;

    private String sampleJsonData;

    @BeforeEach
    public void setUp() {
        // Initialize sample JSON data for testing
        sampleJsonData = "{\"client\": {\"name\": \"John Doe\"}, \"inspection\": \"some data\"}";
    }

    @Test
    public void testImportClient1_Success() throws Exception {
        // Remove the "inspection" field from the JSON string
        JsonNode rootNode = objectMapper.readTree(sampleJsonData);
        ((ObjectNode) rootNode).remove("inspection");
        String jsonDataWithoutInspection = rootNode.toString();

        String sanitizedData = JsonSanitizer.sanitize(jsonDataWithoutInspection);

        ImportClientRequest expectedRequest = objectMapper.readValue(sanitizedData, ImportClientRequest.class);

        // Perform the actual API call
        mockMvc.perform(MockMvcRequestBuilders.post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content(sampleJsonData))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$.client.name").value(expectedRequest.getClient().getName()));
    }

    @Test
    public void testImportClient1_NullData() throws Exception {
        // Perform the API call with null JSON data
        mockMvc.perform(MockMvcRequestBuilders.post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content((String) null))
                .andExpect(status().isBadRequest())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON));
    }

    @Test
    public void testImportClient1_InvalidData() throws Exception {
        // Perform the API call with invalid JSON data
        String invalidData = "Invalid JSON Data";
        mockMvc.perform(MockMvcRequestBuilders.post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content(invalidData))
                .andExpect(status().isBadRequest())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON));
    }
}




//
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

public class ImportClientControllerTest {

    // Instantiate the actual controller to be tested
    private ImportClientController importClientController = new ImportClientController();

    @Test
    public void testImportClient1() {
        // Sample JSON data for testing
        String jsonData = "{\"client\":{\"name\":\"John Doe\"},\"inspection\":{\"type\":\"some_type\"}}";

        // Perform the test
        ResponseEntity<String> responseEntity = importClientController.importClient1(jsonData);

        // Assertions
        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
        assertNotNull(responseEntity.getBody());

        // Since the JSON sanitization is not being tested here, you can perform some basic checks
        assertFalse(responseEntity.getBody().contains("inspection"));
        assertTrue(responseEntity.getBody().contains("John Doe"));
    }

    @Test
    public void testImportClient1WithNullData() {
        // Test with null JSON data
        ResponseEntity<String> responseEntity = importClientController.importClient1(null);

        // Assertions
        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());
        assertTrue(responseEntity.getBody().contains("JSON Data is null"));
    }

    @Test
    public void testImportClient1WithInvalidData() {
        // Test with invalid JSON data
        String invalidData = "Invalid JSON data";
        ResponseEntity<String> responseEntity = importClientController.importClient1(invalidData);

        // Assertions
        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());
        assertTrue(responseEntity.getBody().contains("Failed to parse JSON"));
    }
}



<!-- JUnit 5 dependencies -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <version>5.8.0</version>
    <scope>test</scope>
</dependency>

//
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import com.google.json.JsonSanitizer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class ImportClientControllerTest {

    private ImportClientController importClientController;
    private Gson gson;
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        gson = new Gson();
        objectMapper = new ObjectMapper();
        importClientController = new ImportClientController(gson, objectMapper);
    }

    @Test
    public void testImportClient1_Success() throws Exception {
        // Given
        ImportClientRequest request = new ImportClientRequest();
        // Set up your request data here

        String jsonData = gson.toJson(request);

        // When
        ResponseEntity<String> response = importClientController.importClient1(jsonData);

        // Then
        assertEquals(HttpStatus.OK, response.getStatusCode());
        // Add more assertions to verify the response content
    }

    @Test
    public void testImportClient1_NullData() {
        // Given
        String jsonData = null;

        // When
        ResponseEntity<String> response = importClientController.importClient1(jsonData);

        // Then
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        // Add more assertions to verify the response content
    }

    @Test
    public void testImportClient1_Exception() {
        // Given
        String jsonData = "invalid_json"; // Invalid JSON data

        // When
        ResponseEntity<String> response = importClientController.importClient1(jsonData);

        // Then
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        // Add more assertions to verify the response content
    }
}

//////////////////////
package uk.co.allianz.rap.lc.rest;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.gson.Gson;
import com.google.json.JsonSanitizer;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;

@Slf4j
@RestController
public class ImportClientController {

    @Autowired
    private Gson gson;

    @Autowired
    private ObjectMapper objectMapper;

    //Extracting fields and data from the "data model" sent from loss-control-adapter
    //and building the API request: ImportClient
    @PostMapping("/import-client")
    public ResponseEntity<String> importClient1(@RequestBody String jsonData) {
        try {
            if (jsonData == null) {
                throw new IllegalArgumentException("JSON Data is null");
            }

            // Remove the "inspection" field from the JSON string
            JsonNode rootNode = new ObjectMapper().readTree(jsonData);
            ((ObjectNode) rootNode).remove("inspection");
            String jsonDataWithoutInspection = rootNode.toString();

            String sanitizedData = JsonSanitizer.sanitize(jsonDataWithoutInspection);

            ImportClientRequest importClientRequest = objectMapper.readValue(sanitizedData, ImportClientRequest.class);

            // access the data using the POJO classes
            log.info("Client Name:" + importClientRequest.getClient().getName());


            String processedJson = gson.toJson(importClientRequest);
            return ResponseEntity.ok(processedJson);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }
}

......................

//Added 2 Location and inspection

{
    "inspection":{
        "PolicyNumber":"1"
    },
    "divisionLookupID": "AZ_UK",
    "client": {
        "LookupID": "27105",
        "ContactFirstName": "Client Contact First Name",
        "ContactLastName": "Client Contact Last Name",
        "PolicyNumber": "AS-86587667",
        "Name": "MW Ultan Client Name",
        "Phone": "client Phone",
        "Email": "email@client.com",
        "Address": {
            "Country": "GB",
            "OverseasTerritories": "England",
            "Street1": "C.A. street 1",
            "Street2": "C.A street 2",
            "City": "C.A. City",
            "Region1": "C.A. region1",
            "Region2": "C.A. region2",
            "Region3": "C.A. region3",
            "Region4": "C.A. region4",
            "ZipCode": "C.A. Post Code"
        },
        "Agent": {
            "AgencyCode": "12345678",
            "AgencyName": "MW Ultan Agent 2",
            "AgentCode": "1234",
            "AgentName": "MW Ultan The Only Agent",
            "Email": "ultan@agency.com",
            "FaxNumber": "004416107890",
            "PhoneNumber": "0044316107892",
            "Address": {
                "Country": "GB",
                "Street1": "Agent Street1",
                "Street2": "Agent Street2",
                "City": "Norwich",
                "Region1": "Region1",
                "Region2": "Region2",
                "Region3": "Region3",
                "Region4": "Region4",
                "ZipCode": "PostCode"
            },
            "AgentType": "Broker"
        },
        "Underwriter": {
            "Company": "MW Underwriter company",
            "Email": "ultan@underwriter.com",
            "FirstName": "Underwriter-Ultan",
            "LastName": "Underwriter-McPadden",
            "PhoneNumber": "00441234567",
            "UnderwriterCode": "12345"
        },
        "Locations": [
            {
                "LookupID": "29647",
                "Name": "MW LocationTestUltan API New",
                "PolicyNumber": "API9876567",
                "PolicyEffectiveDate": "2023-03-28T15:08:58.889075+01:00",
                "PolicyExpirationDate": "2023-03-28T15:08:58.889075+01:00",
                "PolicyRenewalDate": "2023-03-28T15:08:58.889075+01:00",
                "Address": {
                    "Country": "GB",
                    "Street1": "L.A. street 1",
                    "Street2": "L.A. street 2",
                    "City": "London",
                    "Region1": "L.A Region1",
                    "Region2": "L.A Region2",
                    "Region3": "L.A Region3",
                    "Region4": "L.A Region4",
                    "ZipCode": "L.A PostCode"
                },
                "OriginalEffectiveDate": "2023-03-28T15:08:58.8820749+01:00",
                "EffectiveDate": "2023-03-28T15:08:58.8820749+01:00",
                "ExpirationDate": "2023-03-28T15:08:58.8820749+01:00",
                "RenewalDate": "2023-03-28T15:08:58.8820749+01:00",
                "LastInspectedDate": "2023-03-28T15:08:58.8820749+01:00",
                "genericFields": [
                    {
                        "key": "0.ISIC+Code",
                        "text": "",
                        "genericFieldValueType": 0
                    }
                ],
                "Coverages": [
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "GenericFields": [
                            {
                                "Number": "50000",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "40000",
                                "Key": "02. PD Content",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "30000",
                                "Key": "03. Stock & Supply",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "20000",
                                "Key": "04. PD Other",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Text": "Machinary",
                                "Key": "05. PD Other Description",
                                "GenericFieldValueType": 0
                            },
                            {
                                "Number": "140000",
                                "Key": "06. TIV PD",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "10000",
                                "Key": "07. TIV BI",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "12",
                                "Key": "08. BI Base Period (Months)",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "150000",
                                "Key": "09. TIV (PD + BI )",
                                "GenericFieldValueType": 1
                            }
                        ]
                    },
                    {
                        "CoverageTypeLookup": "CC_LIAB",
                        "GenericFields": [
                            {
                                "Number": "5000",
                                "Key": "Limit of Liability",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "10",
                                "Key": "Number of Employees",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "5000",
                                "Key": "Total Turnover",
                                "GenericFieldValueType": 1
                            }
                        ]
                    }
                ],
                "Contact": {
                    "CellPhone": "L. Contact Cellphone",
                    "CompanyName": "L. Contact CompanyName",
                    "Email": "L. Contact Email",
                    "FirstName": "L. Contact First Name",
                    "HomePhone": "L. Contact HomePhone",
                    "LastName": "L. Contact LastName",
                    "Occupation": "L. Contact Occupation",
                    "UseCompanyName": true,
                    "WorkPhone": "L. Contact WorkPhone",
                    "Location": "L. Contact Location"
                }
            },
            // Add one more location here
            {
                "LookupID": "12345",
                "Name": "MW Second Location",
                "PolicyNumber": "API9876568",
                "PolicyEffectiveDate": "2023-03-29T15:08:58.889075+01:00",
                "PolicyExpirationDate": "2023-03-29T15:08:58.889075+01:00",
                "PolicyRenewalDate": "2023-03-29T15:08:58.889075+01:00",
                "Address": {
                    "Country": "GB",
                    "Street1": "Second street 1",
                    "Street2": "Second street 2",
                    "City": "London",
                    "Region1": "Second Region1",
                    "Region2": "Second Region2",
                    "Region3": "Second Region3",
                    "Region4": "Second Region4",
                    "ZipCode": "Second PostCode"
                },
                "OriginalEffectiveDate": "2023-03-29T15:08:58.8820749+01:00",
                "EffectiveDate": "2023-03-29T15:08:58.8820749+01:00",
                "ExpirationDate": "2023-03-29T15:08:58.8820749+01:00",
                "RenewalDate": "2023-03-29T15:08:58.8820749+01:00",
                "LastInspectedDate": "2023-03-29T15:08:58.8820749+01:00",
                "genericFields": [
                    {
                        "key": "0.ISIC+Code",
                        "text": "",
                        "genericFieldValueType": 0
                    }
                ],
                "Coverages": [
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "GenericFields": [
                            {
                                "Number": "50000",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1
                            }
                            // ... other fields
                        ]
                    }
                    // Add other coverages if needed
                ],
                "Contact": {
                    "CellPhone": "Second Contact Cellphone"
                    // ... other fields
                }
            }
        ]
    }
}


//////////////////////////////////
{
  "divisionLookupID" : "AZ_UK",
  "client" : {
    "LookupID" : "C008032993",
    "ContactFirstName" : null,
    "ContactLastName" : null,
    "PolicyNumber" : "SP26853148",
    "Name" : "CLIENT NEW BR",
    "Phone" : null,
    "Email" : null,
    "Address" : {
      "Country" : "United Kingdom",
      "OverseasTerritories" : null,
      "Street1" : null,
      "Street2" : null,
      "City" : null,
      "Region1" : null,
      "Region2" : null,
      "Region3" : null,
      "Region4" : null,
      "ZipCode" : null
    },
    "Agent" : {
      "AgencyCode" : "22576",
      "AgencyName" : "Arthur J. Gallagher",
      "AgentCode" : "13332",
      "AgentName" : null,
      "Email" : null,
      "FaxNumber" : null,
      "PhoneNumber" : null,
      "Address" : {
        "Country" : "United Kingdom",
        "OverseasTerritories" : null,
        "Street1" : null,
        "Street2" : null,
        "City" : null,
        "Region1" : null,
        "Region2" : null,
        "Region3" : null,
        "Region4" : null,
        "ZipCode" : null
      },
      "AgentType" : "Broker"
    },
    "Underwriter" : null,
    "Locations" : [ {
      "genericFields" : null,
      "LookupID" : "",
      "Name" : null,
      "PolicyNumber" : "SP26853148",
      "PolicyEffectiveDate" : null,
      "PolicyExpirationDate" : null,
      "PolicyRenewalDate" : null,
      "Address" : {
        "Country" : "United Kingdom",
        "OverseasTerritories" : null,
        "Street1" : "NEW CROSS DEWEL",
        "Street2" : "SD 11 JEW TOWN",
        "City" : "MM KEMSTONE",
        "Region1" : "UK",
        "Region2" : null,
        "Region3" : null,
        "Region4" : null,
        "ZipCode" : "GU1 1DB"
      },
      "OriginalEffectiveDate" : null,
      "EffectiveDate" : null,
      "ExpirationDate" : null,
      "RenewalDate" : "2024-07-17",
      "LastInspectedDate" : null,
      "Coverages" : [ {
        "CoverageTypeLookup" : "PD_TIV",
        "CoverageReference" : "Coverage 1",
        "GenericFields" : [ {
          "Number" : "1123",
          "Key" : "01. PD Building",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "0",
          "Key" : "04. PD Other",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : null,
          "Key" : "05. PD Other Description",
          "GenericFieldValueType" : 0,
          "Text" : ""
        }, {
          "Number" : "1123",
          "Key" : "06. TIV PD",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "332198",
          "Key" : "07. TIV BI",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "",
          "Key" : "08. BI Base Period (Months)",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "332198",
          "Key" : "09. TIV (PD + BI )",
          "GenericFieldValueType" : 1,
          "Text" : null
        } ]
      } ],
      "Contact" : null
    } ]
  }
}




public class GenericField{
    public String key;
    public String text;
    public int genericFieldValueType;
}



public class Location{
    @JsonProperty("LookupID") 
    public String lookupID;
    @JsonProperty("Name") 
    public String name;
    @JsonProperty("PolicyNumber") 
    public String policyNumber;
    @JsonProperty("PolicyEffectiveDate") 
    public Date policyEffectiveDate;
    @JsonProperty("PolicyExpirationDate") 
    public Date policyExpirationDate;
    @JsonProperty("PolicyRenewalDate") 
    public Date policyRenewalDate;
    @JsonProperty("Address") 
    public Address address;
    @JsonProperty("OriginalEffectiveDate") 
    public Date originalEffectiveDate;
    @JsonProperty("EffectiveDate") 
    public Date effectiveDate;
    @JsonProperty("ExpirationDate") 
    public Date expirationDate;
    @JsonProperty("RenewalDate") 
    public Date renewalDate;
    @JsonProperty("LastInspectedDate") 
    public Date lastInspectedDate;
    public ArrayList<GenericField> genericFields;
    @JsonProperty("Coverages") 
    public ArrayList<Coverage> coverages;
    @JsonProperty("Contact") 
    public Contact contact;
}



................
{
    "divisionLookupID": "AZ_UK",
    "client": {
        "LookupID": "27105",
        "ContactFirstName": "Client Contact First Name",
        "ContactLastName": "Client Contact Last Name",
        "PolicyNumber": "AS-86587667",
        "Name": "MW Ultan Client Name",
        "Phone": "client Phone",
        "Email": "email@client.com",
        "Address": {
            "Country": "GB",
            "OverseasTerritories": "England",
            "Street1": "C.A. street 1",
            "Street2": "C.A street 2",
            "City": "C.A. City",
            "Region1": "C.A. region1",
            "Region2": "C.A. region2",
            "Region3": "C.A. region3",
            "Region4": "C.A. region4",
            "ZipCode": "C.A. Post Code"
        },
        "Agent": {
            "AgencyCode": "12345678",
            "AgencyName": "MW Ultan Agent 2",
            "AgentCode": "1234",
            "AgentName": "MW Ultan The Only Agent",
            "Email": "ultan@agency.com",
            "FaxNumber": "004416107890",
            "PhoneNumber": "0044316107892",
            "Address": {
                "Country": "GB",
                "Street1": "Agent Street1",
                "Street2": "Agent Street2",
                "City": "Norwich",
                "Region1": "Region1",
                "Region2": "Region2",
                "Region3": "Region3",
                "Region4": "Region4",
                "ZipCode": "PostCode"
            },
            "AgentType": "Broker"
        },
        "Underwriter": {
            "Company": "MW Underwriter company",
            "Email": "ultan@underwriter.com",
            "FirstName": "Underwriter-Ultan",
            "LastName": "Underwriter-McPadden",
            "PhoneNumber": "00441234567",
            "UnderwriterCode": "12345"
        },
        "Locations": [
            {
                "LookupID": "29647",
                "Name": "MW LocationTestUltan API New",
                "PolicyNumber": "API9876567",
                "PolicyEffectiveDate": "2023-03-28T15:08:58.889075+01:00",
                "PolicyExpirationDate": "2023-03-28T15:08:58.889075+01:00",
                "PolicyRenewalDate": "2023-03-28T15:08:58.889075+01:00",
                "Address": {
                    "Country": "GB",
                    "Street1": "L.A. street 1",
                    "Street2": "L.A. street 2",
                    "City": "London",
                    "Region1": "L.A Region1",
                    "Region2": "L.A Region2",
                    "Region3": "L.A Region3",
                    "Region4": "L.A Region4",
                    "ZipCode": "L.A PostCode"
                },
                "OriginalEffectiveDate": "2023-03-28T15:08:58.8820749+01:00",
                "EffectiveDate": "2023-03-28T15:08:58.8820749+01:00",
                "ExpirationDate": "2023-03-28T15:08:58.8820749+01:00",
                "RenewalDate": "2023-03-28T15:08:58.8820749+01:00",
                "LastInspectedDate": "2023-03-28T15:08:58.8820749+01:00",
                "genericFields": [
                    {
                        "key": "0.ISIC+Code",
                        "text": "",
                        "genericFieldValueType": 0
                    }
                ],
                "Coverages": [
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "GenericFields": [
                            {
                                "Number": "50000",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "40000",
                                "Key": "02. PD Content",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "30000",
                                "Key": "03. Stock & Supply",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "20000",
                                "Key": "04. PD Other",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Text": "Machinary",
                                "Key": "05. PD Other Description",
                                "GenericFieldValueType": 0
                            },
                            {
                                "Number": "140000",
                                "Key": "06. TIV PD",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "10000",
                                "Key": "07. TIV BI",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "12",
                                "Key": "08. BI Base Period (Months)",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "150000",
                                "Key": "09. TIV (PD + BI )",
                                "GenericFieldValueType": 1
                            }
                        ]
                    },
                    {
                        "CoverageTypeLookup": "CC_LIAB",
                        "GenericFields": [
                            {
                                "Number": "5000",
                                "Key": "Limit of Liability",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "10",
                                "Key": "Number of Employees",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "5000",
                                "Key": "Total Turnover",
                                "GenericFieldValueType": 1
                            }
                        ]
                    }
                ],
                "Contact": {
                    "CellPhone": "L. Contact Cellphone",
                    "CompanyName": "L. Contact CompanyName",
                    "Email": "L. Contact Email",
                    "FirstName": "L. Contact First Name",
                    "HomePhone": "L. Contact HomePhone",
                    "LastName": "L. Contact LastName",
                    "Occupation": "L. Contact Occupation",
                    "UseCompanyName": true,
                    "WorkPhone": "L. Contact WorkPhone",
                    "Location": "L. Contact Location"
                }
            }
        ]
    }
}






...............................................................................................................................
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import com.google.gson.JsonObject;

@RestController
public class DataController {

	private final DataService dataService;
	private final Gson gson;
	private final ObjectMapper objectMapper;

	@Autowired
	public DataController(DataService dataService, Gson gson, ObjectMapper objectMapper) {
		this.dataService = dataService;
		this.gson = gson;
		this.objectMapper = objectMapper;

	}
	@PostMapping("/client")
    public ResponseEntity<String> processData1(@RequestBody String jsonData) {
        try {
            if (jsonData == null) {
                throw new IllegalArgumentException("JSON Data Can't be null");
            }
            List<JsonObject> processedData = dataService.processJsonData(jsonData);
            String processedJson = gson.toJson(processedData);

            // Deserialize JSON into ImportClientRequest objects
            ImportClientRequest[] importClientRequests = objectMapper.readValue(processedJson,
                    ImportClientRequest[].class);

            // Now you have the data in Java objects, and you can work with it as needed
            for (ImportClientRequest importClientRequest : importClientRequests) {
                // Access data from each ImportClientRequest object
                String divisionLookupID = importClientRequest.getDivisionLookupID();
                Client client = importClientRequest.getClient();
                // ... and so on

                System.out.println("DivisionLookupID: " + divisionLookupID);
                if (client != null) {
                    System.out.println("Client LookupID: " + client.getLookupID());
                    System.out.println("Client PolicyNumber: " + client.getPolicyNumber());
                    System.out.println("Client PolicyName: " + client.getName());

                    Address address = client.getAddress();
                    if (address != null) {
                        System.out.println("Address country: " + address.getCountry());
                        // Access other address fields as needed
                    }

                    Agent agent = client.getAgent();
                    if (agent != null) {
                        System.out.println("AgencyCode: " + agent.getAgencyCode());
                        System.out.println("AgencyName: " + agent.getAgencyName());
                        System.out.println("AgentCode: " + agent.getAgentCode());
                        // Access other agent fields as needed
                    }

                    List<Location> locationsList = client.getLocations();
                    for (Location location : locationsList) {
                        System.out.println("RenewalDate: " + location.getRenewalDate());
                        // Access other location fields as needed
                    }
                }
            }

            return ResponseEntity.ok("JSON data processed successfully.");
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

	@PostMapping("/data")
	public ResponseEntity<String> processData(@RequestBody String jsonData) {
		try {

			if (jsonData == null) {
				throw new IllegalArgumentException("JSON Data Can't be null");
			}
			List<JsonObject> processedData = dataService.processJsonData(jsonData);
			String processedJson = gson.toJson(processedData);
			return ResponseEntity.ok(processedJson);
		} catch (IllegalArgumentException e) {
			return ResponseEntity.badRequest().body(e.getMessage());
		}
	}
}




[ {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "BS",
  "inspections.0.Mailing.Country" : "RR",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP22677819",
  "inspections.0.Mailing.Street1" : "C012682006",
  "inspections.0.PolicyHolder.CompanyName" : "tBh mMgw uouC qwpASux",
  "inspections.0.Agent.AgentCode" : "100 pBlyGJMnGFiyw",
  "inspections.0.Agent.AgentType" : "qCqvND",
  "inspections.0.Agent.AgencyName" : "qwdewq",
  "inspections.0.Agent.AgencyCode" : "SW1X 7LJ",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "94431",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "13832",
  "inspections.0.CurrencyISO" : "Lockton Companies LLP",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20231231",
  "inspections.0.GenericFields.0.GenericFields" : "872170",
  "divisionLookupID" : "1391199069",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20220128",
  "client.Name" : "Property Damage All Risks Section",
  "client.Address.Country" : "13",
  "client.Agent.AgencyCode" : "12.64",
  "client.Agent.AgencyName" : "20210101",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "6656",
  "client.Agent.Address.Street1" : "1149.6",
  "client.Agent.Address.Street2" : "20190902",
  "client.Agent.Address.City" : "Property Damage All Risks Section",
  "client.Agent.Address.Region1" : "3379",
  "client.Agent.Address.Region2" : "3378.13",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Terrorism - Property Damage",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Contents",
  "client.Locations.0.Address.Street2" : "132531529",
  "client.Locations.0.Address.City" : "3",
  "client.Locations.0.Address.Region1" : "Buildings",
  "client.Locations.0.Address.Region2" : "575700000",
  "client.Locations.0.Address.ZipCode" : "1",
  "client.Locations.0.RenewalDate" : "Global Terrorism - Business Interruption",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "2",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Item Details",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "0",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "3",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Bus. Interrupt."
  }, {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "CS",
  "inspections.0.Mailing.Country" : "PT",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP25496107",
  "inspections.0.Mailing.Street1" : "C006729450",
  "inspections.0.PolicyHolder.CompanyName" : "uvrwMyR mCwwK xsuNHsyE qHg & uvrwMyR mCwwKS qHg y/o uvrwMyR",
  "inspections.0.Agent.AgentCode" : "psqKHDAFDK lsJilwH GJBeHw",
  "inspections.0.Agent.AgentType" : "qCqvND",
  "inspections.0.Agent.AgencyName" : "dasas",
  "inspections.0.Agent.AgencyCode" : "W2 4BH",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS & HOTELIERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "94431",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "13832",
  "inspections.0.CurrencyISO" : "Lockton Companies LLP",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20220101",
  "inspections.0.GenericFields.0.GenericFields" : "3720",
  "divisionLookupID" : "1274250",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20200713",
  "client.Name" : "Property Damage All Risks Section",
  "client.Address.Country" : "0",
  "client.Agent.AgencyCode" : "0",
  "client.Agent.AgencyName" : "20200601",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "3335",
  "client.Agent.Address.Street1" : "390",
  "client.Agent.Address.Street2" : "12334",
  "client.Agent.Address.City" : "ABC",
  "client.Agent.Address.Region1" : "0",
  "client.Agent.Address.Region2" : "0",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Property Damage All Risks Section",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Contents of Flats and Private dwellings as advised",
  "client.Locations.0.Address.Street2" : "312000",
  "client.Locations.0.Address.City" : "1",
  "client.Locations.0.Address.Region1" : "Global Loss of Rent All Risks Section",
  "client.Locations.0.Address.Region2" : "0",
  "client.Locations.0.Address.ZipCode" : "2",
  "client.Locations.0.RenewalDate" : "Item Details",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "3",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Loss of Rent",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "375000",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "2",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Item Details"
  }, {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "RA",
  "inspections.0.Mailing.Country" : "PL",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP29238776",
  "inspections.0.Mailing.Street1" : "C018781222",
  "inspections.0.PolicyHolder.CompanyName" : "MERCANTILE GROUP OF COMPANIES",
  "inspections.0.Agent.AgentCode" : "7  8  7A & 8A QUEENS PARADE",
  "inspections.0.Agent.AgentType" : "SEABURN",
  "inspections.0.Agent.AgencyName" : "SUNDERLAND",
  "inspections.0.Agent.AgencyCode" : "SR6 8DA",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "91115",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "20756",
  "inspections.0.CurrencyISO" : "Howden Insurance Brokers Ltd",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20240120",
  "inspections.0.GenericFields.0.GenericFields" : "123123.33",
  "divisionLookupID" : "678099",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20220302",
  "client.Name" : "Loss of Rent All Risks Section",
  "client.Address.Country" : "4500",
  "client.Agent.AgencyCode" : "13500",
  "client.Agent.AgencyName" : "20220302",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "103653",
  "client.Agent.Address.Street1" : "39247.2",
  "client.Agent.Address.Street2" : "20211127",
  "client.Agent.Address.City" : "Property Damage All Risks Section",
  "client.Agent.Address.Region1" : "80640",
  "client.Agent.Address.Region2" : "28360",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Property Owners Liability Section",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Third Party Prop",
  "client.Locations.0.Address.Street2" : "500",
  "client.Locations.0.Address.City" : "2",
  "client.Locations.0.Address.Region1" : "Wages/Turnover Details",
  "client.Locations.0.Address.Region2" : "0",
  "client.Locations.0.Address.ZipCode" : "1",
  "client.Locations.0.RenewalDate" : "Location Property Damage All Risks Section",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "2",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Item Details",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "0",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "3",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Buildings occupied as Takeaways and     Tyneside f"}, {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "SS",
  "inspections.0.Mailing.Country" : "RR",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP29238776",
  "inspections.0.Mailing.Street1" : "C018781222",
  "inspections.0.PolicyHolder.CompanyName" : "MERCANTILE GROUP OF COMPANIES",
  "inspections.0.Agent.AgentCode" : "4 NEVILLE ROAD",
  "inspections.0.Agent.AgentType" : "PALLION",
  "inspections.0.Agent.AgencyName" : "SUNDERLAND",
  "inspections.0.Agent.AgencyCode" : "SR4 6QT",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "91115",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "20756",
  "inspections.0.CurrencyISO" : "Howden Insurance Brokers Ltd",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20240120",
  "divisionLookupID" : "145512",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20220302",
  "client.Name" : "Loss of Rent All Risks Section",
  "client.Address.Country" : "4500",
  "client.Agent.AgencyCode" : "13500",
  "client.Agent.AgencyName" : "20220302",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "103653",
  "client.Agent.Address.Street1" : "39247.2",
  "client.Agent.Address.Street2" : "20211127",
  "client.Agent.Address.City" : "Property Damage All Risks Section",
  "client.Agent.Address.Region1" : "80640",
  "client.Agent.Address.Region2" : "28360",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Property Owners Liability Section",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Third Party Prop",
  "client.Locations.0.Address.Street2" : "500",
  "client.Locations.0.Address.City" : "2",
  "client.Locations.0.Address.Region1" : "Wages/Turnover Details",
  "client.Locations.0.Address.Region2" : "0",
  "client.Locations.0.Address.ZipCode" : "1",
  "client.Locations.0.RenewalDate" : "Location Property Damage All Risks Section",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "2",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Item Details",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "0",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "3",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Buildings occupied as Barber"
} ]




/////////////////////////////////////////
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
@SuppressWarnings("unused")
public class Underwriter {
    @JsonProperty("Company")
    private String company;
    @JsonProperty("Email")
    private String email;
    @JsonProperty("FirstName")
    private String firstName;
    @JsonProperty("LastName")
    private String lastName;
    @JsonProperty("PhoneNumber")
    private String phoneNumber;
    @JsonProperty("UnderwriterCode")
    private String underwriterCode;
}

..
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
..
import java.util.ArrayList;
import java.util.Date;

@SuppressWarnings("unused")
public class Location {
    @JsonProperty("LookupID")
    private String lookupID;
    @JsonProperty("Name")
    private String name;
    @JsonProperty("PolicyNumber")
    private String policyNumber;
    @JsonProperty("PolicyEffectiveDate")
    private Date policyEffectiveDate;
    @JsonProperty("PolicyExpirationDate")
    private Date policyExpirationDate;
    @JsonProperty("PolicyRenewalDate")
    private Date policyRenewalDate;
    @JsonProperty("Address")
    private Address address;
    @JsonProperty("OriginalEffectiveDate")
    private Date originalEffectiveDate;
    @JsonProperty("EffectiveDate")
    private Date effectiveDate;
    @JsonProperty("ExpirationDate")
    private Date expirationDate;
    @JsonProperty("RenewalDate")
    private Date renewalDate;
    @JsonProperty("LastInspectedDate")
    private Date lastInspectedDate;
    @JsonProperty("genericFields")
    private ArrayList<GenericField> genericFields;
    @JsonProperty("Coverages")
    private ArrayList<Coverage> coverages;
    @JsonProperty("Contact")
    private Contact contact;
}

..
package uk.co.allianz.rap.lc.model.request.importclient;

import lombok.Data;

@SuppressWarnings("unused")
@Data
public class ImportClientRequest {
    private String divisionLookupID;
    private Client client;
}

..
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;

@SuppressWarnings("unused")
public class GenericField2 {
    @JsonProperty("Number")
    private String number;
    @JsonProperty("Key")
    private String key;
    @JsonProperty("GenericFieldValueType")
    private int genericFieldValueType;
    @JsonProperty("Text")
    private String text;
}

..
package uk.co.allianz.rap.lc.model.request.importclient;

import lombok.Data;


@Data
public class GenericField {
    private String key;
    private String text;
    private int genericFieldValueType;
}

..
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.ArrayList;
@SuppressWarnings("unused")
public class Coverage {
    @JsonProperty("CoverageTypeLookup")
    private String coverageTypeLookup;
    @JsonProperty("GenericFields")
    private ArrayList<GenericField2> genericFields;
}


..
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
@SuppressWarnings("unused")
public class Contact {
    @JsonProperty("CellPhone")
    private String cellPhone;
    @JsonProperty("CompanyName")
    private String companyName;
    @JsonProperty("Email")
    private String email;
    @JsonProperty("FirstName")
    private String firstName;
    @JsonProperty("HomePhone")
    private String homePhone;
    @JsonProperty("LastName")
    private String lastName;
    @JsonProperty("Occupation")
    private String occupation;
    @JsonProperty("UseCompanyName")
    private boolean useCompanyName;
    @JsonProperty("WorkPhone")
    private String workPhone;
    @JsonProperty("Location")
    private String location;
}

..
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.ArrayList;
@SuppressWarnings("unused")
public class Client {
    @JsonProperty("LookupID")
    private String lookupID;
    @JsonProperty("ContactFirstName")
    private String contactFirstName;
    @JsonProperty("ContactLastName")
    private String contactLastName;
    @JsonProperty("PolicyNumber")
    private String policyNumber;
    @JsonProperty("Name")
    private String name;
    @JsonProperty("Phone")
    private String phone;
    @JsonProperty("Email")
    private String email;
    @JsonProperty("Address")
    private Address address;
    @JsonProperty("Agent")
    private Agent agent;
    @JsonProperty("Underwriter")
    private Underwriter underwriter;
    @JsonProperty("Locations")
    private ArrayList<Location> locations;
}

...
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;

@SuppressWarnings("unused")
public class Agent {
    @JsonProperty("AgencyCode")
    private String agencyCode;
    @JsonProperty("AgencyName")
    private String agencyName;
    @JsonProperty("AgentCode")
    private String agentCode;
    @JsonProperty("AgentName")
    private String agentName;
    @JsonProperty("Email")
    private String email;
    @JsonProperty("FaxNumber")
    private String faxNumber;
    @JsonProperty("PhoneNumber")
    private String phoneNumber;
    @JsonProperty("Address")
    private Address address;
    @JsonProperty("AgentType")
    private String agentType;
}

...
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;

@SuppressWarnings("unused")
public class Address {
    @JsonProperty("Country")
    private String country;
    @JsonProperty("Street1")
    private String street1;
    @JsonProperty("Street2")
    private String street2;
    @JsonProperty("City")
    private String city;
    @JsonProperty("Region1")
    private String region1;
    @JsonProperty("Region2")
    private String region2;
    @JsonProperty("Region3")
    private String region3;
    @JsonProperty("Region4")
    private String region4;
    @JsonProperty("ZipCode")
    private String zipCode;
}





[ {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "BS",
  "inspections.0.Mailing.Country" : "RR",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP22677819",
  "inspections.0.Mailing.Street1" : "C012682006",
  "inspections.0.PolicyHolder.CompanyName" : "tBh mMgw uouC qwpASux",
  "inspections.0.Agent.AgentCode" : "100 pBlyGJMnGFiyw",
  "inspections.0.Agent.AgentType" : "qCqvND",
  "inspections.0.Agent.AgencyName" : "qwdewq",
  "inspections.0.Agent.AgencyCode" : "SW1X 7LJ",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "94431",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "13832",
  "inspections.0.CurrencyISO" : "Lockton Companies LLP",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20231231",
  "inspections.0.GenericFields.0.GenericFields" : "872170",
  "divisionLookupID" : "1391199069",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20220128",
  "client.Name" : "Property Damage All Risks Section",
  "client.Address.Country" : "13",
  "client.Agent.AgencyCode" : "12.64",
  "client.Agent.AgencyName" : "20210101",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "6656",
  "client.Agent.Address.Street1" : "1149.6",
  "client.Agent.Address.Street2" : "20190902",
  "client.Agent.Address.City" : "Property Damage All Risks Section",
  "client.Agent.Address.Region1" : "3379",
  "client.Agent.Address.Region2" : "3378.13",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Terrorism - Property Damage",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Contents",
  "client.Locations.0.Address.Street2" : "132531529",
  "client.Locations.0.Address.City" : "3",
  "client.Locations.0.Address.Region1" : "Buildings",
  "client.Locations.0.Address.Region2" : "575700000",
  "client.Locations.0.Address.ZipCode" : "1",
  "client.Locations.0.RenewalDate" : "Global Terrorism - Business Interruption",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "2",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Item Details",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "0",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "3",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Bus. Interrupt.",
  "client.Locations.0.Coverages.0..GenericFields" : "7500000"
}, {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "CS",
  "inspections.0.Mailing.Country" : "PT",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP25496107",
  "inspections.0.Mailing.Street1" : "C006729450",
  "inspections.0.PolicyHolder.CompanyName" : "uvrwMyR mCwwK xsuNHsyE qHg & uvrwMyR mCwwKS qHg y/o uvrwMyR",
  "inspections.0.Agent.AgentCode" : "psqKHDAFDK lsJilwH GJBeHw",
  "inspections.0.Agent.AgentType" : "qCqvND",
  "inspections.0.Agent.AgencyName" : "dasas",
  "inspections.0.Agent.AgencyCode" : "W2 4BH",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS & HOTELIERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "94431",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "13832",
  "inspections.0.CurrencyISO" : "Lockton Companies LLP",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20220101",
  "inspections.0.GenericFields.0.GenericFields" : "3720",
  "divisionLookupID" : "1274250",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20200713",
  "client.Name" : "Property Damage All Risks Section",
  "client.Address.Country" : "0",
  "client.Agent.AgencyCode" : "0",
  "client.Agent.AgencyName" : "20200601",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "3335",
  "client.Agent.Address.Street1" : "390",
  "client.Agent.Address.Street2" : "12334",
  "client.Agent.Address.City" : "ABC",
  "client.Agent.Address.Region1" : "0",
  "client.Agent.Address.Region2" : "0",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Property Damage All Risks Section",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Contents of Flats and Private dwellings as advised",
  "client.Locations.0.Address.Street2" : "312000",
  "client.Locations.0.Address.City" : "1",
  "client.Locations.0.Address.Region1" : "Global Loss of Rent All Risks Section",
  "client.Locations.0.Address.Region2" : "0",
  "client.Locations.0.Address.ZipCode" : "2",
  "client.Locations.0.RenewalDate" : "Item Details",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "3",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Loss of Rent",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "375000",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "2",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Item Details",
  "client.Locations.0.Coverages.0..GenericFields" : "0"
}, {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "RA",
  "inspections.0.Mailing.Country" : "PL",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP29238776",
  "inspections.0.Mailing.Street1" : "C018781222",
  "inspections.0.PolicyHolder.CompanyName" : "MERCANTILE GROUP OF COMPANIES",
  "inspections.0.Agent.AgentCode" : "7  8  7A & 8A QUEENS PARADE",
  "inspections.0.Agent.AgentType" : "SEABURN",
  "inspections.0.Agent.AgencyName" : "SUNDERLAND",
  "inspections.0.Agent.AgencyCode" : "SR6 8DA",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "91115",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "20756",
  "inspections.0.CurrencyISO" : "Howden Insurance Brokers Ltd",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20240120",
  "inspections.0.GenericFields.0.GenericFields" : "123123.33",
  "divisionLookupID" : "678099",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20220302",
  "client.Name" : "Loss of Rent All Risks Section",
  "client.Address.Country" : "4500",
  "client.Agent.AgencyCode" : "13500",
  "client.Agent.AgencyName" : "20220302",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "103653",
  "client.Agent.Address.Street1" : "39247.2",
  "client.Agent.Address.Street2" : "20211127",
  "client.Agent.Address.City" : "Property Damage All Risks Section",
  "client.Agent.Address.Region1" : "80640",
  "client.Agent.Address.Region2" : "28360",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Property Owners Liability Section",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Third Party Prop",
  "client.Locations.0.Address.Street2" : "500",
  "client.Locations.0.Address.City" : "2",
  "client.Locations.0.Address.Region1" : "Wages/Turnover Details",
  "client.Locations.0.Address.Region2" : "0",
  "client.Locations.0.Address.ZipCode" : "1",
  "client.Locations.0.RenewalDate" : "Location Property Damage All Risks Section",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "2",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Item Details",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "0",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "3",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Buildings occupied as Takeaways and     Tyneside f",
  "client.Locations.0.Coverages.0..GenericFields" : "677599"
}, {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "SS",
  "inspections.0.Mailing.Country" : "RR",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP29238776",
  "inspections.0.Mailing.Street1" : "C018781222",
  "inspections.0.PolicyHolder.CompanyName" : "MERCANTILE GROUP OF COMPANIES",
  "inspections.0.Agent.AgentCode" : "4 NEVILLE ROAD",
  "inspections.0.Agent.AgentType" : "PALLION",
  "inspections.0.Agent.AgencyName" : "SUNDERLAND",
  "inspections.0.Agent.AgencyCode" : "SR4 6QT",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "91115",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "20756",
  "inspections.0.CurrencyISO" : "Howden Insurance Brokers Ltd",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20240120",
  "inspections.0.GenericFields.0.GenericFields" : "123123.33",
  "divisionLookupID" : "145512",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20220302",
  "client.Name" : "Loss of Rent All Risks Section",
  "client.Address.Country" : "4500",
  "client.Agent.AgencyCode" : "13500",
  "client.Agent.AgencyName" : "20220302",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "103653",
  "client.Agent.Address.Street1" : "39247.2",
  "client.Agent.Address.Street2" : "20211127",
  "client.Agent.Address.City" : "Property Damage All Risks Section",
  "client.Agent.Address.Region1" : "80640",
  "client.Agent.Address.Region2" : "28360",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Property Owners Liability Section",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Third Party Prop",
  "client.Locations.0.Address.Street2" : "500",
  "client.Locations.0.Address.City" : "2",
  "client.Locations.0.Address.Region1" : "Wages/Turnover Details",
  "client.Locations.0.Address.Region2" : "0",
  "client.Locations.0.Address.ZipCode" : "1",
  "client.Locations.0.RenewalDate" : "Location Property Damage All Risks Section",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "2",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Item Details",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "0",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "3",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Buildings occupied as Barber",
  "client.Locations.0.Coverages.0..GenericFields" : "145012"
} ]


/////////////

{
    "divisionLookupID": "AZ_UK",
    "client": {
        "LookupID": "27251",
        "PolicyNumber": "SZ26218858",
        "Name": "alice test new edit EUROSTAMPA UK LIMITED AND UNICORN GRAPHICS LTD AND GILMOUR & DEAN LTD",
        "Address": {
            "Country": "GB" /*Compulsory*/
        },
        "Agent": {
            "AgencyCode": "96686",
            "AgencyName": "D2 Corporate Solutions Ltd",
            "AgentCode": "19747",
            "Address": {/*Compulsory*/},
            "AgentType": "Broker"
        },
        "Locations": [
            {
                "LookupID": "38823",
                "PolicyNumber": "SZ26218858",
                "Address": {
                    "Country": "GB",
                    "Street1": "test 24 CLYDEHOLM ROAD",
                    "Street2": "",
                    "City": "GLASGOW",
                    "Region1": "",
                    "ZipCode": "G14 0QQ"
                },
                "RenewalDate": "2023-03-28T15:08:58.8820749+01:00",
                "Coverages": [
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "CoverageReference":"Coverage 1",
                        "GenericFields": [
                            {
                                "Number": "8124000",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "20713528",
                                "Key": "02. PD Content",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "3500000",
                                "Key": "03. Stock & Supply",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "0",
                                "Key": "04. PD Other",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Text": "",
                                "Key": "05. PD Other Description",
                                "GenericFieldValueType": 0
                            },
                            {    /*This field is the sum of 1,2,3,4*/
                                "Number": "32337528",
                                "Key": "06. TIV PD",
                                "GenericFieldValueType": 1
                            },
                            {    /*Sum of all values in Global Business Section*/
                                "Number": "29000000",
                                "Key": "07. TIV BI",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "12",
                                "Key": "08. BI Base Period (Months)",
                                "GenericFieldValueType": 1
                            },
                            {    /*This field is the sum of 6,7*/
                                "Number": "61337528",
                                "Key": "09. TIV (PD + BI )",
                                "GenericFieldValueType": 1
                            }
                        ]
                    },
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "CoverageReference":"Coverage 2",
                        "GenericFields": [
                            {
                                "Number": "18124000",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "120713528",
                                "Key": "02. PD Content",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "13500000",
                                "Key": "03. Stock & Supply",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "0",
                                "Key": "04. PD Other",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Text": "",
                                "Key": "05. PD Other Description",
                                "GenericFieldValueType": 0
                            },
                            {    /*This field is the sum of 1,2,3,4*/
                                "Number": "132337528",
                                "Key": "06. TIV PD",
                                "GenericFieldValueType": 1
                            },
                            {    /*Sum of all values in Global Business Section*/
                                "Number": "129000000",
                                "Key": "07. TIV BI",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "12",
                                "Key": "08. BI Base Period (Months)",
                                "GenericFieldValueType": 1
                            },
                            {    /*This field is the sum of 6,7*/
                                "Number": "161337528",
                                "Key": "09. TIV (PD + BI )",
                                "GenericFieldValueType": 1
                            }
                        ]
                    }
                ]
            }
        ]
    }
}
