          log.info("Client and Location are not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            lossControlDao.insertLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
             // Lookup ID Response
            lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber(), locationsResponse.get(0).getLocationLookupID());
      



















import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testImportClient_LcLocationIdExists() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"locations\": [{ \"lookupID\": \"123\", \"policyNumber\": \"456\" }] }}";
        String correlationId = "12345";
        String combineLocationID = "123+456";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up your ImportClientResponse with appropriate data

        // Mocking behavior for the scenario where LC360 location ID exists
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByLocationId(anyString())).thenReturn(Collections.singletonMap("1", "1234"));
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(Collections.singletonMap("1", "lc360LocationId"));
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions or verifications based on expected behavior
        assertNotNull(response);
        // Add more assertions based on your expected behavior
    }

    @Test
    public void testImportClient_LcLocationIdNotExists() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"locations\": [{ \"lookupID\": \"123\", \"policyNumber\": \"456\" }] }}";
        String correlationId = "12345";
        String combineLocationID = "123+456";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up your ImportClientResponse with appropriate data

        // Mocking behavior for the scenario where LC360 location ID doesn't exist
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByLocationId(anyString())).thenReturn(Collections.singletonMap("1", "1234"));
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(null);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions or verifications based on expected behavior
        assertNotNull(response);
        // Add more assertions based on your expected behavior
    }

    @Test
    public void testImportClient_LocationNotPresent() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"locations\": [{ \"lookupID\": \"123\", \"policyNumber\": \"456\" }] }}";
        String correlationId = "12345";
        String combineLocationID = "123+456";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up your ImportClientResponse with appropriate data

        // Mocking behavior for the scenario where location is not present
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByLocationId(anyString())).thenReturn(null);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(Collections.singletonMap("1", "lc360LocationId"));

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions or verifications based on expected behavior
        assertNotNull(response);
        // Add more assertions based on your expected behavior
    }

    // Add more test cases to cover different scenarios

    // ... more test methods ...

    // End of the class
}




import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testImportClient_LocationExists() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"locations\": [{ \"lookupID\": \"123\", \"policyNumber\": \"456\" }] }}";
        String correlationId = "12345";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data
        Location location = new Location();
        location.setLookupID("123");
        location.setPolicyNumber("456");
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        importClientRequest.setClient(new Client());
        importClientRequest.getClient().setLocations(locations);

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up your ImportClientResponse with appropriate data

        // Mocking behavior for the existing location scenario
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByLocationId(anyString())).thenReturn(new HashMap<>());
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(new HashMap<>());
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions or verifications based on the expected behavior
        assertNotNull(response);
        // Verify other method calls, assertions, etc.
    }

    @Test
    public void testImportClient_NewLocation() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"locations\": [{ \"lookupID\": \"123\", \"policyNumber\": \"456\" }] }}";
        String correlationId = "12345";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data
        Location location = new Location();
        location.setLookupID("123");
        location.setPolicyNumber("456");
        ArrayList<Location> locations = new ArrayList<>();
        locations.add(location);
        importClientRequest.setClient(new Client());
        importClientRequest.getClient().setLocations(locations);

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up your ImportClientResponse with appropriate data

        // Mocking behavior for the new location scenario
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlDao.findByLocationId(anyString())).thenReturn(null);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);
        when(lossControlDao.insertLocationId(anyString())).thenReturn(new HashMap<>());
        when(lossControlDao.updateLcLocationId(anyString(), anyString())).thenReturn(new HashMap<>());

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions or verifications based on the expected behavior
        assertNotNull(response);
        // Verify other method calls, assertions, etc.
    }

    // Add more test cases to cover other scenarios

    // ... more test methods ...

    // End of the class
}





















package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String location_LookupID = locations.get(0).getLookupID();


//        Policy number
        String policyNumber = locations.get(0).getPolicyNumber();

        //combination of Location ID + Policy number
        String combineLocationID = location_LookupID + "+" + policyNumber;

        Map<String, Object> result = lossControlDao.findByLocationId(combineLocationID);
        if (result != null) {

            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
            if (lcLocationId != null) {
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                locations.get(0).setLookupID(lc360LocationId);


                //If LC-360 Location Id exists use that id to the request to LC360
                String updatedJson = objectMapper.writeValueAsString(importClientRequest);
                System.out.println(updatedJson);


                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Location is not present");
            lossControlDao.insertLocationId(combineLocationID);
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();

//        Lookup ID Response
            String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();

            lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import static org.mockito.Mockito.*;

public class ImportClientServiceImpTest {

    private TokenCache tokenCache;
    private LossControlServiceImpl lossControlServiceImpl;
    private ObjectMapper objectMapper;
    private ImportClientServiceImp importClientService;

    @BeforeEach
    public void setUp() {
        tokenCache = mock(TokenCache.class);
        lossControlServiceImpl = mock(LossControlServiceImpl.class);
        objectMapper = mock(ObjectMapper.class);
        importClientService = new ImportClientServiceImp(tokenCache, lossControlServiceImpl, objectMapper);
    }

    @Test
    public void testImportClient_SuccessfulImport() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { ... }}";
        String correlationId = "12345";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        ImportClientResponse importClientResponse = new ImportClientResponse();

        // Mock behavior
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);
        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn("testToken");

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions or verifications based on expected behavior
        // For example:
        verify(objectMapper, times(1)).readValue(json, ImportClientRequest.class);
        verify(lossControlServiceImpl, times(1)).clientPost(importClientRequest, "testToken");
        // Add more assertions based on your expected behavior
    }

    @Test
    public void testImportClient_JsonProcessingException() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { ... }}";
        String correlationId = "12345";

        // Mocking behavior to simulate JsonProcessingException
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class)))
                .thenThrow(new JsonProcessingException("Test JsonProcessingException") {});

        // Call the actual method and handle the exception
        try {
            ImportClientResponse response = importClientService.importClient(json, correlationId);
            // Add assertions or verifications if needed
        } catch (JsonProcessingException e) {
            // Handle the exception and perform necessary assertions
        }
    }

    // Add more test cases to cover different scenarios

    // ... more test methods ...

    // End of the class
}




import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import static org.junit.Assert.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@Slf4j
public class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testImportClient_SuccessfulImport() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"name\": \"John Doe\" }}";
        String correlationId = "12345";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up your ImportClientResponse with appropriate data

        // Mock behavior
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(importClientResponse);

        // Call the actual method
        ImportClientResponse response = importClientService.importClient(json, correlationId);

        // Assertions
        assertNotNull(response);
        // Additional assertions based on your expected behavior
    }

    @Test(expected = CustomException.class)
    public void testImportClient_JsonProcessingException() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"name\": \"John Doe\" }}";
        String correlationId = "12345";

        // Mock behavior to throw a JsonProcessingException
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenThrow(new JsonProcessingException("Test Exception") {});

        // Call the actual method and expect a CustomException
        importClientService.importClient(json, correlationId);
    }

    @Test(expected = CustomException.class)
    public void testImportClient_CustomExceptionFromService() throws CustomException, JsonProcessingException {
        // Set up test data
        String json = "{\"client\": { \"name\": \"John Doe\" }}";
        String correlationId = "12345";

        ImportClientRequest importClientRequest = new ImportClientRequest();
        // Set up your ImportClientRequest with appropriate data

        // Mock behavior
        when(objectMapper.readValue(anyString(), eq(ImportClientRequest.class))).thenReturn(importClientRequest);
        when(lossControlServiceImpl.clientPost(any(), any())).thenThrow(new CustomException("Test Exception"));

        // Call the actual method and expect a CustomException
        importClientService.importClient(json, correlationId);
    }

    // Add more test cases to cover different scenarios

    // ... existing test methods ...

    // End of the class
}






///////////
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        objectMapper.writeValueAsString(importClientRequest);
        //Implement a  token caching logic within loss-control-service.
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        log.info("Received JSON");
        log.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}

































package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        objectMapper.writeValueAsString(importClientRequest);
        //Implement a  token caching logic within loss-control-service.
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        log.info("Received JSON");
        log.info("importClientResponse Successfully Received");
        return importClientResponse;
    }








///////////////////////////////////////////////////////////////
package uk.co.allianz.rap.lc.dao;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Map;

@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;


    @Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}



//////

package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String location_LookupID = locations.get(0).getLookupID();


//        Policy number
        String policyNumber = locations.get(0).getPolicyNumber();

        //combination of Location ID + Policy number
        String combineLocationID = location_LookupID + "+" + policyNumber;

        Map<String, Object> result = lossControlDao.findByLocationId(combineLocationID);
        if (result != null) {

            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
            if (lcLocationId != null) {
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                locations.get(0).setLookupID(lc360LocationId);


                //If LC-360 Location Id exists use that id to the request to LC360
                String updatedJson = objectMapper.writeValueAsString(importClientRequest);
                System.out.println(updatedJson);


                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Location is not present");
            lossControlDao.insertLocationId(combineLocationID);
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();

//        Lookup ID Response
            String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();

            lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}




////////////////////////////package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        //finding client id in DB exist or not
        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {
            //finding LC360 client id in DB exist or not
            Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            //finding LC360 location id in DB exist or not(combined location lookup ID and policy number)
            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            if (lcClientId != null) {
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                //set client id and location id in pojo
                importClientRequest.getClient().setLookupID(lc360ClientId);
                locations.get(0).setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Client and Location are not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            lossControlDao.insertLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
             // Lookup ID Response
            lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber(), locationsResponse.get(0).getLocationLookupID());
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@Repository
@Qualifier("datasource")
public class MainDatabaseRepository implements MyRepository {
    // Implementation for the main data source
}

@Repository
@Qualifier("test-datasource")
public class TestDatabaseRepository implements MyRepository {
    // Implementation for the test data source
}




test-datasource: # This is a custom name for your test data source
    url: jdbc:postgresql://localhost:5432/testdb
    username: testuser
    password: testpassword
// above //
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/testdb  # Replace with your PostgreSQL URL
    username: testuser
    password: testpassword

# Other configuration properties...

///
spring:
  h2:
    console:
      enabled: true  # Enable H2 console for debugging (optional)
    datasource:
      url: jdbc:h2:mem:testdb  # In-memory database URL
      driver-class-name: org.h2.Driver
      username: sa
      password:

# Other configuration properties...


//
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.jdbc.JdbcTestUtils;
import uk.co.allianz.rap.lc.dao.LossControlDao;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@Sql(scripts = { "classpath:schema.sql" }) // Use your schema creation script here
class LossControlDaoImplLocationTests {

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    void testInsertLocationId() {
        String locationId = "location123";
        lossControlDao.insertLocationId(locationId);

        int rowCount = JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "location_lookup", "location_id = '" + locationId + "'");
        assertEquals(1, rowCount);
    }

    @Test
    void testUpdateLcLocationId() {
        String locationId = "location123";
        String lc360LocationId = "lc360location123";

        // Insert a location row first
        jdbcTemplate.update("INSERT INTO location_lookup (location_id) VALUES (?)", locationId);

        lossControlDao.updateLcLocationId(locationId, lc360LocationId);

        String fetchedLc360LocationId = jdbcTemplate.queryForObject(
            "SELECT lc360_location_id FROM location_lookup WHERE location_id = ?", String.class, locationId
        );

        assertEquals(lc360LocationId, fetchedLc360LocationId);
    }
}

///////
CREATE TABLE client_lookup (
    client_id VARCHAR(255) PRIMARY KEY,
    lc360_client_id VARCHAR(255)
);

CREATE TABLE location_lookup (
    location_id VARCHAR(255) PRIMARY KEY,
    lc360_location_id VARCHAR(255)
);

-- Add more tables and columns as needed

//////////////
-- src/test/resources/schema.sql
CREATE TABLE location_lookup (
    id SERIAL PRIMARY KEY,
    location_id VARCHAR(255)
);

-- Add more schema definitions as needed


///
@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }
    }
////
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.jdbc.Sql;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

@SpringBootTest
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class LossControlDaoImplLocationTest {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private LossControlDao lossControlDao;

    @Test
    @Sql("/location_lookup_cleanup.sql") // SQL script to clean up test data before running the test
    public void testInsertLocationId() {
        String locationId = "test_location_id";
        
        lossControlDao.insertLocationId(locationId);

        Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM location_lookup WHERE location_id = ?", locationId);

        assertNotNull(result);
        assertEquals(locationId, result.get("location_id"));
    }

    @Test
    @Sql("/location_lookup_cleanup.sql") // SQL script to clean up test data before running the test
    public void testUpdateLcLocationId() {
        String locationId = "test_location_id";
        String lc360LocationId = "test_lc360_location_id";

        // Insert a test location before updating
        jdbcTemplate.update("INSERT INTO location_lookup(location_id) VALUES (?)", locationId);

        lossControlDao.updateLcLocationId(locationId, lc360LocationId);

        Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM location_lookup WHERE location_id = ?", locationId);

        assertNotNull(result);
        assertEquals(lc360LocationId, result.get("lc360_location_id"));
    }
}


//
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.jdbc.JdbcTestUtils;
import uk.co.allianz.rap.lc.dao.LossControlDao;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@Sql(scripts = { "classpath:schema.sql" }) // Use your schema creation script here
class LossControlDaoImplLocationTests {

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    void testInsertLocationId() {
        String locationId = "location123";
        lossControlDao.insertLocationId(locationId);

        int rowCount = JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "location_lookup", "location_id = '" + locationId + "'");
        assertEquals(1, rowCount);
    }

    @Test
    void testUpdateLcLocationId() {
        String locationId = "location123";
        String lc360LocationId = "lc360location123";

        // Insert a location row first
        jdbcTemplate.update("INSERT INTO location_lookup (location_id) VALUES (?)", locationId);

        lossControlDao.updateLcLocationId(locationId, lc360LocationId);

        String fetchedLc360LocationId = jdbcTemplate.queryForObject(
            "SELECT lc360_location_id FROM location_lookup WHERE location_id = ?", String.class, locationId
        );

        assertEquals(lc360LocationId, fetchedLc360LocationId);
    }
}

////
@Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
//
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ActiveProfiles;

import javax.sql.DataSource;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@ActiveProfiles("test")
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class ImportClientServiceTest {

    @Autowired
    private ImportClientService importClientService;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private DataSource dataSource;

    @Test
    public void testImportClient() throws Exception {
        String json = "your_test_json_here";
        String correlationId = "your_test_correlation_id_here";

        ImportClientResponse response = importClientService.importClient(json, correlationId);

        assertNotNull(response);
        assertNotNull(response.getResult());
        assertNotNull(response.getResult().getClientLookupID());
        // Add more assertions as needed
    }

    // Add more test cases for edge cases and scenarios
}

@SpringBootTest
@ActiveProfiles("test")
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class LossControlDaoTest {

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private DataSource dataSource;

    @Test
    public void testInsertClientId() {
        String clientId = "test_client_id";
        lossControlDao.insertClientId(clientId);

        Integer count = jdbcTemplate.queryForObject("SELECT COUNT(*) FROM client_lookup", Integer.class);
        assertEquals(1, count);
    }

    // Add more test cases for other methods in LossControlDaoImpl
}

//
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.jdbc.JdbcTestUtils;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class ImportClientServiceTest {

    @Autowired
    private ImportClientService importClientService;

    @Autowired
    private LossControlDao lossControlDao;

    @Test
    public void testImportClient() {
        String json = "{\"client\": {\"lookupID\": \"123\", ...}, ...}"; // Sample JSON
        String correlationId = "correlation123";

        // Clear the database before running the test
        JdbcTestUtils.deleteFromTables(lossControlDao.getJdbcTemplate(), "client_lookup", "location_lookup");

        try {
            ImportClientResponse response = importClientService.importClient(json, correlationId);
            assertNotNull(response);
            assertNotNull(response.getResult());
            assertNotNull(response.getResult().getClientLookupID());

            // Check if the client was inserted into the database
            assertTrue(JdbcTestUtils.countRowsInTableWhere(lossControlDao.getJdbcTemplate(), "client_lookup", "client_id = '123'") > 0);

            // Check if the location was inserted into the database
            ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
            Location location = importClientRequest.getClient().getLocations().get(0);
            assertTrue(JdbcTestUtils.countRowsInTableWhere(lossControlDao.getJdbcTemplate(), "location_lookup", "location_id = '" + location.getLookupID() + "+" + location.getPolicyNumber() + "'") > 0);

            // Test existing client scenario
            response = importClientService.importClient(json, correlationId);
            assertNotNull(response);
            assertNotNull(response.getResult());
            assertNotNull(response.getResult().getClientLookupID());
        } catch (Exception e) {
            fail("Exception occurred: " + e.getMessage());
        }
    }
}

//
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.jdbc.JdbcTestUtils;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
class ImportClientServiceImpTest {

    @Autowired
    private ImportClientService importClientService;

    @Test
    void testImportClient() throws Exception {
        String json = "{\"client\": { ... }}"; // Sample JSON data
        String correlationId = "123456";

        ImportClientResponse response = importClientService.importClient(json, correlationId);

        assertNotNull(response);
        assertNotNull(response.getResult());
        assertNotNull(response.getResult().getClientLookupID());
        // Add more assertions as needed
    }
}

@SpringBootTest
class LossControlDaoImplTest {

    @Autowired
    private LossControlDao lossControlDao;

    @Test
    void testInsertAndFindClient() {
        String clientId = "client123";
        lossControlDao.insertClientId(clientId);
        Map<String, Object> result = lossControlDao.findByClientId(clientId);
        
        assertNotNull(result);
        assertEquals(clientId, result.get("client_id"));
    }

    @Test
    void testInsertAndUpdateClient() {
        String clientId = "client123";
        String lc360ClientId = "lc360client123";
        lossControlDao.insertClientId(clientId);
        lossControlDao.updateLcClientId(clientId, lc360ClientId);
        Map<String, Object> result = lossControlDao.findLc360ClientID(clientId);
        
        assertNotNull(result);
        assertEquals(lc360ClientId, result.get("lc360_client_id"));
    }

    @Test
    void testInsertAndFindLocation() {
        String locationId = "location123";
        lossControlDao.insertLocationId(locationId);
        Map<String, Object> result = lossControlDao.findByLocationId(locationId);
        
        assertNotNull(result);
        assertEquals(locationId, result.get("location_id"));
    }

    @Test
    void testInsertAndUpdateLocation() {
        String locationId = "location123";
        String lc360LocationId = "lc360location123";
        lossControlDao.insertLocationId(locationId);
        lossControlDao.updateLcLocationId(locationId, lc360LocationId);
        Map<String, Object> result = lossControlDao.findLc360LocationID(locationId);
        
        assertNotNull(result);
        assertEquals(lc360LocationId, result.get("lc360_location_id"));
    }
}

////above without mock include dao and service////
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        //finding client id in DB exist or not
        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {
            //finding LC360 client id in DB exist or not
            Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            //finding LC360 location id in DB exist or not(combined location lookup ID and policy number)
            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            if (lcClientId != null) {
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                //set client id and location id in pojo
                importClientRequest.getClient().setLookupID(lc360ClientId);
                locations.get(0).setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Client and Location are not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            lossControlDao.insertLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
             // Lookup ID Response
            lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber(), locationsResponse.get(0).getLocationLookupID());
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}



//
package uk.co.allianz.rap.lc.dao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Map;

@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    //client methods
    @Override
    public void insertClientId(String client_id) {
        String insert = "insert into client_lookup(client_id) values(?)";
        int update = this.jdbcTemplate.update(insert, client_id);
    }

    @Override
    public void updateLcClientId(String client_id, String lc360_client_id) {
        String update = "update client_lookup set lc360_client_id = ? where client_id = ?";
        this.jdbcTemplate.update(update, lc360_client_id, client_id);
    }

    @Override
    public Map<String, Object> findByClientId(String client_id) {
        String checkClientId = "select * from client_lookup where client_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360ClientID(String client_id) {
        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360ClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    // Locations methods
    @Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}




//
package uk.co.allianz.rap.lc.dao;

import java.util.Map;

public interface LossControlDao {

    //client
    Map<String, Object> findByClientId(String client_id);

    void updateLcClientId(String client_id, String lc360_client_id);

    void insertClientId(String client_id);

    Map<String, Object> findLc360ClientID(String client_id);


    //location
    Map<String, Object> findByLocationId(String location_id);

    void updateLcLocationId(String location_id, String lc360_location_id);

    void insertLocationId(String location_id);

    Map<String, Object> findLc360LocationID(String location_id);

}
////////////////////////////////////////////////////////////////Dao layer class above//////////////////////////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
import org.springframework.transaction.annotation.Transactional;
import uk.co.allianz.rap.lc.dao.LossControlDao;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;

@SpringBootTest
@SpringJUnitConfig
@AutoConfigureTestDatabase
@Transactional
public class LossControlDaoImplTest {

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @BeforeEach
    public void setUp() {
        // Create necessary tables or data for testing (if needed)
        // For simplicity, this example assumes the tables already exist
    }

    @Test
    public void testClientOperations() {
        // Insert a client
        lossControlDao.insertClientId("testClientId");
        Map<String, Object> insertedClient = lossControlDao.findByClientId("testClientId");
        assertEquals("testClientId", insertedClient.get("client_id"));

        // Update client LC360 ID
        lossControlDao.updateLcClientId("testClientId", "lc360TestClientId");
        Map<String, Object> updatedClient = lossControlDao.findLc360ClientID("testClientId");
        assertEquals("lc360TestClientId", updatedClient.get("lc360_client_id"));
    }

    @Test
    public void testLocationOperations() {
        // Insert a location
        lossControlDao.insertLocationId("testLocationId");
        Map<String, Object> insertedLocation = lossControlDao.findByLocationId("testLocationId");
        assertEquals("testLocationId", insertedLocation.get("location_id"));

        // Update location LC360 ID
        lossControlDao.updateLcLocationId("testLocationId", "lc360TestLocationId");
        Map<String, Object> updatedLocation = lossControlDao.findLc360LocationID("testLocationId");
        assertEquals("lc360TestLocationId", updatedLocation.get("lc360_location_id"));
    }

    @Test
    public void testNonExistentClientAndLocation() {
        // Attempt to find non-existent client and location
        Map<String, Object> nonExistentClient = lossControlDao.findByClientId("nonExistentClientId");
        assertNull(nonExistentClient);

        Map<String, Object> nonExistentLocation = lossControlDao.findByLocationId("nonExistentLocationId");
        assertNull(nonExistentLocation);
    }
}



//
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.jdbc.Sql;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@Sql(scripts = {"/schema.sql", "/data.sql"}) // Load initial data into the H2 database
public class LossControlDaoImplTest {

    @Autowired
    private LossControlDao lossControlDao;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @BeforeEach
    public void setUp() {
        // Clear data before each test
        jdbcTemplate.update("DELETE FROM client_lookup");
        jdbcTemplate.update("DELETE FROM location_lookup");
    }

    @Test
    public void testInsertClientId() {
        String clientId = "sampleClientId";
        lossControlDao.insertClientId(clientId);

        Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM client_lookup WHERE client_id = ?", clientId);
        assertNotNull(result);
    }

    @Test
    public void testUpdateLcClientId() {
        String clientId = "sampleClientId";
        String lc360ClientId = "sampleLc360ClientId";
        jdbcTemplate.update("INSERT INTO client_lookup(client_id) VALUES (?)", clientId);

        lossControlDao.updateLcClientId(clientId, lc360ClientId);

        Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM client_lookup WHERE client_id = ?", clientId);
        assertEquals(lc360ClientId, result.get("lc360_client_id"));
    }

    @Test
    public void testFindByClientId() {
        String clientId = "sampleClientId";
        jdbcTemplate.update("INSERT INTO client_lookup(client_id) VALUES (?)", clientId);

        Map<String, Object> result = lossControlDao.findByClientId(clientId);
        assertNotNull(result);
    }

    @Test
    public void testFindLc360ClientID() {
        String clientId = "sampleClientId";
        String lc360ClientId = "sampleLc360ClientId";
        jdbcTemplate.update("INSERT INTO client_lookup(client_id, lc360_client_id) VALUES (?, ?)", clientId, lc360ClientId);

        Map<String, Object> result = lossControlDao.findLc360ClientID(clientId);
        assertEquals(lc360ClientId, result.get("lc360_client_id"));
    }

    @Test
    public void testInsertLocationId() {
        String locationId = "sampleLocationId";
        lossControlDao.insertLocationId(locationId);

        Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM location_lookup WHERE location_id = ?", locationId);
        assertNotNull(result);
    }

    @Test
    public void testUpdateLcLocationId() {
        String locationId = "sampleLocationId";
        String lc360LocationId = "sampleLc360LocationId";
        jdbcTemplate.update("INSERT INTO location_lookup(location_id) VALUES (?)", locationId);

        lossControlDao.updateLcLocationId(locationId, lc360LocationId);

        Map<String, Object> result = jdbcTemplate.queryForMap("SELECT * FROM location_lookup WHERE location_id = ?", locationId);
        assertEquals(lc360LocationId, result.get("lc360_location_id"));
    }

    @Test
    public void testFindByLocationId() {
        String locationId = "sampleLocationId";
        jdbcTemplate.update("INSERT INTO location_lookup(location_id) VALUES (?)", locationId);

        Map<String, Object> result = lossControlDao.findByLocationId(locationId);
        assertNotNull(result);
    }

    @Test
    public void testFindLc360LocationID() {
        String locationId = "sampleLocationId";
        String lc360LocationId = "sampleLc360LocationId";
        jdbcTemplate.update("INSERT INTO location_lookup(location_id, lc360_location_id) VALUES (?, ?)", locationId, lc360LocationId);

        Map<String, Object> result = lossControlDao.findLc360LocationID(locationId);
        assertEquals(lc360LocationId, result.get("lc360_location_id"));
    }
}


/////Junit test cases above
package uk.co.allianz.rap.lc.dao;

import java.util.Map;

public interface LossControlDao {

    //client
    Map<String, Object> findByClientId(String client_id);

    void updateLcClientId(String client_id, String lc360_client_id);

    void insertClientId(String client_id);

    Map<String, Object> findLc360ClientID(String client_id);


    //location
    Map<String, Object> findByLocationId(String location_id);

    void updateLcLocationId(String location_id, String lc360_location_id);

    void insertLocationId(String location_id);

    Map<String, Object> findLc360LocationID(String location_id);

}

////
package uk.co.allianz.rap.lc.dao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Map;

@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    //client methods
    @Override
    public void insertClientId(String client_id) {
        String insert = "insert into client_lookup(client_id) values(?)";
        int update = this.jdbcTemplate.update(insert, client_id);
    }

    @Override
    public void updateLcClientId(String client_id, String lc360_client_id) {
        String update = "update client_lookup set lc360_client_id = ? where client_id = ?";
        this.jdbcTemplate.update(update, lc360_client_id, client_id);
    }

    @Override
    public Map<String, Object> findByClientId(String client_id) {
        String checkClientId = "select * from client_lookup where client_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360ClientID(String client_id) {
        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360ClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    // Locations methods
    @Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}

/////JUNIT for DAO layer/////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class TokenCacheTest {

    private TokenCache tokenCache;
    private JwtUtil jwtUtil;
    private CacheManager cacheManager;

    @BeforeEach
    public void setUp() {
        // Initialize the TokenCache instance
        tokenCache = new TokenCache();

        // Create a mock JwtUtil and CacheManager
        jwtUtil = mock(JwtUtil.class);
        cacheManager = mock(CacheManager.class);

        // Set the dependencies using reflection (for simplicity, don't use this in production code)
        try {
            tokenCache.getClass().getDeclaredField("jwtUtil").set(tokenCache, jwtUtil);
            tokenCache.getClass().getDeclaredField("cacheManager").set(tokenCache, cacheManager);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        // Arrange
        String correlationId = "sampleCorrelationId";
        String expectedToken = "sampleToken";

        // Mock behavior of JwtUtil to return a token
        when(jwtUtil.getAuthToken()).thenReturn(expectedToken);

        // Mock behavior of CacheManager and Cache
        Cache cache = mock(Cache.class);
        when(cacheManager.getCache("tokens")).thenReturn(cache);
        when(cache.get("tokens")).thenReturn(null); // Simulate cache miss

        // Act
        String retrievedToken = tokenCache.retrieveTokenFromCache(correlationId);

        // Assert
        assertEquals(expectedToken, retrievedToken);

        // Verify log statements
        // Ideally, you would use a logging framework that captures log output for testing
    }
}


///
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class TokenCacheTest {

    private TokenCache tokenCache;
    private JwtUtil jwtUtil;

    @BeforeEach
    public void setUp() {
        jwtUtil = new JwtUtil(); // You may need to initialize JwtUtil appropriately
        tokenCache = new TokenCache();
        tokenCache.jwtUtil = jwtUtil; // Inject the JwtUtil instance manually
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        // Arrange
        String correlationId = "123456";
        String expectedToken = "testToken";

        // Act
        String token = tokenCache.retrieveTokenFromCache(correlationId);

        // Assert
        assertEquals(expectedToken, token);
    }

    @Test
    public void testRetrieveTokenFromCacheWithDifferentCorrelationId() throws CustomException {
        // Arrange
        String correlationId1 = "123456";
        String correlationId2 = "789012";

        // Act
        String token1 = tokenCache.retrieveTokenFromCache(correlationId1);
        String token2 = tokenCache.retrieveTokenFromCache(correlationId2);

        // Assert
        assertEquals(token1, token2);
    }
}


///
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class TokenCacheTest {

    private TokenCache tokenCache;

    @BeforeEach
    public void setUp() {
        tokenCache = new TokenCache();
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        String correlationId = "testCorrelationId";

        String token = tokenCache.retrieveTokenFromCache(correlationId);

        assertTrue(token != null && !token.isEmpty(), "Token should not be null or empty");
    }

    @Test
    public void testRetrieveTokenFromCacheLogs() throws CustomException {
        String correlationId = "testCorrelationId";

        String token = tokenCache.retrieveTokenFromCache(correlationId);

        // Assuming log.info() statements output to console or log files, you can check these manually.
        assertEquals(token, tokenCache.getToken(), "Token should be fetched from the cache");
    }
}



/////////////////////////Not used MOCK/////////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class TokenCacheTest {

    private TokenCache tokenCache;
    private JwtUtil jwtUtil;
    private CacheManager cacheManager;

    @BeforeEach
    public void setUp() {
        // Initialize the TokenCache instance
        tokenCache = new TokenCache();

        // Create a mock JwtUtil and CacheManager
        jwtUtil = mock(JwtUtil.class);
        cacheManager = mock(CacheManager.class);

        // Set the dependencies using reflection (for simplicity, don't use this in production code)
        try {
            tokenCache.getClass().getDeclaredField("jwtUtil").set(tokenCache, jwtUtil);
            tokenCache.getClass().getDeclaredField("cacheManager").set(tokenCache, cacheManager);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        // Arrange
        String correlationId = "sampleCorrelationId";
        String expectedToken = "sampleToken";

        // Mock behavior of JwtUtil to return a token
        when(jwtUtil.getAuthToken()).thenReturn(expectedToken);

        // Mock behavior of CacheManager and Cache
        Cache cache = mock(Cache.class);
        when(cacheManager.getCache("tokens")).thenReturn(cache);
        when(cache.get("tokens")).thenReturn(null); // Simulate cache miss

        // Act
        String retrievedToken = tokenCache.retrieveTokenFromCache(correlationId);

        // Assert
        assertEquals(expectedToken, retrievedToken);

        // Verify log statements
        // Ideally, you would use a logging framework that captures log output for testing
    }
}

///
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class TokenCacheTest {

    private TokenCache tokenCache;
    private JwtUtil jwtUtil;

    @BeforeEach
    public void setUp() {
        jwtUtil = new JwtUtil(); // You may need to initialize JwtUtil appropriately
        tokenCache = new TokenCache();
        tokenCache.jwtUtil = jwtUtil; // Inject the JwtUtil instance manually
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        // Arrange
        String correlationId = "123456";
        String expectedToken = "testToken";

        // Act
        String token = tokenCache.retrieveTokenFromCache(correlationId);

        // Assert
        assertEquals(expectedToken, token);
    }

    @Test
    public void testRetrieveTokenFromCacheWithDifferentCorrelationId() throws CustomException {
        // Arrange
        String correlationId1 = "123456";
        String correlationId2 = "789012";

        // Act
        String token1 = tokenCache.retrieveTokenFromCache(correlationId1);
        String token2 = tokenCache.retrieveTokenFromCache(correlationId2);

        // Assert
        assertEquals(token1, token2);
    }
}

//
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class TokenCacheTest {

    private TokenCache tokenCache;

    @BeforeEach
    public void setUp() {
        tokenCache = new TokenCache();
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        String correlationId = "testCorrelationId";

        String token = tokenCache.retrieveTokenFromCache(correlationId);

        assertTrue(token != null && !token.isEmpty(), "Token should not be null or empty");
    }

    @Test
    public void testRetrieveTokenFromCacheLogs() throws CustomException {
        String correlationId = "testCorrelationId";

        String token = tokenCache.retrieveTokenFromCache(correlationId);

        // Assuming log.info() statements output to console or log files, you can check these manually.
        assertEquals(token, tokenCache.getToken(), "Token should be fetched from the cache");
    }
}


without MOCK
///
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

public class TokenCacheTest {

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CacheManager cacheManager;

    @Mock
    private Cache cache;

    @InjectMocks
    private TokenCache tokenCache;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        String correlationId = "12345";
        String expectedToken = "sampleToken";

        // Mock cache behavior
        when(cacheManager.getCache(anyString())).thenReturn(cache);
        when(cache.get(any())).thenReturn(expectedToken);

        // Mock JwtUtil behavior
        when(jwtUtil.getAuthToken()).thenReturn(expectedToken);

        // Call the method under test
        String actualToken = tokenCache.retrieveTokenFromCache(correlationId);

        // Verify behavior
        verify(cacheManager).getCache(TokenCache.TOKEN_CACHE_NAME);
        verify(cache).get(TokenCache.TOKEN_CACHE_NAME);
        verify(jwtUtil).getAuthToken();
        verify(cache).put(eq(TokenCache.TOKEN_CACHE_NAME), eq(expectedToken));

        // Verify the returned token
        assertEquals(expectedToken, actualToken);
    }

    @Test
    public void testRetrieveTokenFromCache_NoCacheEntry() throws CustomException {
        String correlationId = "12345";
        String expectedToken = "sampleToken";

        // Mock cache behavior
        when(cacheManager.getCache(anyString())).thenReturn(cache);
        when(cache.get(any())).thenReturn(null);

        // Mock JwtUtil behavior
        when(jwtUtil.getAuthToken()).thenReturn(expectedToken);

        // Call the method under test
        String actualToken = tokenCache.retrieveTokenFromCache(correlationId);

        // Verify behavior
        verify(cacheManager).getCache(TokenCache.TOKEN_CACHE_NAME);
        verify(cache).get(TokenCache.TOKEN_CACHE_NAME);
        verify(jwtUtil).getAuthToken();
        verify(cache).put(eq(TokenCache.TOKEN_CACHE_NAME), eq(expectedToken));

        // Verify the returned token
        assertEquals(expectedToken, actualToken);
    }
}


//
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class TokenCacheTest {

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CacheManager cacheManager;

    @InjectMocks
    private TokenCache tokenCache;

    @Mock
    private Cache cache;

    @Test
    void testRetrieveTokenFromCache_WithCachedToken() throws CustomException {
        String correlationId = "correlation-123";
        String cachedToken = "cached-token";

        when(cacheManager.getCache("tokens")).thenReturn(cache);
        when(cache.get("tokens")).thenReturn(new Cache.ValueWrapper() {
            @Override
            public Object get() {
                return cachedToken;
            }
        });

        String result = tokenCache.retrieveTokenFromCache(correlationId);

        verify(cacheManager).getCache("tokens");
        verify(cache).get("tokens");
        verify(jwtUtil, never()).getAuthToken(); // Token should not be fetched from JwtUtil
        // Ensure logs are generated and correlationId is mentioned
        // Verify if the returned token matches the cached token
        // Verify log statements

        assertEquals(cachedToken, result);
    }

    @Test
    void testRetrieveTokenFromCache_WithoutCachedToken() throws CustomException {
        String correlationId = "correlation-456";
        String fetchedToken = "fetched-token";

        when(cacheManager.getCache("tokens")).thenReturn(cache);
        when(cache.get("tokens")).thenReturn(null); // Simulating cache miss
        when(jwtUtil.getAuthToken()).thenReturn(fetchedToken);

        String result = tokenCache.retrieveTokenFromCache(correlationId);

        verify(cacheManager).getCache("tokens");
        verify(cache).get("tokens");
        verify(jwtUtil).getAuthToken(); // Token should be fetched from JwtUtil
        // Ensure logs are generated and correlationId is mentioned
        // Verify if the returned token matches the fetched token
        // Verify log statements

        assertEquals(fetchedToken, result);
    }
}


/////////
@Test
    public void testRetrieveTokenFromCache() throws CustomException {
        String correlationId = "testCorrelationId";
        String mockToken = "mockToken";

        when(cacheManager.getCache(TokenCache.TOKEN_CACHE_NAME)).thenReturn(cache);
        when(cache.get(TokenCache.TOKEN_CACHE_NAME)).thenReturn(Mockito.mock(Cache.ValueWrapper.class));
        when(cache.get(TokenCache.TOKEN_CACHE_NAME).get()).thenReturn(mockToken);

        when(tokenCache.getToken()).thenReturn(mockToken);

        String resultToken = tokenCache.retrieveTokenFromCache(correlationId);

        assertEquals(mockToken, resultToken);

        verify(cacheManager, times(1)).getCache(TokenCache.TOKEN_CACHE_NAME);
        verify(cache, times(1)).get(TokenCache.TOKEN_CACHE_NAME);
        verify(tokenCache, times(1)).getToken();

        verify(cache, never()).put(any(), any());
    }
}
In this test class, we are using JUnit 5 along with Mockito to mock the necessary dependencies. The test case ensures that all lines in the retrieveTokenFromCache method are covered. The flow includes mocking the cache manager, cache, and token retrieval using the getToken method. The verify statements at the end ensure that the relevant methods were called the expected number of times.

Please note that you might need to adjust the imports and adapt the test case to your project's specific configuration and version of Spring and Mockito.









/////////
package uk.co.allianz.rap.lc.cache;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

//1. Implement a  token caching logic within loss-control-service
@Slf4j
@Component
public class TokenCache {

    private static final String TOKEN_CACHE_NAME = "tokens";
    @Autowired
    protected JwtUtil jwtUtil;
    @Autowired
    protected CacheManager cacheManager;

    @Cacheable(value = TOKEN_CACHE_NAME)
    public String getToken() throws CustomException {

        // Retrieve the token from the cache or data source
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            Cache.ValueWrapper valueWrapper = cache.get(TOKEN_CACHE_NAME);
            if (valueWrapper != null) {
                return (String) valueWrapper.get();
            }
        }
        String tokenFromDataSource = retrieveTokenFromDataSource();
        log.info("Generated Token");
        // Cache the token for future use
        cacheToken(tokenFromDataSource);
        return tokenFromDataSource;
    }

    public String retrieveTokenFromDataSource() throws CustomException {
        // Perform the actual retrieval of the token from the jwtUtil class
        String jwtToken = jwtUtil.getAuthToken();
        return jwtToken;
    }

    //token store in cache
    public void cacheToken(final String token) {
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            cache.put(TOKEN_CACHE_NAME, token);
        }
    }

    //retrieve Token From Cache & request contains the correlation id
    public String retrieveTokenFromCache(final String correlationId) throws CustomException {
        if (log.isInfoEnabled()) {
            log.info("Start invoking for token : Correlation ID: " + correlationId);
        }
        String token = getToken();
        log.info("Token fetch from cache");
        if (log.isInfoEnabled()) {
            log.info("Successfully retrieved the token: Correlation ID: " + correlationId);
        }
        return token;
    }
}

///////////////////////
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class CacheConfigTest {

    @InjectMocks
    private CacheConfig cacheConfig;

    @Test
    public void testCacheManagerConfiguration() {
        CacheManager cacheManager = cacheConfig.cacheManager();

        assertNotNull(cacheManager);

        Caffeine<Object, Object> caffeineCache = cacheConfig.caffeineCacheBuilder();
        assertNotNull(caffeineCache);

        caffeineCache.expireAfterWrite(123, TimeUnit.SECONDS);
        caffeineCache.maximumSize(456);

        assertEquals(123, caffeineCache.getExpiresAfterWrite());
        assertEquals(456, caffeineCache.getMaximumSize());
    }
}


//

import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class TokenCacheTest {

    @InjectMocks
    private TokenCache tokenCache;

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CacheManager cacheManager;

    @Mock
    private Cache cache;

    private static final String TOKEN_CACHE_NAME = "tokens";  // Define the private constant here

    @Before
    public void setup() {
        when(cacheManager.getCache(TOKEN_CACHE_NAME)).thenReturn(cache); // Use the constant here
    }

    // ... Rest of the test methods remain the same
}

////////////////1////////////////
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.test.context.junit4.SpringRunner;

import static org.junit.Assert.assertNotNull;

@RunWith(SpringRunner.class)
public class CacheConfigTest {

    @Configuration
    static class TestConfiguration {
        @Bean
        public CacheManager cacheManager() {
            return new CaffeineCacheManager();
        }
    }

    @Autowired
    private CacheManager cacheManager;

    @Test
    public void testCacheManagerBean() {
        Cache cache = cacheManager.getCache("tokens");
        assertNotNull(cache);
    }
}


//
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class TokenCacheTest {

    @InjectMocks
    private TokenCache tokenCache;

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CacheManager cacheManager;

    @Mock
    private Cache cache;

    @Before
    public void setup() {
        when(cacheManager.getCache(TokenCache.TOKEN_CACHE_NAME)).thenReturn(cache);
    }

    @Test
    public void testRetrieveTokenFromDataSource() throws CustomException {
        when(jwtUtil.getAuthToken()).thenReturn("testToken");
        String token = tokenCache.retrieveTokenFromDataSource();
        assertEquals("testToken", token);
    }

    @Test
    public void testCacheToken() {
        tokenCache.cacheToken("cachedToken");
        verify(cache, times(1)).put(eq(TokenCache.TOKEN_CACHE_NAME), eq("cachedToken"));
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        when(cache.get(TokenCache.TOKEN_CACHE_NAME)).thenReturn(new SimpleValueWrapper("cachedToken"));
        String token = tokenCache.retrieveTokenFromCache("correlationId");
        assertEquals("cachedToken", token);
    }

    @Test
    public void testGetTokenFromCache() throws CustomException {
        when(cache.get(TokenCache.TOKEN_CACHE_NAME)).thenReturn(null);
        when(jwtUtil.getAuthToken()).thenReturn("newToken");
        String token = tokenCache.getToken();
        assertEquals("newToken", token);
        verify(cache, times(1)).put(eq(TokenCache.TOKEN_CACHE_NAME), eq("newToken"));
    }
}


////2/////
package uk.co.allianz.rap.lc.cache;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.junit.jupiter.api.Test;
import org.springframework.cache.CacheManager;
import org.springframework.cache.caffeine.CaffeineCacheManager;

import static org.junit.jupiter.api.Assertions.*;

class CacheConfigTest {

    @Test
    void testCacheManagerBean() {
        CacheManager cacheManager = new CacheConfig().cacheManager();

        assertNotNull(cacheManager);
        assertTrue(cacheManager instanceof CaffeineCacheManager);

        CaffeineCacheManager caffeineCacheManager = (CaffeineCacheManager) cacheManager;
        Caffeine<Object, Object> caffeine = caffeineCacheManager.getCaffeine();

        assertNotNull(caffeine);
        assertEquals(CacheConfig.CACHE_DURATION, caffeine.getExpiresAfterWrite());
        assertEquals(CacheConfig.CACHE_SIZE, caffeine.getMaximumSize());
    }
}


//
package uk.co.allianz.rap.lc.cache;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

class TokenCacheTest {

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CacheManager cacheManager;

    @Mock
    private Cache cache;

    @InjectMocks
    private TokenCache tokenCache;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        when(cacheManager.getCache(TokenCache.TOKEN_CACHE_NAME)).thenReturn(cache);
    }

    @Test
    void testGetTokenFromCache() throws CustomException {
        String token = "testToken";
        when(cache.get(TokenCache.TOKEN_CACHE_NAME)).thenReturn(mock(Cache.ValueWrapper.class));
        when(cache.get(TokenCache.TOKEN_CACHE_NAME).get()).thenReturn(token);

        String result = tokenCache.getToken();

        assertEquals(token, result);
        verify(cache, times(1)).get(TokenCache.TOKEN_CACHE_NAME);
    }

    @Test
    void testGetTokenFromDataSource() throws CustomException {
        String jwtToken = "testJwtToken";
        when(jwtUtil.getAuthToken()).thenReturn(jwtToken);

        String result = tokenCache.retrieveTokenFromDataSource();

        assertEquals(jwtToken, result);
        verify(jwtUtil, times(1)).getAuthToken();
    }

    @Test
    void testCacheToken() {
        String token = "testToken";
        tokenCache.cacheToken(token);

        verify(cache, times(1)).put(TokenCache.TOKEN_CACHE_NAME, token);
    }

    @Test
    void testRetrieveTokenFromCache() throws CustomException {
        String correlationId = "testCorrelationId";
        String token = "testToken";
        when(cache.get(TokenCache.TOKEN_CACHE_NAME)).thenReturn(mock(Cache.ValueWrapper.class));
        when(cache.get(TokenCache.TOKEN_CACHE_NAME).get()).thenReturn(token);

        String result = tokenCache.retrieveTokenFromCache(correlationId);

        assertEquals(token, result);
        verify(cache, times(1)).get(TokenCache.TOKEN_CACHE_NAME);
    }
}


/////1//////
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class CacheConfigTest {

    @InjectMocks
    private CacheConfig cacheConfig;

    @Test
    public void testCacheManagerConfiguration() {
        CacheManager cacheManager = cacheConfig.cacheManager();

        assertNotNull(cacheManager);

        Caffeine<Object, Object> caffeineCache = cacheConfig.caffeineCacheBuilder();
        assertNotNull(caffeineCache);

        assertEquals(123, caffeineCache.expireAfterWrite(123, TimeUnit.SECONDS).getExpiresAfterWrite());
        assertEquals(456, caffeineCache.maximumSize(456).maximumSize());
    }
}

//
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class TokenCacheTest {

    @InjectMocks
    private TokenCache tokenCache;

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private CacheManager cacheManager;

    @Mock
    private Cache cache;

    @Test
    public void testGetTokenFromCache() throws CustomException {
        when(cacheManager.getCache(eq(TokenCache.TOKEN_CACHE_NAME))).thenReturn(cache);
        when(cache.get(eq(TokenCache.TOKEN_CACHE_NAME))).thenReturn(new SimpleValueWrapper("cachedToken"));

        String token = tokenCache.getToken();

        assertEquals("cachedToken", token);
        verify(jwtUtil, never()).getAuthToken(); // Make sure the jwtUtil is not called
    }

    @Test
    public void testGetTokenFromDataSource() throws CustomException {
        when(cacheManager.getCache(eq(TokenCache.TOKEN_CACHE_NAME))).thenReturn(cache);
        when(cache.get(eq(TokenCache.TOKEN_CACHE_NAME))).thenReturn(null);
        when(jwtUtil.getAuthToken()).thenReturn("newToken");

        String token = tokenCache.getToken();

        assertEquals("newToken", token);
        verify(cache).put(eq(TokenCache.TOKEN_CACHE_NAME), eq("newToken"));
    }

    @Test
    public void testRetrieveTokenFromCache() throws CustomException {
        when(cacheManager.getCache(eq(TokenCache.TOKEN_CACHE_NAME))).thenReturn(cache);
        when(cache.get(eq(TokenCache.TOKEN_CACHE_NAME))).thenReturn(new SimpleValueWrapper("cachedToken"));

        String token = tokenCache.retrieveTokenFromCache("correlationId");

        assertEquals("cachedToken", token);
    }
}

///////////////
package uk.co.allianz.rap.lc.cache;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;

//1. Implement a  token caching logic within loss-control-service
@Slf4j
@Component
public class TokenCache {

    private static final String TOKEN_CACHE_NAME = "tokens";
    @Autowired
    protected JwtUtil jwtUtil;
    @Autowired
    protected CacheManager cacheManager;

    @Cacheable(value = TOKEN_CACHE_NAME)
    public String getToken() throws CustomException {

        // Retrieve the token from the cache or data source
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            Cache.ValueWrapper valueWrapper = cache.get(TOKEN_CACHE_NAME);
            if (valueWrapper != null) {
                return (String) valueWrapper.get();
            }
        }
        String tokenFromDataSource = retrieveTokenFromDataSource();
        log.info("Generated Token");
        // Cache the token for future use
        cacheToken(tokenFromDataSource);
        return tokenFromDataSource;
    }

    public String retrieveTokenFromDataSource() throws CustomException {
        // Perform the actual retrieval of the token from the jwtUtil class
        String jwtToken = jwtUtil.getAuthToken();
        return jwtToken;
    }

    //token store in cache
    public void cacheToken(final String token) {
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            cache.put(TOKEN_CACHE_NAME, token);
        }
    }

    //retrieve Token From Cache & request contains the correlation id
    public String retrieveTokenFromCache(final String correlationId) throws CustomException {
        if (log.isInfoEnabled()) {
            log.info("Start invoking for token : Correlation ID: " + correlationId);
        }
        String token = getToken();
        log.info("Token fetch from cache");
        if (log.isInfoEnabled()) {
            log.info("Successfully retrieved the token: Correlation ID: " + correlationId);
        }
        return token;
    }
}
.........
package uk.co.allianz.rap.lc.cache;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.TimeUnit;

import static uk.co.allianz.rap.lc.constant.LCConstants.CACHE_DURATION;
import static uk.co.allianz.rap.lc.constant.LCConstants.CACHE_SIZE;

@Configuration
@EnableCaching
public class CacheConfig {

    //This method for Manage the cache
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(caffeineCacheBuilder());
        return cacheManager;
    }

    @Bean
    public Caffeine<Object, Object> caffeineCacheBuilder() {
        return Caffeine.newBuilder().expireAfterWrite(CACHE_DURATION, TimeUnit.SECONDS) // Set the expiration time for the tokens
                .maximumSize(CACHE_SIZE); // Set the maximum number of tokens to store in the cache
    }
}
///////////////// JUNIT-Test Cases ////////////////////////////////////////////////////////
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
    
    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
    Map<String, Object> locationResult = lossControlDao.findByLocationId(combineLocationID);

    if (clientResult != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
            importClientRequest.getClient().setLookupID(lc360ClientId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        String lc360_Lookup_ID = importClientResponse.getResult().getClientLookupID();
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), lc360_Lookup_ID);
    }

    if (locationResult == null) {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    } else {
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationId != null) {
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
            locations.get(0).setLookupID(lc360LocationId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    }
    
    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}


//
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());

    if (result != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get("lc360_client_id"); // Replace with the correct key
            importClientRequest.getClient().setLookupID(lc360ClientId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        String lc360_Lookup_ID = importClientResponse.getResult().getClientLookupID();
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), lc360_Lookup_ID);
    }

    if (result == null) {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    } else {
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationId != null) {
            String lc360LocationId = (String) lcLocationId.get("lc360_location_id"); // Replace with the correct key
            locations.get(0).setLookupID(lc360LocationId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    }

    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}


//
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
    
    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
    
    if (result != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
            importClientRequest.getClient().setLookupID(lc360ClientId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            String lc360_Lookup_ID = importClientResponse.getResult().getClientLookupID();
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), lc360_Lookup_ID);
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        String lc360_Lookup_ID = importClientResponse.getResult().getClientLookupID();
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), lc360_Lookup_ID);
    }
    
    if (result == null) {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    } else {
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationId != null) {
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
            locations.get(0).setLookupID(lc360LocationId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    }
    
    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}


////11111//
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

    Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
    Map<String, Object> locationResult = lossControlDao.findByLocationId(importClientRequest.getClient().getLookupID());

    if (clientResult != null) {
        Map<String, Object> lcClientIds = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientIds != null) {
            String lc360ClientId = (String) lcClientIds.get(lcClientIds.keySet().iterator().next());
            importClientRequest.getClient().setLookupID(lc360ClientId);
            log.info("Received JSON for client");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        String lc360ClientId = importClientResponse.getResult().getClientLookupID();
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), lc360ClientId);
    }

    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String locationLookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = locationLookupID + "+" + policyNumber;

    if (locationResult != null) {
        Map<String, Object> lcLocationIds = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationIds != null) {
            String lc360LocationId = (String) lcLocationIds.get(lcLocationIds.keySet().iterator().next());
            locations.get(0).setLookupID(lc360LocationId);
            log.info("Received JSON for location");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    } else {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        String lc360LocationId = importClientResponse.getResult().getLocations().get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360LocationId);
    }

    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}


...
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());

    if (result != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
            importClientRequest.getClient().setLookupID(lc360ClientId);

            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

        // Only update lcLocationId if it's not already set
        if (locations.get(0).getLookupID() == null) {
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
            String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
            locations.get(0).setLookupID(lc360_Lookup_ID);
            lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
        }
    }

    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}


.........
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
    
    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
    
    if (result != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
            importClientRequest.getClient().setLookupID(lc360ClientId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        String lc360_Lookup_ID = importClientResponse.getResult().getClientLookupID();
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), lc360_Lookup_ID);
    }
    
    if (result == null) {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    } else {
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationId != null) {
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
            locations.get(0).setLookupID(lc360LocationId);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    }
    
    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}

//1 ..below1
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
    
    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());

    if (result == null) {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
    }

    Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
    if (lcClientId != null) {
        String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
        importClientRequest.getClient().setLookupID(lc360ClientId);
        objectMapper.writeValueAsString(importClientRequest);
        System.out.println(importClientRequest);
        log.info("Received JSON");
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
    } else {
        log.info("lc360 client id not present");
    }

    Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
    if (lcLocationId != null) {
        String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
        locations.get(0).setLookupID(lc360LocationId);

        String updatedJson = objectMapper.writeValueAsString(importClientRequest);
        System.out.println(updatedJson);
        log.info("Received JSON");
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
    } else {
        log.info("lc360 location id not present");
    }

    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package uk.co.allianz.rap.lc.service; //onlyClientLC:+!

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());

        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String location_LookupID = locations.get(0).getLookupID();
        String policyNumber = locations.get(0).getPolicyNumber();
        String combineLocationID = location_LookupID + "+" + policyNumber;

        if (result != null) {
            Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            if (lcClientId != null) {
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
                importClientRequest.getClient().setLookupID(lc360ClientId);
                objectMapper.writeValueAsString(importClientRequest);
                System.out.println(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 client id not present");
            }
        } else {
            log.info("Client is not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(),importClientResponse.getResult().getClientLookupID());
        }

        if (result == null) {
            log.info("Location is not present");
            lossControlDao.insertLocationId(combineLocationID);
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
            String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
            lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
        } else {
            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
            if (lcLocationId != null) {
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                locations.get(0).setLookupID(lc360LocationId);
                String updatedJson = objectMapper.writeValueAsString(importClientRequest);
                System.out.println(updatedJson);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        }

        log.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}


/////
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String locationID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = locationID + "+" + policyNumber;

    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
    if (result != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());

            importClientRequest.getClient().setLookupID(lc360ClientId);

            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest,tokenCache.retrieveTokenFromCache(correlationId));
        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(),importClientResponse.getResult().getClientLookupID());
    }

    if (result == null) {
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationId != null) {
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
            locations.get(0).setLookupID(lc360LocationId);

            String updatedJson = objectMapper.writeValueAsString(importClientRequest);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    } else {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();

        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    }

    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}

//
@Override
public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
    ImportClientResponse importClientResponse = null;
    ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
    Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
    
    ArrayList<Location> locations = importClientRequest.getClient().getLocations();
    String location_LookupID = locations.get(0).getLookupID();
    String policyNumber = locations.get(0).getPolicyNumber();
    String combineLocationID = location_LookupID + "+" + policyNumber;

    if (result != null) {
        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        if (lcClientId != null) {
            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
            importClientRequest.getClient().setLookupID(lc360ClientId);
            objectMapper.writeValueAsString(importClientRequest);
            System.out.println(importClientRequest);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 client id not present");
        }
    } else {
        log.info("Client is not present");
        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    }
    
    if (result == null) {
        log.info("Location is not present");
        lossControlDao.insertLocationId(combineLocationID);
        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
        String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
        lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
    } else {
        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
        if (lcLocationId != null) {
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
            locations.get(0).setLookupID(lc360LocationId);
            String updatedJson = objectMapper.writeValueAsString(importClientRequest);
            System.out.println(updatedJson);
            log.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        } else {
            log.info("lc360 location id not present");
        }
    }
    
    log.info("importClientResponse Successfully Received");
    return importClientResponse;
}

//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String location_LookupID = locations.get(0).getLookupID();
        String policyNumber = locations.get(0).getPolicyNumber();
        String combineLocationID = location_LookupID + "+" + policyNumber;

        Map<String, Object> result = lossControlDao.findByLocationId(combineLocationID);
        if (result != null) {
            Map<String,Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
            if (lcLocationId != null) {
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                locations.get(0).setLookupID(lc360LocationId);
                String updatedJson = objectMapper.writeValueAsString(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Location is not present");
            lossControlDao.insertLocationId(combineLocationID);
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
            String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();
            lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
        }

        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {
            Map<String,Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            if (lcClientId != null) {
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
                importClientRequest.getClient().setLookupID(lc360ClientId);
                objectMapper.writeValueAsString(importClientRequest);
                System.out.println(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 client id not present");
            }
        } else {
            log.info("Client is not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
        }

        log.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}



//////////package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> result = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if(result != null){
            Map<String,Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            if(lcClientId != null){
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());

           importClientRequest.getClient().setLookupID(lc360ClientId);
                objectMapper.writeValueAsString(importClientRequest);
                System.out.println(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            }
            else {
                log.info("lc360 client id not present");
            }
        }
        else {
            log.info("Client is not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest,tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(),importClientResponse.getResult().getClientLookupID());
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}















//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String location_LookupID = locations.get(0).getLookupID();


//        Policy number
        String policyNumber = locations.get(0).getPolicyNumber();

        //combination of Location ID + Policy number
        String combineLocationID = location_LookupID + "+" + policyNumber;

        Map<String, Object> result = lossControlDao.findByLocationId(combineLocationID);
        if (result != null) {

            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
            if (lcLocationId != null) {
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                locations.get(0).setLookupID(lc360LocationId);


                //If LC-360 Location Id exists use that id to the request to LC360
                String updatedJson = objectMapper.writeValueAsString(importClientRequest);
                System.out.println(updatedJson);


                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Location is not present");
            lossControlDao.insertLocationId(combineLocationID);
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();

//        Lookup ID Response
            String lc360_Lookup_ID = locationsResponse.get(0).getLocationLookupID();

            lossControlDao.updateLcLocationId(combineLocationID, lc360_Lookup_ID);
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}





/////package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);

        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String locationID = locations.get(0).getLookupID();
        //
//
//        //Location ID:LookupID
        System.out.println("LocationID:" + locationID);
//        //Policy number
        String policyNumber = locations.get(0).getPolicyNumber();
        System.out.println("policyNumber:" + policyNumber);
//
//        //combination of Location ID + Policy number
        String combineLocationID = locationID + "+" + policyNumber;
        System.out.println("combination of Location ID + Policy number:" + combineLocationID);
//
        //
        Map<String, Object> result = lossControlDao.findByLocationId(combineLocationID);
        if(result != null){

            Map<String,Object> lcLocationId = lossControlDao.findLc360LocationID(combineLocationID);
            if(lcLocationId != null){
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                System.out.println(lc360LocationId);
//
package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;

@SuppressWarnings("unused")
@Data
public class Location {
    @JsonProperty("LocationID")
    private String locationID;
    @JsonProperty("ClientID")
    private String clientID;
    @JsonProperty("LocationLookupID")
    private String locationLookupID;
    @JsonProperty("IsDeleted")
    private boolean isDeleted;
    @JsonProperty("Success")
    private boolean success;
    @JsonProperty("CommercialCoverages")
    private ArrayList<CommercialCoverage> commercialCoverages;
}

//
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;
import java.util.Date;

@SuppressWarnings("unused")
@Data
public class Location {
    @JsonProperty("LookupID")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String lookupID;
    @JsonProperty("PolicyNumber")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String policyNumber;
    @JsonProperty("RenewalDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    @JsonFormat(pattern = "yyyy-MM-dd")
    private Date renewalDate;
    @JsonProperty("Address")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Address address;
    @JsonProperty("Coverages")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private ArrayList<Coverage> coverages;
    @JsonProperty("Contact")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Contact contact;
    @JsonProperty("Name")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String name;

    @JsonProperty("PolicyEffectiveDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date policyEffectiveDate;

    @JsonProperty("PolicyExpirationDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date policyExpirationDate;

    @JsonProperty("PolicyRenewalDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date policyRenewalDate;

    @JsonProperty("OriginalEffectiveDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date originalEffectiveDate;

    @JsonProperty("EffectiveDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date effectiveDate;
    @JsonProperty("ExpirationDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date expirationDate;

    @JsonProperty("LastInspectedDate")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Date lastInspectedDate;
    private ArrayList<GenericField> genericFields;

}



///
package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;
@SuppressWarnings("unused")
@Data
public class Result {
    @JsonProperty("ClientID")
    private String clientID;
    @JsonProperty("ClientLookupID")
    private String clientLookupID;
    @JsonProperty("IsDeleted")
    private boolean isDeleted;
    @JsonProperty("Errors")
    private ArrayList<Object> errors;
    @JsonProperty("Warnings")
    private Object warnings;
    @JsonProperty("Success")
    private boolean success;
    @JsonProperty("Locations")
    private ArrayList<Location> locations;
    @JsonProperty("CommercialCoverages")
    private ArrayList<Object> commercialCoverages;
    @JsonProperty("Messages")
    private ArrayList<Object> messages;
}


..

package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@SuppressWarnings("unused")
@Data
public class ImportClientResponse {
    @JsonProperty("Result")
    private Result result;
    @JsonProperty("ImportRequestID")
    private String importRequestID;
}



.............
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;
@SuppressWarnings("unused")
@Data
public class Client {
    @JsonProperty("LookupID")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String lookupID;
    @JsonProperty("ContactFirstName")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String contactFirstName;
    @JsonProperty("ContactLastName")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String contactLastName;
    @JsonProperty("PolicyNumber")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String policyNumber;
    @JsonProperty("Name")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String name;
    @JsonProperty("Phone")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String phone;
    @JsonProperty("Email")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String email;
    @JsonProperty("Address")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Address address;
    @JsonProperty("Agent")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Agent agent;
    @JsonProperty("Underwriter")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Underwriter underwriter;

    @JsonProperty("Locations")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private ArrayList<Location> locations;

}


................


package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Data;
import com.fasterxml.jackson.annotation.JsonProperty;

@SuppressWarnings("unused")
@Data
public class ImportClientRequest {
    @JsonProperty("divisionLookupID")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String divisionLookupID;
    @JsonProperty("client")
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private Client client;

}



///////////

package uk.co.allianz.rap.lc.util;



import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.client.WebClient;
import uk.co.allianz.rap.lc.model.JwtTokenModel;
import uk.co.allianz.rap.lc.model.response.AuthTokenResponse;

@Component
public class JwtUtil {

    @Autowired
    private JwtTokenModel jwtTokenModel;

    //method used for invoke first LC360 api
    //post http request
    //input clientid,granttype,clientsecret,authtokenurl
    //generate jwt bearer token
    public String getAuthToken() {
         WebClient webClient = WebClient.create();
        MultiValueMap<String, String> requestBody = new LinkedMultiValueMap<>(); //added in try catch using custome exception
        requestBody.add("grant_type", jwtTokenModel.getGrantType());
        requestBody.add("client_id", jwtTokenModel.getClientId());
        requestBody.add("client_secret", jwtTokenModel.getClientSecret());
        AuthTokenResponse authTokenResponse = webClient.post()
                .uri(jwtTokenModel.getAuthTokenUrl())
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .bodyValue(requestBody)
                .retrieve()
                .bodyToMono(AuthTokenResponse.class)
                .block();

        return authTokenResponse.getAccessToken();
    }
}

//provide log 

if (log.isErrorEnabled()) {
    log.error("Invalid JSON: " + e.getMessage());
}

.............
if (log.isInfoEnabled()) {
    log.info("Information message: " + someInfo);
}

if (log.isDebugEnabled()) {
    log.debug("Debug message: " + someDebugInfo);
}

if (log.isWarnEnabled()) {
    log.warn("Warning message: " + someWarning);
}


//////////////////package uk.co.allianz.rap.lc.rest;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;


@Slf4j
@RestController
public class ValidationRest {
    @Autowired
    private TokenCache tokenCache;

    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    //Build the end point/Resource path: POST: surveySubmission
    //Build standard JSON validation on incoming data

    //Implement a  token caching logic within loss-control-service.
    //Consume the correlation id we receive is available for further business logic to log it.
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<?> processJson(@RequestBody(required = false) final String json, @RequestHeader("Correlation-ID") final String correlationId) {

        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            log.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");

        }
        try {
            //for validate JSON
            String validateinput = validationServiceImpl.processJson(json);
            //For import only client
            ImportClientResponse processedJson = importClientServiceImp.importClient(validateinput, correlationId);
            log.info("JSON received successfully");
            return ResponseEntity.ok(processedJson);

        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            log.error("Invalid JSON: " + e.getMessage());
            return ResponseEntity.badRequest().body("Invalid JSON: " + e.getMessage());

        } catch (Exception e) {
            // Other exceptions
            log.error("Invalid JSON format");
            return ResponseEntity.badRequest().body("Invalid JSON format");

        }
    }
}




/////////////////

@Service
public class SomeOtherService {
    private final LocationService locationService;

    @Autowired
    public SomeOtherService(LocationService locationService) {
        this.locationService = locationService;
    }

    public void someMethod() {
        String locationIDToCheck = "your_location_id_here";
        boolean isLocationIDPresent = locationService.isLocationIDPresentInDB(locationIDToCheck);

        if (isLocationIDPresent) {
            System.out.println("Location ID exists in the database.");
        } else {
            System.out.println("Location ID does not exist in the database.");
        }
    }
}



import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class LocationService {
    private final LocationRepository locationRepository;

    @Autowired
    public LocationService(LocationRepository locationRepository) {
        this.locationRepository = locationRepository;
    }

    public boolean isLocationIDPresentInDB(String locationID) {
        return locationRepository.existsByLocationID(locationID);
    }
}



import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface LocationRepository extends JpaRepository<LocationEntity, String> {
    // Custom query to check if a locationID exists in the database
    boolean existsByLocationID(String locationID);
}



import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "location_table") // Replace "location_table" with the actual table name in your database
@Data
public class LocationEntity {
    @Id
    private String locationID;
    // Add other attributes as needed
}

////////////////////
package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;

@SuppressWarnings("unused")
@Data//
public class Location {
    @JsonProperty("LocationID")
    private String locationID;
    @JsonProperty("ClientID")
    private String clientID;
    @JsonProperty("LocationLookupID")
    private String locationLookupID;
    @JsonProperty("IsDeleted")
    private boolean isDeleted;
    @JsonProperty("Success")
    private boolean success;
    @JsonProperty("CommercialCoverages")
    private ArrayList<CommercialCoverage> commercialCoverages;
}





package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;
@SuppressWarnings("unused")
@Data//
public class Result {
    @JsonProperty("ClientID")
    private String clientID;
    @JsonProperty("ClientLookupID")
    private String clientLookupID;
    @JsonProperty("IsDeleted")
    private boolean isDeleted;
    @JsonProperty("Errors")
    private ArrayList<Object> errors;
    @JsonProperty("Warnings")
    private Object warnings;
    @JsonProperty("Success")
    private boolean success;
    @JsonProperty("Locations")
    private ArrayList<Location> locations;
    @JsonProperty("CommercialCoverages")
    private ArrayList<Object> commercialCoverages;
    @JsonProperty("Messages")
    private ArrayList<Object> messages;
}



package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@SuppressWarnings("unused")
@Data
public class ImportClientResponse {
    @JsonProperty("Result")
    private Result result;
    @JsonProperty("ImportRequestID")
    private String importRequestID;
}


//////////////////
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import org.junit.Before;
import org.junit.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import static org.junit.Assert.assertEquals;

public class ImportClientServiceImpTest {

    private TokenCache tokenCache;
    private LossControlServiceImpl lossControlServiceImpl;
    private Gson gson;
    private ObjectMapper objectMapper;
    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        tokenCache = new TokenCache(); // Instantiate the real TokenCache if needed
        lossControlServiceImpl = new LossControlServiceImpl(); // Instantiate the real LossControlServiceImpl if needed
        gson = new Gson(); // Instantiate the real Gson if needed
        objectMapper = new ObjectMapper(); // Instantiate the real ObjectMapper if needed

        importClientService = new ImportClientServiceImp();
        importClientService.setTokenCache(tokenCache);
        importClientService.setLossControlService(lossControlServiceImpl);
        importClientService.setGson(gson);
        importClientService.setObjectMapper(objectMapper);
    }

    @Test
    public void testImportClient_Success() throws CustomException, JsonProcessingException {
        // Prepare the JSON input
        String jsonInput = "{\"divisionLookupID\": \"123\", \"client\": {\"Name\": \"John Doe\"}}";

        // Call the method under test
        ImportClientResponse result = importClientService.importClient(jsonInput);

        // Assert the result based on your expectations
        assertEquals("SUCCESS", result.getStatus());
        // ... Assert other properties of the result if needed
    }
}

//
import static org.junit.Assert.assertEquals;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import org.junit.Before;
import org.junit.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

public class ImportClientServiceImpTest {

    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        importClientService = new ImportClientServiceImp();
        importClientService.tokenCache = new TokenCache(); // You may need to initialize tokenCache with appropriate data
        importClientService.lossControlServiceImpl = new LossControlServiceImpl(); // You may need to initialize lossControlServiceImpl with appropriate data
        importClientService.gson = new Gson();
        importClientService.objectMapper = new ObjectMapper();
    }

    @Test
    public void testImportClient_Success() throws CustomException, JsonProcessingException {
        // Test data
        String jsonInput = "{\"divisionLookupID\": \"123\", \"client\": {\"Name\": \"John Doe\"}}";

        // Call the method under test
        ImportClientResponse result = importClientService.importClient(jsonInput);

        // Assert the result (Replace the expected values with the actual expected output)
        assertEquals("EXPECTED_STATUS", result.getStatus());
        // ... Assert other properties of the response
    }
}

//
import static org.junit.Assert.assertEquals;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import org.junit.Before;
import org.junit.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

public class ImportClientServiceImpTest {

    private TokenCache tokenCache;
    private LossControlServiceImpl lossControlServiceImpl;
    private Gson gson;
    private ObjectMapper objectMapper;
    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        // Initialize test instances
        tokenCache = new TokenCache();
        lossControlServiceImpl = new LossControlServiceImpl();
        gson = new Gson();
        objectMapper = new ObjectMapper();
        importClientService = new ImportClientServiceImp(tokenCache, lossControlServiceImpl, gson, objectMapper);
    }

    @Test
    public void testImportClient_Success() throws CustomException, JsonProcessingException {
        // Prepare test data
        String jsonInput = "{\"divisionLookupID\": \"123\", \"client\": {\"Name\": \"John Doe\"}}";
        ImportClientRequest request = new ImportClientRequest();
        request.setDivisionLookupID("123");
        // ... Set other properties

        ImportClientResponse expectedResponse = new ImportClientResponse();
        expectedResponse.setStatus("SUCCESS");
        // ... Set other properties

        // Call the method under test
        ImportClientResponse result = importClientService.importClient(jsonInput);

        // Assert the result
        assertEquals(expectedResponse, result);
    }

    // Add more test cases as needed for other scenarios and error cases
}



//
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import org.junit.Before;
import org.junit.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import static org.junit.Assert.assertEquals;

public class ImportClientServiceImpTest {

    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        TokenCache tokenCache = new TokenCache();
        LossControlServiceImpl lossControlServiceImpl = new LossControlServiceImpl();
        Gson gson = new Gson();
        ObjectMapper objectMapper = new ObjectMapper();
        importClientService = new ImportClientServiceImp(tokenCache, lossControlServiceImpl, gson, objectMapper);
    }

    @Test
    public void testImportClient_Success() throws CustomException, JsonProcessingException {
        // Prepare the JSON input
        String jsonInput = "{\"divisionLookupID\": \"123\", \"client\": {\"Name\": \"John Doe\"}}";

        // Call the method under test
        ImportClientResponse result = importClientService.importClient(jsonInput);

        // Verify the behavior and the result
        assertEquals("SUCCESS", result.getStatus());
        // ... Add other assertions based on the expected response properties
    }
}


//
import static org.junit.Assert.assertEquals;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import org.junit.Before;
import org.junit.Test;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

public class ImportClientServiceImpTest {

    private TokenCache tokenCache;
    private LossControlServiceImpl lossControlService;
    private Gson gson;
    private ObjectMapper objectMapper;
    private ImportClientServiceImp importClientService;

    @Before
    public void setUp() {
        tokenCache = new TokenCache(); // Initialize tokenCache as needed
        lossControlService = new LossControlServiceImpl(); // Initialize lossControlService as needed
        gson = new Gson();
        objectMapper = new ObjectMapper();
        importClientService = new ImportClientServiceImp(tokenCache, lossControlService, gson, objectMapper);
    }

    @Test
    public void testImportClient_Success() throws CustomException, JsonProcessingException {
        // Prepare the JSON input
        String jsonInput = "{\"divisionLookupID\": \"123\", \"client\": {\"Name\": \"John Doe\"}}";

        // Call the method under test
        ImportClientResponse result = importClientService.importClient(jsonInput);

        // Prepare the expected ImportClientRequest
        ImportClientRequest expectedRequest = new ImportClientRequest();
        expectedRequest.setDivisionLookupID("123");
        // ... Set other properties

        // Prepare the expected ImportClientResponse
        ImportClientResponse expectedResponse = new ImportClientResponse();
        expectedResponse.setStatus("SUCCESS");
        // ... Set other properties

        // Convert the result and expectedResponse to JSON strings for comparison
        String resultJson = gson.toJson(result);
        String expectedResponseJson = gson.toJson(expectedResponse);

        // Compare the JSON strings
        assertEquals(expectedResponseJson, resultJson);
    }
}



///
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;

    @Autowired
    private Gson gson;

    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public ImportClientResponse importClient(String json) throws CustomException, JsonProcessingException {

        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        String processedJson = objectMapper.writeValueAsString(importClientRequest);
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache1());
        log.info("Received JSON: " + processedJson);

        log.info("importClientResponse:" + importClientResponse);
        return importClientResponse;

    }
}



//

package uk.co.allianz.rap.lc.rest;

import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;


@Slf4j
@RestController
public class ValidationRest {


    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    //2. Build the end point/Resource path: POST: surveySubmission
    //3. Build standard JSON validation on incoming data
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<String> processJson(@RequestBody(required = false) final String json) {

        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            log.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");

        }
        try {
            //for validate JSON
           String validateinput=validationServiceImpl.processJson(json);
            //For import only client
            ImportClientResponse processedJson=importClientServiceImp.importClient(validateinput);
            log.info("JSON received successfully");
            return ResponseEntity.ok(processedJson);

        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            log.error("Invalid JSON: " + e.getMessage());
            return ResponseEntity.badRequest().body("Invalid JSON: " + e.getMessage());

        } catch (Exception e) {
            // Other exceptions
            log.error("Invalid JSON format");
            return ResponseEntity.badRequest().body("Invalid JSON format");

        }
    }
}






// Configure the date format for deserialization
        objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);

     // Configure the ObjectMapper to include non-null properties during serialization
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);



        ImportClientRequest importClientRequest = objectMapper.readValue(jsonDataWithoutInspection, ImportClientRequest.class);

        log.info("importClientRequest:"+importClientRequest);
        // access the data using the POJO classes(checking)
        log.info("Client Name:" + importClientRequest.getClient().getName());

        log.info("importClientRequest: " + importClientRequest);
        // Serialize the Java object back to JSON with non-null properties included
        String processedJson = objectMapper.writeValueAsString(importClientRequest);


//        String processedJson = gson.toJson(importClientRequest);
       // ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache1());


    //    log.info("importClientResponse:" + importClientResponse);

        log.info("Received JSON: " + processedJson);
        return processedJson;



//

{
    "client": {
        "lookupID": "C008032993",
        "policyNumber": "SP26853148",
        "address": {
            "country": "United Kingdom"
        },
        "agent": {
            "agencyCode": "22576",
            "agencyName": "Arthur J. Gallagher",
            "agentCode": "13332",
            "address": {
                "country": "United Kingdom"
            },
            "agentType": "Broker"
        },
        "locations": [
            {
                "lookupID": "",
                "policyNumber": "SP26853148",
                "renewalDate": "Jul 17, 2024, 5:30:00 AM",
                "address": {
                    "country": "United Kingdom",
                    "street1": "NEW CROSS DEWEL",
                    "street2": "SD 11 JEW TOWN",
                    "city": "MM KEMSTONE",
                    "region1": "UK",
                    "zipCode": "GU1 1DB"
                },
                "coverages": [
                    {
                        "coverageReference": "Coverage 1",
                        "coverageTypeLookup": "PD_TIV",
                        "genericFields": [
                            {
                                "number": "1123",
                                "key": "01. PD Building",
                                "genericFieldValueType": 1
                            },
                            {
                                "number": "0",
                                "key": "04. PD Other",
                                "genericFieldValueType": 1
                            },
                            {
                                "key": "05. PD Other Description",
                                "genericFieldValueType": 0,
                                "text": ""
                            },
                            {
                                "number": "1123",
                                "key": "06. TIV PD",
                                "genericFieldValueType": 1
                            },
                            {
                                "number": "332198",
                                "key": "07. TIV BI",
                                "genericFieldValueType": 1
                            },
                            {
                                "number": "",
                                "key": "08. BI Base Period (Months)",
                                "genericFieldValueType": 1
                            },
                            {
                                "number": "332198",
                                "key": "09. TIV (PD + BI )",
                                "genericFieldValueType": 1
                            }
                        ]
                    }
                ]
            }
        ]
    }
}
//
{
  "divisionLookupID" : "AZ_UK",
  "client" : {
    "LookupID" : "C008032993",
    "ContactFirstName" : null,
    "ContactLastName" : null,
    "PolicyNumber" : "SP26853148",
    "Name" : null,
    "Phone" : null,
    "Email" : null,
    "Address" : {
      "Country" : "United Kingdom",
      "OverseasTerritories" : null,
      "Street1" : null,
      "Street2" : null,
      "City" : null,
      "Region1" : null,
      "Region2" : null,
      "Region3" : null,
      "Region4" : null,
      "ZipCode" : null
    },
    "Agent" : {
      "AgencyCode" : "22576",
      "AgencyName" : "Arthur J. Gallagher",
      "AgentCode" : "13332",
      "AgentName" : null,
      "Email" : null,
      "FaxNumber" : null,
      "PhoneNumber" : null,
      "Address" : {
        "Country" : "United Kingdom",
        "OverseasTerritories" : null,
        "Street1" : null,
        "Street2" : null,
        "City" : null,
        "Region1" : null,
        "Region2" : null,
        "Region3" : null,
        "Region4" : null,
        "ZipCode" : null
      },
      "AgentType" : "Broker"
    },
    "Underwriter" : null,
    "Locations" : [ {
      "genericFields" : null,
      "LookupID" : "",
      "Name" : null,
      "PolicyNumber" : "SP26853148",
      "PolicyEffectiveDate" : null,
      "PolicyExpirationDate" : null,
      "PolicyRenewalDate" : null,
      "Address" : {
        "Country" : "United Kingdom",
        "OverseasTerritories" : null,
        "Street1" : "NEW CROSS DEWEL",
        "Street2" : "SD 11 JEW TOWN",
        "City" : "MM KEMSTONE",
        "Region1" : "UK",
        "Region2" : null,
        "Region3" : null,
        "Region4" : null,
        "ZipCode" : "GU1 1DB"
      },
      "OriginalEffectiveDate" : null,
      "EffectiveDate" : null,
      "ExpirationDate" : null,
      "RenewalDate" : "2024-07-17",
      "LastInspectedDate" : null,
      "Coverages" : [ {
        "CoverageTypeLookup" : "PD_TIV",
        "CoverageReference" : "Coverage 1",
        "GenericFields" : [ {
          "Number" : "1123",
          "Key" : "01. PD Building",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "0",
          "Key" : "04. PD Other",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : null,
          "Key" : "05. PD Other Description",
          "GenericFieldValueType" : 0,
          "Text" : ""
        }, {
          "Number" : "1123",
          "Key" : "06. TIV PD",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "332198",
          "Key" : "07. TIV BI",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "",
          "Key" : "08. BI Base Period (Months)",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "332198",
          "Key" : "09. TIV (PD + BI )",
          "GenericFieldValueType" : 1,
          "Text" : null
        } ]
      } ],
      "Contact" : null
    } ]
  }
}


//package uk.co.allianz.rap.lc.rest;

import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;


@Slf4j
@RestController
public class ValidationRest {

    private static final Logger LOGGER = LoggerFactory.getLogger(ValidationRest.class);

    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    //2. Build the end point/Resource path: POST: surveySubmission
    //3. Build standard JSON validation on incoming data
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<String> processJson(@RequestBody(required = false) final String json) {

        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            LOGGER.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");

        }
        try {
            //for validate JSON
           String validateinput=validationServiceImpl.processJson(json);
            // Return a response indicating success
            //For import only client and remove inspection
            String processedJson=importClientServiceImp.importClient(validateinput);
            LOGGER.info("JSON received successfully");
            return ResponseEntity.ok(processedJson);

        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            LOGGER.error("Invalid JSON: " + e.getMessage());
            return ResponseEntity.badRequest().body("Invalid JSON: " + e.getMessage());

        } catch (Exception e) {
            // Other exceptions
            LOGGER.error("Invalid JSON format");
            return ResponseEntity.badRequest().body("Invalid JSON format");

        }
    }
}



//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import com.google.json.JsonSanitizer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.exception.CustomException;

//3. Build standard JSON validation on incoming data
@Service
public class ValidationServiceImpl implements ValidationService {

    @Autowired
    private ImportClientServiceImp importClientServiceImp;
    private static final Logger LOGGER = LoggerFactory.getLogger(ValidationServiceImpl.class);

    public String processJson(final String json) throws CustomException, JsonProcessingException {
        // Parse the JSON string into a JsonElement

        JsonElement jsonElement;
        jsonElement = JsonParser.parseString(json);

        // Check if the JSON is a single value (string or number) or empty object/array
        if (isSingleValue(jsonElement)) {
            throw new CustomException("JSON is a single value. ");
        } else if (isEmptyObject(jsonElement) || isEmptyArray(jsonElement)) {
            throw new CustomException("JSON is empty object/array. ");
        }

        // Print the received JSON
        String sanitizedJson = JsonSanitizer.sanitize(json);


        return sanitizedJson;
    }

    // Helper method to check if the JSON element is a single value
    private boolean isSingleValue(final JsonElement jsonElement) {
        return !jsonElement.isJsonObject() && !jsonElement.isJsonArray();
    }

    // Helper method to check if the JSON element is an empty object ({})
    private boolean isEmptyObject(final JsonElement jsonElement) {
        return jsonElement.isJsonObject() && jsonElement.getAsJsonObject().entrySet().isEmpty();
    }

    // Helper method to check if the JSON element is an empty array ([])
    private boolean isEmptyArray(final JsonElement jsonElement) {
        return jsonElement.isJsonArray() && jsonElement.getAsJsonArray().size() == 0;
    }
}
//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.gson.Gson;
import com.google.json.JsonSanitizer;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

//Extracting fields and data from the "data model"
//sent from loss-control-adapter and building the API request: ImportClient
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;

    @Autowired
    private Gson gson;

    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public String importClient(String json) throws CustomException, JsonProcessingException {

        // Remove the "inspection" field from the JSON string
        JsonNode rootNode = new ObjectMapper().readTree(json);

        ((ObjectNode) rootNode).remove("inspection");
        String jsonDataWithoutInspection = rootNode.toString();


        //Data Mapping into Model(POJO) class
        ImportClientRequest importClientRequest = objectMapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT).readValue(jsonDataWithoutInspection, ImportClientRequest.class);

        log.info("importClientRequest:"+importClientRequest);
        // access the data using the POJO classes(checking)
        log.info("Client Name:" + importClientRequest.getClient().getName());

        log.info("importClientRequest: " + importClientRequest);

        String processedJson = gson.toJson(importClientRequest);
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache1());


        log.info("importClientResponse:" + importClientResponse);

        log.info("Received JSON: " + processedJson);
        return processedJson;

    }
}



///////////
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

@WebMvcTest(ImportClientController.class)
public class ImportClientControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testImportClient1_NullData() throws Exception {
        // Given
        String jsonData = null;

        // When-Then
        mockMvc.perform(post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content(jsonData))
                .andExpect(status().isBadRequest());
    }
}

//
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;

@WebMvcTest(ImportClientController.class)
public class ImportClientControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private Gson gson;

    @MockBean
    private ObjectMapper objectMapper;

    @Test
    public void testImportClient1_Success() throws Exception {
        // Given
        String jsonData = "{\"client\": {\"name\": \"John Doe\"}, \"inspection\": \"data\"}";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client client = new Client();
        client.setName("John Doe");
        importClientRequest.setClient(client);

        // Mock the behavior of ObjectMapper and Gson
        when(objectMapper.readTree(anyString())).thenReturn(new ObjectMapper().readTree(jsonData));
        when(gson.toJson(any(ImportClientRequest.class))).thenReturn("{\"client\":{\"name\":\"John Doe\"}}");

        // When-Then
        mockMvc.perform(post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content(jsonData))
                .andExpect(status().isOk());
    }
}


//
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;

// Add the necessary annotations
@SpringBootTest
@ContextConfiguration(classes = {ImportClientController.class})
@WebMvcTest
public class ImportClientControllerTest {

    @Autowired
    private MockMvc mockMvc;

    // Sample JSON data for testing
    private static final String SAMPLE_JSON_DATA = "{\"client\": {\"name\": \"John Doe\"}, \"inspection\": {\"field\": \"value\"}}";

    @Test
    public void testImportClient1_ValidData_Success() throws Exception {
        // Perform the POST request to "/import-client"
        mockMvc.perform(post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content(SAMPLE_JSON_DATA))
                .andExpect(status().isOk());
        // Add more assertions as needed based on the expected behavior
    }

    @Test
    public void testImportClient1_NullData_BadRequest() throws Exception {
        // Perform the POST request with null data
        mockMvc.perform(post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content((String) null))
                .andExpect(status().isBadRequest());
        // Add more assertions as needed based on the expected behavior
    }

    @Test
    public void testImportClient1_InvalidData_BadRequest() throws Exception {
        // Sample JSON data with invalid format to trigger an exception
        String invalidData = "invalid_json_data";

        // Perform the POST request with invalid data
        mockMvc.perform(post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content(invalidData))
                .andExpect(status().isBadRequest());
        // Add more assertions as needed based on the expected behavior
    }

    // Add more test cases as needed to cover different scenarios and edge cases
}


//
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.gson.Gson;
import com.google.json.JsonSanitizer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(ImportClientController.class)
@ContextConfiguration(classes = {ImportClientController.class})
public class ImportClientControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private Gson gson;

    @Autowired
    private ObjectMapper objectMapper;

    private String sampleJsonData;

    @BeforeEach
    public void setUp() {
        // Initialize sample JSON data for testing
        sampleJsonData = "{\"client\": {\"name\": \"John Doe\"}, \"inspection\": \"some data\"}";
    }

    @Test
    public void testImportClient1_Success() throws Exception {
        // Remove the "inspection" field from the JSON string
        JsonNode rootNode = objectMapper.readTree(sampleJsonData);
        ((ObjectNode) rootNode).remove("inspection");
        String jsonDataWithoutInspection = rootNode.toString();

        String sanitizedData = JsonSanitizer.sanitize(jsonDataWithoutInspection);

        ImportClientRequest expectedRequest = objectMapper.readValue(sanitizedData, ImportClientRequest.class);

        // Perform the actual API call
        mockMvc.perform(MockMvcRequestBuilders.post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content(sampleJsonData))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$.client.name").value(expectedRequest.getClient().getName()));
    }

    @Test
    public void testImportClient1_NullData() throws Exception {
        // Perform the API call with null JSON data
        mockMvc.perform(MockMvcRequestBuilders.post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content((String) null))
                .andExpect(status().isBadRequest())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON));
    }

    @Test
    public void testImportClient1_InvalidData() throws Exception {
        // Perform the API call with invalid JSON data
        String invalidData = "Invalid JSON Data";
        mockMvc.perform(MockMvcRequestBuilders.post("/import-client")
                .contentType(MediaType.APPLICATION_JSON)
                .content(invalidData))
                .andExpect(status().isBadRequest())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON));
    }
}




//
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

public class ImportClientControllerTest {

    // Instantiate the actual controller to be tested
    private ImportClientController importClientController = new ImportClientController();

    @Test
    public void testImportClient1() {
        // Sample JSON data for testing
        String jsonData = "{\"client\":{\"name\":\"John Doe\"},\"inspection\":{\"type\":\"some_type\"}}";

        // Perform the test
        ResponseEntity<String> responseEntity = importClientController.importClient1(jsonData);

        // Assertions
        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
        assertNotNull(responseEntity.getBody());

        // Since the JSON sanitization is not being tested here, you can perform some basic checks
        assertFalse(responseEntity.getBody().contains("inspection"));
        assertTrue(responseEntity.getBody().contains("John Doe"));
    }

    @Test
    public void testImportClient1WithNullData() {
        // Test with null JSON data
        ResponseEntity<String> responseEntity = importClientController.importClient1(null);

        // Assertions
        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());
        assertTrue(responseEntity.getBody().contains("JSON Data is null"));
    }

    @Test
    public void testImportClient1WithInvalidData() {
        // Test with invalid JSON data
        String invalidData = "Invalid JSON data";
        ResponseEntity<String> responseEntity = importClientController.importClient1(invalidData);

        // Assertions
        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());
        assertTrue(responseEntity.getBody().contains("Failed to parse JSON"));
    }
}



<!-- JUnit 5 dependencies -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <version>5.8.0</version>
    <scope>test</scope>
</dependency>

//
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import com.google.json.JsonSanitizer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class ImportClientControllerTest {

    private ImportClientController importClientController;
    private Gson gson;
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setUp() {
        gson = new Gson();
        objectMapper = new ObjectMapper();
        importClientController = new ImportClientController(gson, objectMapper);
    }

    @Test
    public void testImportClient1_Success() throws Exception {
        // Given
        ImportClientRequest request = new ImportClientRequest();
        // Set up your request data here

        String jsonData = gson.toJson(request);

        // When
        ResponseEntity<String> response = importClientController.importClient1(jsonData);

        // Then
        assertEquals(HttpStatus.OK, response.getStatusCode());
        // Add more assertions to verify the response content
    }

    @Test
    public void testImportClient1_NullData() {
        // Given
        String jsonData = null;

        // When
        ResponseEntity<String> response = importClientController.importClient1(jsonData);

        // Then
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        // Add more assertions to verify the response content
    }

    @Test
    public void testImportClient1_Exception() {
        // Given
        String jsonData = "invalid_json"; // Invalid JSON data

        // When
        ResponseEntity<String> response = importClientController.importClient1(jsonData);

        // Then
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        // Add more assertions to verify the response content
    }
}

//////////////////////
package uk.co.allianz.rap.lc.rest;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.google.gson.Gson;
import com.google.json.JsonSanitizer;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;

@Slf4j
@RestController
public class ImportClientController {

    @Autowired
    private Gson gson;

    @Autowired
    private ObjectMapper objectMapper;

    //Extracting fields and data from the "data model" sent from loss-control-adapter
    //and building the API request: ImportClient
    @PostMapping("/import-client")
    public ResponseEntity<String> importClient1(@RequestBody String jsonData) {
        try {
            if (jsonData == null) {
                throw new IllegalArgumentException("JSON Data is null");
            }

            // Remove the "inspection" field from the JSON string
            JsonNode rootNode = new ObjectMapper().readTree(jsonData);
            ((ObjectNode) rootNode).remove("inspection");
            String jsonDataWithoutInspection = rootNode.toString();

            String sanitizedData = JsonSanitizer.sanitize(jsonDataWithoutInspection);

            ImportClientRequest importClientRequest = objectMapper.readValue(sanitizedData, ImportClientRequest.class);

            // access the data using the POJO classes
            log.info("Client Name:" + importClientRequest.getClient().getName());


            String processedJson = gson.toJson(importClientRequest);
            return ResponseEntity.ok(processedJson);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }
}

......................

//Added 2 Location and inspection

{
    "inspection":{
        "PolicyNumber":"1"
    },
    "divisionLookupID": "AZ_UK",
    "client": {
        "LookupID": "27105",
        "ContactFirstName": "Client Contact First Name",
        "ContactLastName": "Client Contact Last Name",
        "PolicyNumber": "AS-86587667",
        "Name": "MW Ultan Client Name",
        "Phone": "client Phone",
        "Email": "email@client.com",
        "Address": {
            "Country": "GB",
            "OverseasTerritories": "England",
            "Street1": "C.A. street 1",
            "Street2": "C.A street 2",
            "City": "C.A. City",
            "Region1": "C.A. region1",
            "Region2": "C.A. region2",
            "Region3": "C.A. region3",
            "Region4": "C.A. region4",
            "ZipCode": "C.A. Post Code"
        },
        "Agent": {
            "AgencyCode": "12345678",
            "AgencyName": "MW Ultan Agent 2",
            "AgentCode": "1234",
            "AgentName": "MW Ultan The Only Agent",
            "Email": "ultan@agency.com",
            "FaxNumber": "004416107890",
            "PhoneNumber": "0044316107892",
            "Address": {
                "Country": "GB",
                "Street1": "Agent Street1",
                "Street2": "Agent Street2",
                "City": "Norwich",
                "Region1": "Region1",
                "Region2": "Region2",
                "Region3": "Region3",
                "Region4": "Region4",
                "ZipCode": "PostCode"
            },
            "AgentType": "Broker"
        },
        "Underwriter": {
            "Company": "MW Underwriter company",
            "Email": "ultan@underwriter.com",
            "FirstName": "Underwriter-Ultan",
            "LastName": "Underwriter-McPadden",
            "PhoneNumber": "00441234567",
            "UnderwriterCode": "12345"
        },
        "Locations": [
            {
                "LookupID": "29647",
                "Name": "MW LocationTestUltan API New",
                "PolicyNumber": "API9876567",
                "PolicyEffectiveDate": "2023-03-28T15:08:58.889075+01:00",
                "PolicyExpirationDate": "2023-03-28T15:08:58.889075+01:00",
                "PolicyRenewalDate": "2023-03-28T15:08:58.889075+01:00",
                "Address": {
                    "Country": "GB",
                    "Street1": "L.A. street 1",
                    "Street2": "L.A. street 2",
                    "City": "London",
                    "Region1": "L.A Region1",
                    "Region2": "L.A Region2",
                    "Region3": "L.A Region3",
                    "Region4": "L.A Region4",
                    "ZipCode": "L.A PostCode"
                },
                "OriginalEffectiveDate": "2023-03-28T15:08:58.8820749+01:00",
                "EffectiveDate": "2023-03-28T15:08:58.8820749+01:00",
                "ExpirationDate": "2023-03-28T15:08:58.8820749+01:00",
                "RenewalDate": "2023-03-28T15:08:58.8820749+01:00",
                "LastInspectedDate": "2023-03-28T15:08:58.8820749+01:00",
                "genericFields": [
                    {
                        "key": "0.ISIC+Code",
                        "text": "",
                        "genericFieldValueType": 0
                    }
                ],
                "Coverages": [
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "GenericFields": [
                            {
                                "Number": "50000",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "40000",
                                "Key": "02. PD Content",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "30000",
                                "Key": "03. Stock & Supply",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "20000",
                                "Key": "04. PD Other",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Text": "Machinary",
                                "Key": "05. PD Other Description",
                                "GenericFieldValueType": 0
                            },
                            {
                                "Number": "140000",
                                "Key": "06. TIV PD",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "10000",
                                "Key": "07. TIV BI",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "12",
                                "Key": "08. BI Base Period (Months)",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "150000",
                                "Key": "09. TIV (PD + BI )",
                                "GenericFieldValueType": 1
                            }
                        ]
                    },
                    {
                        "CoverageTypeLookup": "CC_LIAB",
                        "GenericFields": [
                            {
                                "Number": "5000",
                                "Key": "Limit of Liability",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "10",
                                "Key": "Number of Employees",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "5000",
                                "Key": "Total Turnover",
                                "GenericFieldValueType": 1
                            }
                        ]
                    }
                ],
                "Contact": {
                    "CellPhone": "L. Contact Cellphone",
                    "CompanyName": "L. Contact CompanyName",
                    "Email": "L. Contact Email",
                    "FirstName": "L. Contact First Name",
                    "HomePhone": "L. Contact HomePhone",
                    "LastName": "L. Contact LastName",
                    "Occupation": "L. Contact Occupation",
                    "UseCompanyName": true,
                    "WorkPhone": "L. Contact WorkPhone",
                    "Location": "L. Contact Location"
                }
            },
            // Add one more location here
            {
                "LookupID": "12345",
                "Name": "MW Second Location",
                "PolicyNumber": "API9876568",
                "PolicyEffectiveDate": "2023-03-29T15:08:58.889075+01:00",
                "PolicyExpirationDate": "2023-03-29T15:08:58.889075+01:00",
                "PolicyRenewalDate": "2023-03-29T15:08:58.889075+01:00",
                "Address": {
                    "Country": "GB",
                    "Street1": "Second street 1",
                    "Street2": "Second street 2",
                    "City": "London",
                    "Region1": "Second Region1",
                    "Region2": "Second Region2",
                    "Region3": "Second Region3",
                    "Region4": "Second Region4",
                    "ZipCode": "Second PostCode"
                },
                "OriginalEffectiveDate": "2023-03-29T15:08:58.8820749+01:00",
                "EffectiveDate": "2023-03-29T15:08:58.8820749+01:00",
                "ExpirationDate": "2023-03-29T15:08:58.8820749+01:00",
                "RenewalDate": "2023-03-29T15:08:58.8820749+01:00",
                "LastInspectedDate": "2023-03-29T15:08:58.8820749+01:00",
                "genericFields": [
                    {
                        "key": "0.ISIC+Code",
                        "text": "",
                        "genericFieldValueType": 0
                    }
                ],
                "Coverages": [
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "GenericFields": [
                            {
                                "Number": "50000",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1
                            }
                            // ... other fields
                        ]
                    }
                    // Add other coverages if needed
                ],
                "Contact": {
                    "CellPhone": "Second Contact Cellphone"
                    // ... other fields
                }
            }
        ]
    }
}


//////////////////////////////////
{
  "divisionLookupID" : "AZ_UK",
  "client" : {
    "LookupID" : "C008032993",
    "ContactFirstName" : null,
    "ContactLastName" : null,
    "PolicyNumber" : "SP26853148",
    "Name" : "CLIENT NEW BR",
    "Phone" : null,
    "Email" : null,
    "Address" : {
      "Country" : "United Kingdom",
      "OverseasTerritories" : null,
      "Street1" : null,
      "Street2" : null,
      "City" : null,
      "Region1" : null,
      "Region2" : null,
      "Region3" : null,
      "Region4" : null,
      "ZipCode" : null
    },
    "Agent" : {
      "AgencyCode" : "22576",
      "AgencyName" : "Arthur J. Gallagher",
      "AgentCode" : "13332",
      "AgentName" : null,
      "Email" : null,
      "FaxNumber" : null,
      "PhoneNumber" : null,
      "Address" : {
        "Country" : "United Kingdom",
        "OverseasTerritories" : null,
        "Street1" : null,
        "Street2" : null,
        "City" : null,
        "Region1" : null,
        "Region2" : null,
        "Region3" : null,
        "Region4" : null,
        "ZipCode" : null
      },
      "AgentType" : "Broker"
    },
    "Underwriter" : null,
    "Locations" : [ {
      "genericFields" : null,
      "LookupID" : "",
      "Name" : null,
      "PolicyNumber" : "SP26853148",
      "PolicyEffectiveDate" : null,
      "PolicyExpirationDate" : null,
      "PolicyRenewalDate" : null,
      "Address" : {
        "Country" : "United Kingdom",
        "OverseasTerritories" : null,
        "Street1" : "NEW CROSS DEWEL",
        "Street2" : "SD 11 JEW TOWN",
        "City" : "MM KEMSTONE",
        "Region1" : "UK",
        "Region2" : null,
        "Region3" : null,
        "Region4" : null,
        "ZipCode" : "GU1 1DB"
      },
      "OriginalEffectiveDate" : null,
      "EffectiveDate" : null,
      "ExpirationDate" : null,
      "RenewalDate" : "2024-07-17",
      "LastInspectedDate" : null,
      "Coverages" : [ {
        "CoverageTypeLookup" : "PD_TIV",
        "CoverageReference" : "Coverage 1",
        "GenericFields" : [ {
          "Number" : "1123",
          "Key" : "01. PD Building",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "0",
          "Key" : "04. PD Other",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : null,
          "Key" : "05. PD Other Description",
          "GenericFieldValueType" : 0,
          "Text" : ""
        }, {
          "Number" : "1123",
          "Key" : "06. TIV PD",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "332198",
          "Key" : "07. TIV BI",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "",
          "Key" : "08. BI Base Period (Months)",
          "GenericFieldValueType" : 1,
          "Text" : null
        }, {
          "Number" : "332198",
          "Key" : "09. TIV (PD + BI )",
          "GenericFieldValueType" : 1,
          "Text" : null
        } ]
      } ],
      "Contact" : null
    } ]
  }
}




public class GenericField{
    public String key;
    public String text;
    public int genericFieldValueType;
}



public class Location{
    @JsonProperty("LookupID") 
    public String lookupID;
    @JsonProperty("Name") 
    public String name;
    @JsonProperty("PolicyNumber") 
    public String policyNumber;
    @JsonProperty("PolicyEffectiveDate") 
    public Date policyEffectiveDate;
    @JsonProperty("PolicyExpirationDate") 
    public Date policyExpirationDate;
    @JsonProperty("PolicyRenewalDate") 
    public Date policyRenewalDate;
    @JsonProperty("Address") 
    public Address address;
    @JsonProperty("OriginalEffectiveDate") 
    public Date originalEffectiveDate;
    @JsonProperty("EffectiveDate") 
    public Date effectiveDate;
    @JsonProperty("ExpirationDate") 
    public Date expirationDate;
    @JsonProperty("RenewalDate") 
    public Date renewalDate;
    @JsonProperty("LastInspectedDate") 
    public Date lastInspectedDate;
    public ArrayList<GenericField> genericFields;
    @JsonProperty("Coverages") 
    public ArrayList<Coverage> coverages;
    @JsonProperty("Contact") 
    public Contact contact;
}



................
{
    "divisionLookupID": "AZ_UK",
    "client": {
        "LookupID": "27105",
        "ContactFirstName": "Client Contact First Name",
        "ContactLastName": "Client Contact Last Name",
        "PolicyNumber": "AS-86587667",
        "Name": "MW Ultan Client Name",
        "Phone": "client Phone",
        "Email": "email@client.com",
        "Address": {
            "Country": "GB",
            "OverseasTerritories": "England",
            "Street1": "C.A. street 1",
            "Street2": "C.A street 2",
            "City": "C.A. City",
            "Region1": "C.A. region1",
            "Region2": "C.A. region2",
            "Region3": "C.A. region3",
            "Region4": "C.A. region4",
            "ZipCode": "C.A. Post Code"
        },
        "Agent": {
            "AgencyCode": "12345678",
            "AgencyName": "MW Ultan Agent 2",
            "AgentCode": "1234",
            "AgentName": "MW Ultan The Only Agent",
            "Email": "ultan@agency.com",
            "FaxNumber": "004416107890",
            "PhoneNumber": "0044316107892",
            "Address": {
                "Country": "GB",
                "Street1": "Agent Street1",
                "Street2": "Agent Street2",
                "City": "Norwich",
                "Region1": "Region1",
                "Region2": "Region2",
                "Region3": "Region3",
                "Region4": "Region4",
                "ZipCode": "PostCode"
            },
            "AgentType": "Broker"
        },
        "Underwriter": {
            "Company": "MW Underwriter company",
            "Email": "ultan@underwriter.com",
            "FirstName": "Underwriter-Ultan",
            "LastName": "Underwriter-McPadden",
            "PhoneNumber": "00441234567",
            "UnderwriterCode": "12345"
        },
        "Locations": [
            {
                "LookupID": "29647",
                "Name": "MW LocationTestUltan API New",
                "PolicyNumber": "API9876567",
                "PolicyEffectiveDate": "2023-03-28T15:08:58.889075+01:00",
                "PolicyExpirationDate": "2023-03-28T15:08:58.889075+01:00",
                "PolicyRenewalDate": "2023-03-28T15:08:58.889075+01:00",
                "Address": {
                    "Country": "GB",
                    "Street1": "L.A. street 1",
                    "Street2": "L.A. street 2",
                    "City": "London",
                    "Region1": "L.A Region1",
                    "Region2": "L.A Region2",
                    "Region3": "L.A Region3",
                    "Region4": "L.A Region4",
                    "ZipCode": "L.A PostCode"
                },
                "OriginalEffectiveDate": "2023-03-28T15:08:58.8820749+01:00",
                "EffectiveDate": "2023-03-28T15:08:58.8820749+01:00",
                "ExpirationDate": "2023-03-28T15:08:58.8820749+01:00",
                "RenewalDate": "2023-03-28T15:08:58.8820749+01:00",
                "LastInspectedDate": "2023-03-28T15:08:58.8820749+01:00",
                "genericFields": [
                    {
                        "key": "0.ISIC+Code",
                        "text": "",
                        "genericFieldValueType": 0
                    }
                ],
                "Coverages": [
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "GenericFields": [
                            {
                                "Number": "50000",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "40000",
                                "Key": "02. PD Content",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "30000",
                                "Key": "03. Stock & Supply",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "20000",
                                "Key": "04. PD Other",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Text": "Machinary",
                                "Key": "05. PD Other Description",
                                "GenericFieldValueType": 0
                            },
                            {
                                "Number": "140000",
                                "Key": "06. TIV PD",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "10000",
                                "Key": "07. TIV BI",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "12",
                                "Key": "08. BI Base Period (Months)",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "150000",
                                "Key": "09. TIV (PD + BI )",
                                "GenericFieldValueType": 1
                            }
                        ]
                    },
                    {
                        "CoverageTypeLookup": "CC_LIAB",
                        "GenericFields": [
                            {
                                "Number": "5000",
                                "Key": "Limit of Liability",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "10",
                                "Key": "Number of Employees",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "5000",
                                "Key": "Total Turnover",
                                "GenericFieldValueType": 1
                            }
                        ]
                    }
                ],
                "Contact": {
                    "CellPhone": "L. Contact Cellphone",
                    "CompanyName": "L. Contact CompanyName",
                    "Email": "L. Contact Email",
                    "FirstName": "L. Contact First Name",
                    "HomePhone": "L. Contact HomePhone",
                    "LastName": "L. Contact LastName",
                    "Occupation": "L. Contact Occupation",
                    "UseCompanyName": true,
                    "WorkPhone": "L. Contact WorkPhone",
                    "Location": "L. Contact Location"
                }
            }
        ]
    }
}






...............................................................................................................................
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import com.google.gson.JsonObject;

@RestController
public class DataController {

	private final DataService dataService;
	private final Gson gson;
	private final ObjectMapper objectMapper;

	@Autowired
	public DataController(DataService dataService, Gson gson, ObjectMapper objectMapper) {
		this.dataService = dataService;
		this.gson = gson;
		this.objectMapper = objectMapper;

	}
	@PostMapping("/client")
    public ResponseEntity<String> processData1(@RequestBody String jsonData) {
        try {
            if (jsonData == null) {
                throw new IllegalArgumentException("JSON Data Can't be null");
            }
            List<JsonObject> processedData = dataService.processJsonData(jsonData);
            String processedJson = gson.toJson(processedData);

            // Deserialize JSON into ImportClientRequest objects
            ImportClientRequest[] importClientRequests = objectMapper.readValue(processedJson,
                    ImportClientRequest[].class);

            // Now you have the data in Java objects, and you can work with it as needed
            for (ImportClientRequest importClientRequest : importClientRequests) {
                // Access data from each ImportClientRequest object
                String divisionLookupID = importClientRequest.getDivisionLookupID();
                Client client = importClientRequest.getClient();
                // ... and so on

                System.out.println("DivisionLookupID: " + divisionLookupID);
                if (client != null) {
                    System.out.println("Client LookupID: " + client.getLookupID());
                    System.out.println("Client PolicyNumber: " + client.getPolicyNumber());
                    System.out.println("Client PolicyName: " + client.getName());

                    Address address = client.getAddress();
                    if (address != null) {
                        System.out.println("Address country: " + address.getCountry());
                        // Access other address fields as needed
                    }

                    Agent agent = client.getAgent();
                    if (agent != null) {
                        System.out.println("AgencyCode: " + agent.getAgencyCode());
                        System.out.println("AgencyName: " + agent.getAgencyName());
                        System.out.println("AgentCode: " + agent.getAgentCode());
                        // Access other agent fields as needed
                    }

                    List<Location> locationsList = client.getLocations();
                    for (Location location : locationsList) {
                        System.out.println("RenewalDate: " + location.getRenewalDate());
                        // Access other location fields as needed
                    }
                }
            }

            return ResponseEntity.ok("JSON data processed successfully.");
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

	@PostMapping("/data")
	public ResponseEntity<String> processData(@RequestBody String jsonData) {
		try {

			if (jsonData == null) {
				throw new IllegalArgumentException("JSON Data Can't be null");
			}
			List<JsonObject> processedData = dataService.processJsonData(jsonData);
			String processedJson = gson.toJson(processedData);
			return ResponseEntity.ok(processedJson);
		} catch (IllegalArgumentException e) {
			return ResponseEntity.badRequest().body(e.getMessage());
		}
	}
}




[ {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "BS",
  "inspections.0.Mailing.Country" : "RR",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP22677819",
  "inspections.0.Mailing.Street1" : "C012682006",
  "inspections.0.PolicyHolder.CompanyName" : "tBh mMgw uouC qwpASux",
  "inspections.0.Agent.AgentCode" : "100 pBlyGJMnGFiyw",
  "inspections.0.Agent.AgentType" : "qCqvND",
  "inspections.0.Agent.AgencyName" : "qwdewq",
  "inspections.0.Agent.AgencyCode" : "SW1X 7LJ",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "94431",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "13832",
  "inspections.0.CurrencyISO" : "Lockton Companies LLP",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20231231",
  "inspections.0.GenericFields.0.GenericFields" : "872170",
  "divisionLookupID" : "1391199069",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20220128",
  "client.Name" : "Property Damage All Risks Section",
  "client.Address.Country" : "13",
  "client.Agent.AgencyCode" : "12.64",
  "client.Agent.AgencyName" : "20210101",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "6656",
  "client.Agent.Address.Street1" : "1149.6",
  "client.Agent.Address.Street2" : "20190902",
  "client.Agent.Address.City" : "Property Damage All Risks Section",
  "client.Agent.Address.Region1" : "3379",
  "client.Agent.Address.Region2" : "3378.13",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Terrorism - Property Damage",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Contents",
  "client.Locations.0.Address.Street2" : "132531529",
  "client.Locations.0.Address.City" : "3",
  "client.Locations.0.Address.Region1" : "Buildings",
  "client.Locations.0.Address.Region2" : "575700000",
  "client.Locations.0.Address.ZipCode" : "1",
  "client.Locations.0.RenewalDate" : "Global Terrorism - Business Interruption",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "2",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Item Details",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "0",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "3",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Bus. Interrupt."
  }, {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "CS",
  "inspections.0.Mailing.Country" : "PT",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP25496107",
  "inspections.0.Mailing.Street1" : "C006729450",
  "inspections.0.PolicyHolder.CompanyName" : "uvrwMyR mCwwK xsuNHsyE qHg & uvrwMyR mCwwKS qHg y/o uvrwMyR",
  "inspections.0.Agent.AgentCode" : "psqKHDAFDK lsJilwH GJBeHw",
  "inspections.0.Agent.AgentType" : "qCqvND",
  "inspections.0.Agent.AgencyName" : "dasas",
  "inspections.0.Agent.AgencyCode" : "W2 4BH",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS & HOTELIERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "94431",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "13832",
  "inspections.0.CurrencyISO" : "Lockton Companies LLP",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20220101",
  "inspections.0.GenericFields.0.GenericFields" : "3720",
  "divisionLookupID" : "1274250",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20200713",
  "client.Name" : "Property Damage All Risks Section",
  "client.Address.Country" : "0",
  "client.Agent.AgencyCode" : "0",
  "client.Agent.AgencyName" : "20200601",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "3335",
  "client.Agent.Address.Street1" : "390",
  "client.Agent.Address.Street2" : "12334",
  "client.Agent.Address.City" : "ABC",
  "client.Agent.Address.Region1" : "0",
  "client.Agent.Address.Region2" : "0",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Property Damage All Risks Section",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Contents of Flats and Private dwellings as advised",
  "client.Locations.0.Address.Street2" : "312000",
  "client.Locations.0.Address.City" : "1",
  "client.Locations.0.Address.Region1" : "Global Loss of Rent All Risks Section",
  "client.Locations.0.Address.Region2" : "0",
  "client.Locations.0.Address.ZipCode" : "2",
  "client.Locations.0.RenewalDate" : "Item Details",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "3",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Loss of Rent",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "375000",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "2",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Item Details"
  }, {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "RA",
  "inspections.0.Mailing.Country" : "PL",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP29238776",
  "inspections.0.Mailing.Street1" : "C018781222",
  "inspections.0.PolicyHolder.CompanyName" : "MERCANTILE GROUP OF COMPANIES",
  "inspections.0.Agent.AgentCode" : "7  8  7A & 8A QUEENS PARADE",
  "inspections.0.Agent.AgentType" : "SEABURN",
  "inspections.0.Agent.AgencyName" : "SUNDERLAND",
  "inspections.0.Agent.AgencyCode" : "SR6 8DA",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "91115",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "20756",
  "inspections.0.CurrencyISO" : "Howden Insurance Brokers Ltd",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20240120",
  "inspections.0.GenericFields.0.GenericFields" : "123123.33",
  "divisionLookupID" : "678099",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20220302",
  "client.Name" : "Loss of Rent All Risks Section",
  "client.Address.Country" : "4500",
  "client.Agent.AgencyCode" : "13500",
  "client.Agent.AgencyName" : "20220302",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "103653",
  "client.Agent.Address.Street1" : "39247.2",
  "client.Agent.Address.Street2" : "20211127",
  "client.Agent.Address.City" : "Property Damage All Risks Section",
  "client.Agent.Address.Region1" : "80640",
  "client.Agent.Address.Region2" : "28360",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Property Owners Liability Section",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Third Party Prop",
  "client.Locations.0.Address.Street2" : "500",
  "client.Locations.0.Address.City" : "2",
  "client.Locations.0.Address.Region1" : "Wages/Turnover Details",
  "client.Locations.0.Address.Region2" : "0",
  "client.Locations.0.Address.ZipCode" : "1",
  "client.Locations.0.RenewalDate" : "Location Property Damage All Risks Section",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "2",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Item Details",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "0",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "3",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Buildings occupied as Takeaways and     Tyneside f"}, {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "SS",
  "inspections.0.Mailing.Country" : "RR",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP29238776",
  "inspections.0.Mailing.Street1" : "C018781222",
  "inspections.0.PolicyHolder.CompanyName" : "MERCANTILE GROUP OF COMPANIES",
  "inspections.0.Agent.AgentCode" : "4 NEVILLE ROAD",
  "inspections.0.Agent.AgentType" : "PALLION",
  "inspections.0.Agent.AgencyName" : "SUNDERLAND",
  "inspections.0.Agent.AgencyCode" : "SR4 6QT",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "91115",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "20756",
  "inspections.0.CurrencyISO" : "Howden Insurance Brokers Ltd",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20240120",
  "divisionLookupID" : "145512",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20220302",
  "client.Name" : "Loss of Rent All Risks Section",
  "client.Address.Country" : "4500",
  "client.Agent.AgencyCode" : "13500",
  "client.Agent.AgencyName" : "20220302",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "103653",
  "client.Agent.Address.Street1" : "39247.2",
  "client.Agent.Address.Street2" : "20211127",
  "client.Agent.Address.City" : "Property Damage All Risks Section",
  "client.Agent.Address.Region1" : "80640",
  "client.Agent.Address.Region2" : "28360",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Property Owners Liability Section",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Third Party Prop",
  "client.Locations.0.Address.Street2" : "500",
  "client.Locations.0.Address.City" : "2",
  "client.Locations.0.Address.Region1" : "Wages/Turnover Details",
  "client.Locations.0.Address.Region2" : "0",
  "client.Locations.0.Address.ZipCode" : "1",
  "client.Locations.0.RenewalDate" : "Location Property Damage All Risks Section",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "2",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Item Details",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "0",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "3",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Buildings occupied as Barber"
} ]




/////////////////////////////////////////
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
@SuppressWarnings("unused")
public class Underwriter {
    @JsonProperty("Company")
    private String company;
    @JsonProperty("Email")
    private String email;
    @JsonProperty("FirstName")
    private String firstName;
    @JsonProperty("LastName")
    private String lastName;
    @JsonProperty("PhoneNumber")
    private String phoneNumber;
    @JsonProperty("UnderwriterCode")
    private String underwriterCode;
}

..
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
..
import java.util.ArrayList;
import java.util.Date;

@SuppressWarnings("unused")
public class Location {
    @JsonProperty("LookupID")
    private String lookupID;
    @JsonProperty("Name")
    private String name;
    @JsonProperty("PolicyNumber")
    private String policyNumber;
    @JsonProperty("PolicyEffectiveDate")
    private Date policyEffectiveDate;
    @JsonProperty("PolicyExpirationDate")
    private Date policyExpirationDate;
    @JsonProperty("PolicyRenewalDate")
    private Date policyRenewalDate;
    @JsonProperty("Address")
    private Address address;
    @JsonProperty("OriginalEffectiveDate")
    private Date originalEffectiveDate;
    @JsonProperty("EffectiveDate")
    private Date effectiveDate;
    @JsonProperty("ExpirationDate")
    private Date expirationDate;
    @JsonProperty("RenewalDate")
    private Date renewalDate;
    @JsonProperty("LastInspectedDate")
    private Date lastInspectedDate;
    @JsonProperty("genericFields")
    private ArrayList<GenericField> genericFields;
    @JsonProperty("Coverages")
    private ArrayList<Coverage> coverages;
    @JsonProperty("Contact")
    private Contact contact;
}

..
package uk.co.allianz.rap.lc.model.request.importclient;

import lombok.Data;

@SuppressWarnings("unused")
@Data
public class ImportClientRequest {
    private String divisionLookupID;
    private Client client;
}

..
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;

@SuppressWarnings("unused")
public class GenericField2 {
    @JsonProperty("Number")
    private String number;
    @JsonProperty("Key")
    private String key;
    @JsonProperty("GenericFieldValueType")
    private int genericFieldValueType;
    @JsonProperty("Text")
    private String text;
}

..
package uk.co.allianz.rap.lc.model.request.importclient;

import lombok.Data;


@Data
public class GenericField {
    private String key;
    private String text;
    private int genericFieldValueType;
}

..
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.ArrayList;
@SuppressWarnings("unused")
public class Coverage {
    @JsonProperty("CoverageTypeLookup")
    private String coverageTypeLookup;
    @JsonProperty("GenericFields")
    private ArrayList<GenericField2> genericFields;
}


..
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
@SuppressWarnings("unused")
public class Contact {
    @JsonProperty("CellPhone")
    private String cellPhone;
    @JsonProperty("CompanyName")
    private String companyName;
    @JsonProperty("Email")
    private String email;
    @JsonProperty("FirstName")
    private String firstName;
    @JsonProperty("HomePhone")
    private String homePhone;
    @JsonProperty("LastName")
    private String lastName;
    @JsonProperty("Occupation")
    private String occupation;
    @JsonProperty("UseCompanyName")
    private boolean useCompanyName;
    @JsonProperty("WorkPhone")
    private String workPhone;
    @JsonProperty("Location")
    private String location;
}

..
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.ArrayList;
@SuppressWarnings("unused")
public class Client {
    @JsonProperty("LookupID")
    private String lookupID;
    @JsonProperty("ContactFirstName")
    private String contactFirstName;
    @JsonProperty("ContactLastName")
    private String contactLastName;
    @JsonProperty("PolicyNumber")
    private String policyNumber;
    @JsonProperty("Name")
    private String name;
    @JsonProperty("Phone")
    private String phone;
    @JsonProperty("Email")
    private String email;
    @JsonProperty("Address")
    private Address address;
    @JsonProperty("Agent")
    private Agent agent;
    @JsonProperty("Underwriter")
    private Underwriter underwriter;
    @JsonProperty("Locations")
    private ArrayList<Location> locations;
}

...
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;

@SuppressWarnings("unused")
public class Agent {
    @JsonProperty("AgencyCode")
    private String agencyCode;
    @JsonProperty("AgencyName")
    private String agencyName;
    @JsonProperty("AgentCode")
    private String agentCode;
    @JsonProperty("AgentName")
    private String agentName;
    @JsonProperty("Email")
    private String email;
    @JsonProperty("FaxNumber")
    private String faxNumber;
    @JsonProperty("PhoneNumber")
    private String phoneNumber;
    @JsonProperty("Address")
    private Address address;
    @JsonProperty("AgentType")
    private String agentType;
}

...
package uk.co.allianz.rap.lc.model.request.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;

@SuppressWarnings("unused")
public class Address {
    @JsonProperty("Country")
    private String country;
    @JsonProperty("Street1")
    private String street1;
    @JsonProperty("Street2")
    private String street2;
    @JsonProperty("City")
    private String city;
    @JsonProperty("Region1")
    private String region1;
    @JsonProperty("Region2")
    private String region2;
    @JsonProperty("Region3")
    private String region3;
    @JsonProperty("Region4")
    private String region4;
    @JsonProperty("ZipCode")
    private String zipCode;
}





[ {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "BS",
  "inspections.0.Mailing.Country" : "RR",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP22677819",
  "inspections.0.Mailing.Street1" : "C012682006",
  "inspections.0.PolicyHolder.CompanyName" : "tBh mMgw uouC qwpASux",
  "inspections.0.Agent.AgentCode" : "100 pBlyGJMnGFiyw",
  "inspections.0.Agent.AgentType" : "qCqvND",
  "inspections.0.Agent.AgencyName" : "qwdewq",
  "inspections.0.Agent.AgencyCode" : "SW1X 7LJ",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "94431",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "13832",
  "inspections.0.CurrencyISO" : "Lockton Companies LLP",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20231231",
  "inspections.0.GenericFields.0.GenericFields" : "872170",
  "divisionLookupID" : "1391199069",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20220128",
  "client.Name" : "Property Damage All Risks Section",
  "client.Address.Country" : "13",
  "client.Agent.AgencyCode" : "12.64",
  "client.Agent.AgencyName" : "20210101",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "6656",
  "client.Agent.Address.Street1" : "1149.6",
  "client.Agent.Address.Street2" : "20190902",
  "client.Agent.Address.City" : "Property Damage All Risks Section",
  "client.Agent.Address.Region1" : "3379",
  "client.Agent.Address.Region2" : "3378.13",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Terrorism - Property Damage",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Contents",
  "client.Locations.0.Address.Street2" : "132531529",
  "client.Locations.0.Address.City" : "3",
  "client.Locations.0.Address.Region1" : "Buildings",
  "client.Locations.0.Address.Region2" : "575700000",
  "client.Locations.0.Address.ZipCode" : "1",
  "client.Locations.0.RenewalDate" : "Global Terrorism - Business Interruption",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "2",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Item Details",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "0",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "3",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Bus. Interrupt.",
  "client.Locations.0.Coverages.0..GenericFields" : "7500000"
}, {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "CS",
  "inspections.0.Mailing.Country" : "PT",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP25496107",
  "inspections.0.Mailing.Street1" : "C006729450",
  "inspections.0.PolicyHolder.CompanyName" : "uvrwMyR mCwwK xsuNHsyE qHg & uvrwMyR mCwwKS qHg y/o uvrwMyR",
  "inspections.0.Agent.AgentCode" : "psqKHDAFDK lsJilwH GJBeHw",
  "inspections.0.Agent.AgentType" : "qCqvND",
  "inspections.0.Agent.AgencyName" : "dasas",
  "inspections.0.Agent.AgencyCode" : "W2 4BH",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS & HOTELIERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "94431",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "13832",
  "inspections.0.CurrencyISO" : "Lockton Companies LLP",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20220101",
  "inspections.0.GenericFields.0.GenericFields" : "3720",
  "divisionLookupID" : "1274250",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20200713",
  "client.Name" : "Property Damage All Risks Section",
  "client.Address.Country" : "0",
  "client.Agent.AgencyCode" : "0",
  "client.Agent.AgencyName" : "20200601",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "3335",
  "client.Agent.Address.Street1" : "390",
  "client.Agent.Address.Street2" : "12334",
  "client.Agent.Address.City" : "ABC",
  "client.Agent.Address.Region1" : "0",
  "client.Agent.Address.Region2" : "0",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Property Damage All Risks Section",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Contents of Flats and Private dwellings as advised",
  "client.Locations.0.Address.Street2" : "312000",
  "client.Locations.0.Address.City" : "1",
  "client.Locations.0.Address.Region1" : "Global Loss of Rent All Risks Section",
  "client.Locations.0.Address.Region2" : "0",
  "client.Locations.0.Address.ZipCode" : "2",
  "client.Locations.0.RenewalDate" : "Item Details",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "3",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Loss of Rent",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "375000",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "2",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Item Details",
  "client.Locations.0.Coverages.0..GenericFields" : "0"
}, {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "RA",
  "inspections.0.Mailing.Country" : "PL",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP29238776",
  "inspections.0.Mailing.Street1" : "C018781222",
  "inspections.0.PolicyHolder.CompanyName" : "MERCANTILE GROUP OF COMPANIES",
  "inspections.0.Agent.AgentCode" : "7  8  7A & 8A QUEENS PARADE",
  "inspections.0.Agent.AgentType" : "SEABURN",
  "inspections.0.Agent.AgencyName" : "SUNDERLAND",
  "inspections.0.Agent.AgencyCode" : "SR6 8DA",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "91115",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "20756",
  "inspections.0.CurrencyISO" : "Howden Insurance Brokers Ltd",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20240120",
  "inspections.0.GenericFields.0.GenericFields" : "123123.33",
  "divisionLookupID" : "678099",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20220302",
  "client.Name" : "Loss of Rent All Risks Section",
  "client.Address.Country" : "4500",
  "client.Agent.AgencyCode" : "13500",
  "client.Agent.AgencyName" : "20220302",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "103653",
  "client.Agent.Address.Street1" : "39247.2",
  "client.Agent.Address.Street2" : "20211127",
  "client.Agent.Address.City" : "Property Damage All Risks Section",
  "client.Agent.Address.Region1" : "80640",
  "client.Agent.Address.Region2" : "28360",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Property Owners Liability Section",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Third Party Prop",
  "client.Locations.0.Address.Street2" : "500",
  "client.Locations.0.Address.City" : "2",
  "client.Locations.0.Address.Region1" : "Wages/Turnover Details",
  "client.Locations.0.Address.Region2" : "0",
  "client.Locations.0.Address.ZipCode" : "1",
  "client.Locations.0.RenewalDate" : "Location Property Damage All Risks Section",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "2",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Item Details",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "0",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "3",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Buildings occupied as Takeaways and     Tyneside f",
  "client.Locations.0.Coverages.0..GenericFields" : "677599"
}, {
  "inspections.0.PolicyNumber" : "I94788",
  "inspections.0.DivisionLookupID" : "75",
  "inspections.0.InspectionTypeLookupID" : "75",
  "inspections.0.Location.Country" : "SS",
  "inspections.0.Mailing.Country" : "RR",
  "inspections.0.Mailing.City" : "C",
  "inspections.0.Mailing.ZipCode" : "SP29238776",
  "inspections.0.Mailing.Street1" : "C018781222",
  "inspections.0.PolicyHolder.CompanyName" : "MERCANTILE GROUP OF COMPANIES",
  "inspections.0.Agent.AgentCode" : "4 NEVILLE ROAD",
  "inspections.0.Agent.AgentType" : "PALLION",
  "inspections.0.Agent.AgencyName" : "SUNDERLAND",
  "inspections.0.Agent.AgencyCode" : "SR4 6QT",
  "inspections.0.OrderNotes" : "PROPERTY OWNERS",
  "inspections.0.GenericFields.0.Key" : "75",
  "inspections.0.GenericFields.0.Text" : "91115",
  "inspections.0.GenericFields.0.GenericFieldValueType" : "20756",
  "inspections.0.CurrencyISO" : "Howden Insurance Brokers Ltd",
  "inspections.0.ClientInfo.LookupId" : "Y",
  "inspections.0.ClientInfo.LocationInfo.LookupId" : "20240120",
  "inspections.0.GenericFields.0.GenericFields" : "123123.33",
  "divisionLookupID" : "145512",
  "client.LookupID" : "B",
  "client.PolicyNumber" : "20220302",
  "client.Name" : "Loss of Rent All Risks Section",
  "client.Address.Country" : "4500",
  "client.Agent.AgencyCode" : "13500",
  "client.Agent.AgencyName" : "20220302",
  "client.Agent.AgentCode" : "Property Damage All Risks Section",
  "client.Agent.Address.Country" : "103653",
  "client.Agent.Address.Street1" : "39247.2",
  "client.Agent.Address.Street2" : "20211127",
  "client.Agent.Address.City" : "Property Damage All Risks Section",
  "client.Agent.Address.Region1" : "80640",
  "client.Agent.Address.Region2" : "28360",
  "client.Agent.Address.Region3" : "1",
  "client.Agent.Address.Region4" : "Global Property Owners Liability Section",
  "client.Agent.Address.ZipCode" : "0",
  "client.Agent.AgentType" : "2",
  "client.Locations.0.LookupID" : "Item Details",
  "client.Locations.0.PolicyNumber" : "0",
  "client.Locations.0.Address.Country" : "3",
  "client.Locations.0.Address.Street1" : "Third Party Prop",
  "client.Locations.0.Address.Street2" : "500",
  "client.Locations.0.Address.City" : "2",
  "client.Locations.0.Address.Region1" : "Wages/Turnover Details",
  "client.Locations.0.Address.Region2" : "0",
  "client.Locations.0.Address.ZipCode" : "1",
  "client.Locations.0.RenewalDate" : "Location Property Damage All Risks Section",
  "client.Locations.0.Coverages.0.CoverageTypeLookup" : "0",
  "client.Locations.0.Coverages.0.CoverageReference" : "2",
  "client.Locations.0.Coverages.0.GenericFields.1.Number" : "Item Details",
  "client.Locations.0.Coverages.0.GenericFields.1.Key" : "0",
  "client.Locations.0.Coverages.0.GenericFields.1.GenericFieldValueType" : "3",
  "client.Locations.0.Coverages.1.CoverageTypeLookup" : "Buildings occupied as Barber",
  "client.Locations.0.Coverages.0..GenericFields" : "145012"
} ]


/////////////

{
    "divisionLookupID": "AZ_UK",
    "client": {
        "LookupID": "27251",
        "PolicyNumber": "SZ26218858",
        "Name": "alice test new edit EUROSTAMPA UK LIMITED AND UNICORN GRAPHICS LTD AND GILMOUR & DEAN LTD",
        "Address": {
            "Country": "GB" /*Compulsory*/
        },
        "Agent": {
            "AgencyCode": "96686",
            "AgencyName": "D2 Corporate Solutions Ltd",
            "AgentCode": "19747",
            "Address": {/*Compulsory*/},
            "AgentType": "Broker"
        },
        "Locations": [
            {
                "LookupID": "38823",
                "PolicyNumber": "SZ26218858",
                "Address": {
                    "Country": "GB",
                    "Street1": "test 24 CLYDEHOLM ROAD",
                    "Street2": "",
                    "City": "GLASGOW",
                    "Region1": "",
                    "ZipCode": "G14 0QQ"
                },
                "RenewalDate": "2023-03-28T15:08:58.8820749+01:00",
                "Coverages": [
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "CoverageReference":"Coverage 1",
                        "GenericFields": [
                            {
                                "Number": "8124000",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "20713528",
                                "Key": "02. PD Content",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "3500000",
                                "Key": "03. Stock & Supply",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "0",
                                "Key": "04. PD Other",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Text": "",
                                "Key": "05. PD Other Description",
                                "GenericFieldValueType": 0
                            },
                            {    /*This field is the sum of 1,2,3,4*/
                                "Number": "32337528",
                                "Key": "06. TIV PD",
                                "GenericFieldValueType": 1
                            },
                            {    /*Sum of all values in Global Business Section*/
                                "Number": "29000000",
                                "Key": "07. TIV BI",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "12",
                                "Key": "08. BI Base Period (Months)",
                                "GenericFieldValueType": 1
                            },
                            {    /*This field is the sum of 6,7*/
                                "Number": "61337528",
                                "Key": "09. TIV (PD + BI )",
                                "GenericFieldValueType": 1
                            }
                        ]
                    },
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "CoverageReference":"Coverage 2",
                        "GenericFields": [
                            {
                                "Number": "18124000",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "120713528",
                                "Key": "02. PD Content",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "13500000",
                                "Key": "03. Stock & Supply",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "0",
                                "Key": "04. PD Other",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Text": "",
                                "Key": "05. PD Other Description",
                                "GenericFieldValueType": 0
                            },
                            {    /*This field is the sum of 1,2,3,4*/
                                "Number": "132337528",
                                "Key": "06. TIV PD",
                                "GenericFieldValueType": 1
                            },
                            {    /*Sum of all values in Global Business Section*/
                                "Number": "129000000",
                                "Key": "07. TIV BI",
                                "GenericFieldValueType": 1
                            },
                            {
                                "Number": "12",
                                "Key": "08. BI Base Period (Months)",
                                "GenericFieldValueType": 1
                            },
                            {    /*This field is the sum of 6,7*/
                                "Number": "161337528",
                                "Key": "09. TIV (PD + BI )",
                                "GenericFieldValueType": 1
                            }
                        ]
                    }
                ]
            }
        ]
    }
}
