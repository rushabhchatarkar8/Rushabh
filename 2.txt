
///
package uk.co.allianz.rap.lc.dao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Map;

@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    //client methods
    @Override
    public void insertClientId(String client_id) {
        String insert = "insert into client_lookup(client_id) values(?)";
        int update = this.jdbcTemplate.update(insert, client_id);
    }

    @Override
    public void updateLcClientId(String client_id, String lc360_client_id) {
        String update = "update client_lookup set lc360_client_id = ? where client_id = ?";
        this.jdbcTemplate.update(update, lc360_client_id, client_id);
    }

    @Override
    public Map<String, Object> findByClientId(String client_id) {
        String checkClientId = "select * from client_lookup where client_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360ClientID(String client_id) {
        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360ClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    // Locations methods
    @Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}

///
package uk.co.allianz.rap.lc.dao;

import java.util.Map;

public interface LossControlDao {

    //client
    Map<String, Object> findByClientId(String client_id);

    void updateLcClientId(String client_id, String lc360_client_id);

    void insertClientId(String client_id);

    Map<String, Object> findLc360ClientID(String client_id);


    //location
    Map<String, Object> findByLocationId(String location_id);

    void updateLcLocationId(String location_id, String lc360_location_id);

    void insertLocationId(String location_id);

    Map<String, Object> findLc360LocationID(String location_id);

}

//

DAO
//

import com.googlecode.jsonsanitizer.JsonSanitizer;
import com.googlecode.jsonsanitizer.JsonSanitizerException;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.Set;

@Service
public class DataService {

    private final Gson gson;

    public DataService(Gson gson) {
        this.gson = gson;
    }

    public String processJsonData(String jsonData) {
        if (jsonData == null || jsonData.isEmpty()) {
            throw new IllegalArgumentException("JSON data cannot be null or empty");
        }

        try {
            // Deserialize the JSON string into an array of JsonElements
            JsonElement[] elements = gson.fromJson(jsonData, JsonElement[].class);

            // Create a new JSON object
            JsonObject jsonObject = new JsonObject();

            // Set to store encountered fields
            Set<String> encounteredFields = new HashSet<>();

            // Iterate through each element in the array
            for (int i = 0; i < elements.length; i++) {
                JsonObject elementObject = elements[i].getAsJsonObject();

                // Iterate through each key-value pair in the element object
                for (String key : elementObject.keySet()) {
                    // Remove the '.0' from the key and check for uniqueness
                    String cleanedKey = key.replace(".0", "");
                    if (encounteredFields.contains(cleanedKey)) {
                        // Duplicate field encountered, get the existing property value as a JsonArray
                        JsonArray existingArray = jsonObject.getAsJsonArray(cleanedKey);

                        // Get the new property value as a JsonElement
                        JsonElement newValue = elementObject.get(key);

                        // Add the new value to the existing array
                        existingArray.add(newValue);
                    } else {
                        encounteredFields.add(cleanedKey);

                        // Split the key by '.' to get the nested structure
                        String[] keyParts = cleanedKey.split("\\.");

                        JsonObject currentObject = jsonObject;

                        // Create nested JSON objects based on the key structure
                        for (int j = 0; j < keyParts.length - 1; j++) {
                            String keyPart = keyParts[j];
                            if (!currentObject.has(keyPart)) {
                                JsonObject nestedObject = new JsonObject();
                                currentObject.add(keyPart, nestedObject);
                                currentObject = nestedObject;
                            } else {
                                currentObject = currentObject.getAsJsonObject(keyPart);
                            }
                        }

                        // Get the value as a JsonElement
                        JsonElement valueElement = elementObject.get(key);

                        // Check if the value is already an array
                        if (valueElement instanceof JsonArray) {
                            // Value is an array, add it directly to the current object
                            currentObject.add(keyParts[keyParts.length - 1], valueElement);
                        } else {
                            // Value is not an array, create a new array and add the value to it
                            JsonArray newArray = new JsonArray();
                            newArray.add(valueElement);
                            currentObject.add(keyParts[keyParts.length - 1], newArray);
                        }
                    }
                }
            }

            // Convert the JSON object to a JSON string
            String processedData = gson.toJson(jsonObject);

            // Sanitize the processed JSON data
            String sanitizedData = JsonSanitizer.sanitize(processedData);

            // Return the sanitized JSON data
            return sanitizedData;

        } catch (JsonSanitizerException e) {
            throw new IllegalArgumentException("Invalid JSON data");
        }
    }
}
