import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.Mockito.*;

class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;
    @Mock
    private LossControlDao lossControlDao;
    @Mock
    private LossControlServiceImpl lossControlServiceImpl;
    @Mock
    private ObjectMapper objectMapper;

    private ImportClientServiceImp importClientService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        importClientService = new ImportClientServiceImp();
        importClientService.setTokenCache(tokenCache);
        importClientService.setLossControlDao(lossControlDao);
        importClientService.setLossControlServiceImpl(lossControlServiceImpl);
        importClientService.setObjectMapper(objectMapper);
    }

    // Rest of your test methods...
}

/////
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;
    @Mock
    private LossControlDao lossControlDao;
    @Mock
    private LossControlServiceImpl lossControlServiceImpl;
    @Mock
    private ObjectMapper objectMapper;

    private ImportClientServiceImp importClientService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        importClientService = new ImportClientServiceImp(tokenCache, lossControlDao, lossControlServiceImpl, objectMapper);
    }

    @Test
    void testImportClientClientExists() throws CustomException, JsonProcessingException {
        // Mocking
String json = "{\"client\": {" +
              "\"lookupID\": \"client123\"," +
              "\"locations\": [{" +
                  "\"lookupID\": \"location123\"," +
                  "\"policyNumber\": \"policy123\"" +
              "}]" +
          "}}";



 //       String json = "{\"client\": { ... }}";
        String correlationId = "123456";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("client123");
        importClientRequest.setClient(client);
        Location location = new Location();
        location.setLookupID("location123");
        location.setPolicyNumber("policy123");
        ArrayList<Location> locations = new ArrayList<>(Collections.singletonList(location));
        importClientRequest.getClient().setLocations(locations);

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("client123")).thenReturn(new HashMap<>());
        when(lossControlDao.findLc360ClientID("client123")).thenReturn(new HashMap<>());
        when(lossControlDao.findLc360LocationID("location123+policy123")).thenReturn(new HashMap<>());

        // Test
        ImportClientResponse result = importClientService.importClient(json, correlationId);

        // Assertions and verifications
        assertNotNull(result);
        verify(lossControlDao, never()).insertClientId(any());
        verify(lossControlDao, never()).insertLocationId(any());
        verify(lossControlServiceImpl).clientPost(importClientRequest, null);
        verify(lossControlDao, never()).updateLcClientId(any(), any());
        verify(lossControlDao, never()).updateLcLocationId(any(), any());
    }

    @Test
    void testImportClientClientDoesNotExist() throws CustomException, JsonProcessingException {
        // Mocking
        String json = "{\"client\": { ... }}";
        String correlationId = "123456";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("client123");
        importClientRequest.setClient(client);
        Location location = new Location();
        location.setLookupID("location123");
        location.setPolicyNumber("policy123");
        ArrayList<Location> locations = new ArrayList<>(Collections.singletonList(location));
        importClientRequest.getClient().setLocations(locations);
        ImportClientResponse importClientResponse = new ImportClientResponse();

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId("client123")).thenReturn(null);
        when(lossControlServiceImpl.clientPost(importClientRequest, null)).thenReturn(importClientResponse);

        // Test
        ImportClientResponse result = importClientService.importClient(json, correlationId);

        // Assertions and verifications
        assertNotNull(result);
        verify(lossControlDao).insertClientId("client123");
        verify(lossControlDao).insertLocationId("location123+policy123");
        verify(lossControlServiceImpl).clientPost(importClientRequest, null);
        verify(lossControlDao).updateLcClientId("client123", null);
        verify(lossControlDao).updateLcLocationId("location123+policy123", null);
    }
}


///////////

Mockito.when(jdbcTemplate.queryForMap(anyString(), any())).thenThrow(EmptyResultDataAccessException.class);
        Map<String, Object> result = dao.findLc360LocationID("111");
        Assertions.assertNull(result);
        Mockito.verify(jdbcTemplate).queryForMap(eq("select lc360_location_id from location_lookup where location_id = ? "), eq("111"));


client.setLocations(Collections.singletonList(location));


import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class ImportClientServiceImpTest {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testImportClientExistingClient() throws CustomException {
        String json = "{\"client\": { ... }}";
        String correlationId = "123456";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        importClientRequest.setClient(new ImportClientRequest.Client());
        Location location = new Location();
        location.setLookupID("location123");
        location.setPolicyNumber("policy123");
        importClientRequest.getClient().setLocations(Collections.singletonList(location));

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId(anyString())).thenReturn(new HashMap<>());
        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(new HashMap<>());
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(new HashMap<>());
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(new ImportClientResponse());

        ImportClientResponse response = importClientService.importClient(json, correlationId);

        assertNotNull(response);
        verify(lossControlDao, times(1)).findLc360LocationID("location123+policy123");
    }

    @Test
    void testImportClientNewClientAndLocation() throws CustomException {
        String json = "{\"client\": { ... }}";
        String correlationId = "123456";
        ImportClientRequest importClientRequest = new ImportClientRequest();
        importClientRequest.setClient(new ImportClientRequest.Client());
        Location location = new Location();
        location.setLookupID("location123");
        location.setPolicyNumber("policy123");
        importClientRequest.getClient().setLocations(Collections.singletonList(location));

        when(objectMapper.readValue(json, ImportClientRequest.class)).thenReturn(importClientRequest);
        when(lossControlDao.findByClientId(anyString())).thenReturn(null);
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(new ImportClientResponse());

        ImportClientResponse response = importClientService.importClient(json, correlationId);

        assertNotNull(response);
        verify(lossControlDao, times(1)).insertClientId(anyString());
        verify(lossControlDao, times(1)).insertLocationId("location123+policy123");
        verify(lossControlDao, times(1)).updateLcClientId(anyString(), anyString());
        verify(lossControlDao, times(1)).updateLcLocationId(eq("location123+policy123"), anyString());
    }
}

/////
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.springframework.boot.test.context.SpringBootTest;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.Collections;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@SpringBootTest
class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    private ObjectMapper objectMapper = new ObjectMapper();

    private ImportClientServiceImp importClientService;

    @BeforeEach
    void setUp() {
        importClientService = new ImportClientServiceImp();
        importClientService.tokenCache = tokenCache;
        importClientService.lossControlDao = lossControlDao;
        importClientService.lossControlServiceImpl = lossControlServiceImpl;
        importClientService.objectMapper = objectMapper;
    }

    @Test
    void testImportClientClientExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("123");
        request.setClient(client);
        String json = objectMapper.writeValueAsString(request);

        when(lossControlDao.findByClientId("123")).thenReturn(Collections.singletonMap("client_id", "123"));

        ImportClientResponse response = importClientService.importClient(json, "correlationId");

        assertNotNull(response);
        // Add more assertions as needed
    }

    @Test
    void testImportClientClientNotExists() throws CustomException, JsonProcessingException {
        ImportClientRequest request = new ImportClientRequest();
        Client client = new Client();
        client.setLookupID("123");
        Location location = new Location();
        location.setLookupID("456");
        location.setPolicyNumber("789");
        client.setLocations(Collections.singletonList(location));
        request.setClient(client);
        String json = objectMapper.writeValueAsString(request);

        when(lossControlDao.findByClientId("123")).thenReturn(null);
        when(lossControlDao.findLc360ClientID("123")).thenReturn(Collections.singletonMap("lc360_client_id", "lc123"));
        when(lossControlDao.findLc360LocationID("456+789")).thenReturn(Collections.singletonMap("lc360_location_id", "loc123"));

        ImportClientResponse response = new ImportClientResponse(); // Set your response data
        when(lossControlServiceImpl.clientPost(any(), any())).thenReturn(response);

        ImportClientResponse result = importClientService.importClient(json, "correlationId");

        assertNotNull(result);
        // Add more assertions as needed
    }
}

////
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.boot.test.context.SpringBootTest;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@SpringBootTest
class ImportClientServiceImpTest {

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlService;

    private ImportClientServiceImp importClientService;

    private ObjectMapper objectMapper = new ObjectMapper();

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        importClientService = new ImportClientServiceImp(tokenCache, lossControlDao, lossControlService, objectMapper);
    }

    @Test
    void testImportClient_ClientExists_LC360ClientIdExists() throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = new ImportClientRequest(); // Create a valid request
        importClientRequest.getClient().setLookupID("client123");

        when(lossControlDao.findByClientId("client123")).thenReturn(new HashMap<>()); // Simulate client exists
        when(lossControlDao.findLc360ClientID("client123")).thenReturn(createLc360ClientIdResult());
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(createLc360LocationIdResult());

        ImportClientResponse importClientResponse = importClientService.importClient(objectMapper.writeValueAsString(importClientRequest), "correlation123");

        assertNotNull(importClientResponse);
        // Add more assertions as needed
    }

    @Test
    void testImportClient_ClientDoesNotExist() throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = new ImportClientRequest(); // Create a valid request
        importClientRequest.getClient().setLookupID("client123");

        when(lossControlDao.findByClientId("client123")).thenReturn(null); // Simulate client doesn't exist
        when(lossControlDao.findLc360LocationID(anyString())).thenReturn(createLc360LocationIdResult());
        when(lossControlService.clientPost(any(), any())).thenReturn(createSampleImportClientResponse());
        
        // Simulate returned data from the service call
        when(lossControlService.clientPost(any(), any())).thenReturn(createSampleImportClientResponse());
        when(lossControlDao.findLc360ClientID("client123")).thenReturn(null);
        when(lossControlDao.insertClientId("client123")).thenReturn(1);
        when(lossControlDao.insertLocationId(anyString())).thenReturn(1);
        when(lossControlService.clientPost(any(), any())).thenReturn(createSampleImportClientResponse());
        when(lossControlDao.updateLcClientId(anyString(), anyString())).thenReturn(1);
        when(lossControlDao.updateLcLocationId(anyString(), anyString())).thenReturn(1);

        ImportClientResponse importClientResponse = importClientService.importClient(objectMapper.writeValueAsString(importClientRequest), "correlation123");

        assertNotNull(importClientResponse);
        // Add more assertions as needed
    }

    private Map<String, Object> createLc360ClientIdResult() {
        Map<String, Object> result = new HashMap<>();
        result.put("lc360_client_id", "lc360client123");
        return result;
    }

    private Map<String, Object> createLc360LocationIdResult() {
        Map<String, Object> result = new HashMap<>();
        result.put("lc360_location_id", "lc360location123");
        return result;
    }

    private ImportClientResponse createSampleImportClientResponse() {
        ImportClientResponse response = new ImportClientResponse();
        // Set response data
        return response;
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        //finding client id in DB exist or not
        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {
            //finding LC360 client id in DB exist or not
            Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            //finding LC360 location id in DB exist or not(combined location lookup ID and policy number)
            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            if (lcClientId != null) {
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                //set client id and location id in pojo
                importClientRequest.getClient().setLookupID(lc360ClientId);
                locations.get(0).setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Client and Location are not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            lossControlDao.insertLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
             // Lookup ID Response
            lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber(), locationsResponse.get(0).getLocationLookupID());
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}













///
package uk.co.allianz.rap.lc.dao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Map;

@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    //client methods
    @Override
    public void insertClientId(String client_id) {
        String insert = "insert into client_lookup(client_id) values(?)";
        int update = this.jdbcTemplate.update(insert, client_id);
    }

    @Override
    public void updateLcClientId(String client_id, String lc360_client_id) {
        String update = "update client_lookup set lc360_client_id = ? where client_id = ?";
        this.jdbcTemplate.update(update, lc360_client_id, client_id);
    }

    @Override
    public Map<String, Object> findByClientId(String client_id) {
        String checkClientId = "select * from client_lookup where client_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360ClientID(String client_id) {
        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360ClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    // Locations methods
    @Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}

///
package uk.co.allianz.rap.lc.dao;

import java.util.Map;

public interface LossControlDao {

    //client
    Map<String, Object> findByClientId(String client_id);

    void updateLcClientId(String client_id, String lc360_client_id);

    void insertClientId(String client_id);

    Map<String, Object> findLc360ClientID(String client_id);


    //location
    Map<String, Object> findByLocationId(String location_id);

    void updateLcLocationId(String location_id, String lc360_location_id);

    void insertLocationId(String location_id);

    Map<String, Object> findLc360LocationID(String location_id);

}

//

DAO
//

import com.googlecode.jsonsanitizer.JsonSanitizer;
import com.googlecode.jsonsanitizer.JsonSanitizerException;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.Set;

@Service
public class DataService {

    private final Gson gson;

    public DataService(Gson gson) {
        this.gson = gson;
    }

    public String processJsonData(String jsonData) {
        if (jsonData == null || jsonData.isEmpty()) {
            throw new IllegalArgumentException("JSON data cannot be null or empty");
        }

        try {
            // Deserialize the JSON string into an array of JsonElements
            JsonElement[] elements = gson.fromJson(jsonData, JsonElement[].class);

            // Create a new JSON object
            JsonObject jsonObject = new JsonObject();

            // Set to store encountered fields
            Set<String> encounteredFields = new HashSet<>();

            // Iterate through each element in the array
            for (int i = 0; i < elements.length; i++) {
                JsonObject elementObject = elements[i].getAsJsonObject();

                // Iterate through each key-value pair in the element object
                for (String key : elementObject.keySet()) {
                    // Remove the '.0' from the key and check for uniqueness
                    String cleanedKey = key.replace(".0", "");
                    if (encounteredFields.contains(cleanedKey)) {
                        // Duplicate field encountered, get the existing property value as a JsonArray
                        JsonArray existingArray = jsonObject.getAsJsonArray(cleanedKey);

                        // Get the new property value as a JsonElement
                        JsonElement newValue = elementObject.get(key);

                        // Add the new value to the existing array
                        existingArray.add(newValue);
                    } else {
                        encounteredFields.add(cleanedKey);

                        // Split the key by '.' to get the nested structure
                        String[] keyParts = cleanedKey.split("\\.");

                        JsonObject currentObject = jsonObject;

                        // Create nested JSON objects based on the key structure
                        for (int j = 0; j < keyParts.length - 1; j++) {
                            String keyPart = keyParts[j];
                            if (!currentObject.has(keyPart)) {
                                JsonObject nestedObject = new JsonObject();
                                currentObject.add(keyPart, nestedObject);
                                currentObject = nestedObject;
                            } else {
                                currentObject = currentObject.getAsJsonObject(keyPart);
                            }
                        }

                        // Get the value as a JsonElement
                        JsonElement valueElement = elementObject.get(key);

                        // Check if the value is already an array
                        if (valueElement instanceof JsonArray) {
                            // Value is an array, add it directly to the current object
                            currentObject.add(keyParts[keyParts.length - 1], valueElement);
                        } else {
                            // Value is not an array, create a new array and add the value to it
                            JsonArray newArray = new JsonArray();
                            newArray.add(valueElement);
                            currentObject.add(keyParts[keyParts.length - 1], newArray);
                        }
                    }
                }
            }

            // Convert the JSON object to a JSON string
            String processedData = gson.toJson(jsonObject);

            // Sanitize the processed JSON data
            String sanitizedData = JsonSanitizer.sanitize(processedData);

            // Return the sanitized JSON data
            return sanitizedData;

        } catch (JsonSanitizerException e) {
            throw new IllegalArgumentException("Invalid JSON data");
        }
    }
}
