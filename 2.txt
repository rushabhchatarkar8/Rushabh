package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Slf4j
@Service
public class ImportClientServiceImp implements ImportClientService {

    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;


    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        //finding client id in DB exist or not
        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
        if (clientResult != null) {
            //finding LC360 client id in DB exist or not
            Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
            //finding LC360 location id in DB exist or not(combined location lookup ID and policy number)
            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            if (lcClientId != null) {
                String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                //set client id and location id in pojo
                importClientRequest.getClient().setLookupID(lc360ClientId);
                locations.get(0).setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
                log.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            } else {
                log.info("lc360 location id not present");
            }
        } else {
            log.info("Client and Location are not present");
            lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
            lossControlDao.insertLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber());
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
             // Lookup ID Response
            lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "+" + locations.get(0).getPolicyNumber(), locationsResponse.get(0).getLocationLookupID());
        }
        log.info("importClientResponse Successfully Received");
        return importClientResponse;

    }
}













///
package uk.co.allianz.rap.lc.dao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Map;

@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    //client methods
    @Override
    public void insertClientId(String client_id) {
        String insert = "insert into client_lookup(client_id) values(?)";
        int update = this.jdbcTemplate.update(insert, client_id);
    }

    @Override
    public void updateLcClientId(String client_id, String lc360_client_id) {
        String update = "update client_lookup set lc360_client_id = ? where client_id = ?";
        this.jdbcTemplate.update(update, lc360_client_id, client_id);
    }

    @Override
    public Map<String, Object> findByClientId(String client_id) {
        String checkClientId = "select * from client_lookup where client_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360ClientID(String client_id) {
        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360ClientId, client_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    // Locations methods
    @Override
    public void insertLocationId(String location_id) {
        String insert = "insert into location_lookup(location_id) values(?)";
        int update = this.jdbcTemplate.update(insert, location_id);
    }

    @Override
    public void updateLcLocationId(String location_id, String lc360_location_id) {
        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
        this.jdbcTemplate.update(update, lc360_location_id, location_id);
    }

    @Override
    public Map<String, Object> findByLocationId(String location_id) {
        String checkLocationId = "select * from location_lookup where location_id =?";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(checkLocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }

    @Override
    public Map<String, Object> findLc360LocationID(String location_id) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, location_id);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}

///
package uk.co.allianz.rap.lc.dao;

import java.util.Map;

public interface LossControlDao {

    //client
    Map<String, Object> findByClientId(String client_id);

    void updateLcClientId(String client_id, String lc360_client_id);

    void insertClientId(String client_id);

    Map<String, Object> findLc360ClientID(String client_id);


    //location
    Map<String, Object> findByLocationId(String location_id);

    void updateLcLocationId(String location_id, String lc360_location_id);

    void insertLocationId(String location_id);

    Map<String, Object> findLc360LocationID(String location_id);

}

//

DAO
//

import com.googlecode.jsonsanitizer.JsonSanitizer;
import com.googlecode.jsonsanitizer.JsonSanitizerException;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.Set;

@Service
public class DataService {

    private final Gson gson;

    public DataService(Gson gson) {
        this.gson = gson;
    }

    public String processJsonData(String jsonData) {
        if (jsonData == null || jsonData.isEmpty()) {
            throw new IllegalArgumentException("JSON data cannot be null or empty");
        }

        try {
            // Deserialize the JSON string into an array of JsonElements
            JsonElement[] elements = gson.fromJson(jsonData, JsonElement[].class);

            // Create a new JSON object
            JsonObject jsonObject = new JsonObject();

            // Set to store encountered fields
            Set<String> encounteredFields = new HashSet<>();

            // Iterate through each element in the array
            for (int i = 0; i < elements.length; i++) {
                JsonObject elementObject = elements[i].getAsJsonObject();

                // Iterate through each key-value pair in the element object
                for (String key : elementObject.keySet()) {
                    // Remove the '.0' from the key and check for uniqueness
                    String cleanedKey = key.replace(".0", "");
                    if (encounteredFields.contains(cleanedKey)) {
                        // Duplicate field encountered, get the existing property value as a JsonArray
                        JsonArray existingArray = jsonObject.getAsJsonArray(cleanedKey);

                        // Get the new property value as a JsonElement
                        JsonElement newValue = elementObject.get(key);

                        // Add the new value to the existing array
                        existingArray.add(newValue);
                    } else {
                        encounteredFields.add(cleanedKey);

                        // Split the key by '.' to get the nested structure
                        String[] keyParts = cleanedKey.split("\\.");

                        JsonObject currentObject = jsonObject;

                        // Create nested JSON objects based on the key structure
                        for (int j = 0; j < keyParts.length - 1; j++) {
                            String keyPart = keyParts[j];
                            if (!currentObject.has(keyPart)) {
                                JsonObject nestedObject = new JsonObject();
                                currentObject.add(keyPart, nestedObject);
                                currentObject = nestedObject;
                            } else {
                                currentObject = currentObject.getAsJsonObject(keyPart);
                            }
                        }

                        // Get the value as a JsonElement
                        JsonElement valueElement = elementObject.get(key);

                        // Check if the value is already an array
                        if (valueElement instanceof JsonArray) {
                            // Value is an array, add it directly to the current object
                            currentObject.add(keyParts[keyParts.length - 1], valueElement);
                        } else {
                            // Value is not an array, create a new array and add the value to it
                            JsonArray newArray = new JsonArray();
                            newArray.add(valueElement);
                            currentObject.add(keyParts[keyParts.length - 1], newArray);
                        }
                    }
                }
            }

            // Convert the JSON object to a JSON string
            String processedData = gson.toJson(jsonObject);

            // Sanitize the processed JSON data
            String sanitizedData = JsonSanitizer.sanitize(processedData);

            // Return the sanitized JSON data
            return sanitizedData;

        } catch (JsonSanitizerException e) {
            throw new IllegalArgumentException("Invalid JSON data");
        }
    }
}
