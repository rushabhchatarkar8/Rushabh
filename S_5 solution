import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest3 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(new ArrayList<>());
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_ValidationFailure() {
        String json = "{\"invalidJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation to throw an exception
        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_GeneralException() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response to throw a general exception
        when(importClientServiceImp.importClient(json, correlationId)).thenThrow(new RuntimeException("Import failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}



//////////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest2 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(true);
        mockResponse.setResult(lookupResult);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(false);
        lookupResult.setErrors(new ArrayList<>()); // Simulating errors
        mockResponse.setResult(lookupResult);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }
    
    // Additional test case targeting specific ImportClientResponse scenarios
    @Test
    public void testProcessJson_ImportResponseIsNull() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response to be null
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(null);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertNotNull(response.getBody());
    }
    
    // Additional test case targeting specific Result scenarios
    @Test
    public void testProcessJson_ImportFailureWithErrors() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(false);
        lookupResult.setErrors(new ArrayList<>()); // Simulating errors
        mockResponse.setResult(lookupResult);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}






/////////////////////////////////////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importclient.Result;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest1 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(new ArrayList<>());
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_ValidationFailure() {
        String json = "{\"invalidJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation to throw an exception
        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_GeneralException() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response to throw a general exception
        when(importClientServiceImp.importClient(json, correlationId)).thenThrow(new RuntimeException("Import failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}










////////////////////////////////////
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

public class ValidationRestTest {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(true);
        mockResponse.setResult(lookupResult);

        when(importClientServiceImp.importClient(Mockito.any(), Mockito.any())).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(false);
        lookupResult.setErrors("Import failed");
        mockResponse.setResult(lookupResult);

        when(importClientServiceImp.importClient(Mockito.any(), Mockito.any())).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
    }
}





















if (processedJson != null && processedJson.getResult() != null) {
    if (processedJson.getResult().isSuccess()) {
        // ...
    } else {
        // ...
    }
}






public ArrayList<Location> locationResponse(ArrayList<Location> locations) {
    ArrayList<Location> validLocations = new ArrayList<>();
    
    for (Location location : locations) {
        if (location.getLookupID() != null) {
            validLocations.add(location);
        }
    }
    
    return validLocations;
}



////
public ArrayList<Location> locationResponse(ArrayList<Location> locations) {
    ArrayList<Location> validLocations = new ArrayList<>();

    for (Location location : locations) {
        String lookupID = location.getLookupID();
        System.out.println("LookupID: " + lookupID);

        if (lookupID != null) {
            validLocations.add(location);
        }
    }

    return validLocations;
}










// ... (existing imports)

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        if (clientResult != null) {
            LOGGER.info("Client is present");
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            importClientRequest.getClient().setLookupID(lc360ClientId);

            for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID());
                if (locationResult != null) {
                    LOGGER.info("Location is present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    location.setLookupID(lc360LocationId);
                }
            }

            objectMapper.writeValueAsString(importClientRequest);
            LOGGER.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                    System.out.println("lc360ClientId: " + lc360ClientId);
                }
            }
        } else {
            LOGGER.info("Client is not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
                }
            }
        }

        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}






// ... (import statements and annotations)

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);

    // Autowired fields...

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        if (clientResult != null) {
            LOGGER.info("Client is present");
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            importClientRequest.getClient().setLookupID(lc360ClientId);
            
            for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID());

                if (locationResult != null) {
                    LOGGER.info("Location is present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    location.setLookupID(lc360LocationId);
                }

                objectMapper.writeValueAsString(importClientRequest);
                LOGGER.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                    System.out.println("lc360ClientId: " + lc360ClientId);
                }
            }
        } else {
            LOGGER.info("Client is not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
                }
            }
        }
        
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}






// ... Existing imports ...

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        if (clientResult != null) {
            LOGGER.info("Client is present");
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            
            // Process each location
            for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID());
                
                if (locationResult != null) {
                    LOGGER.info("Location is present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    location.setLookupID(lc360LocationId);
                }
            }
            
            importClientRequest.getClient().setLookupID(lc360ClientId);
            objectMapper.writeValueAsString(importClientRequest);
            
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            
            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                }
            }
        } else {
            LOGGER.info("Client is not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.insertData(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
                }
            }
        }
        
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}










ArrayList<Location> locations = importClientRequest.getClient().getLocations();

for (int index = 0; index < locations.size(); index++) {
    String lookupID = locations.get(index).getLookupID();
    System.out.println("LookupID at index " + index + ": " + lookupID);
}









ArrayList<Location> locations = importClientRequest.getClient().getLocations();

for (int index = 0; index < locations.size(); index++) {
    String lookupID = locations.get(index).getLookupID();
    int position = index + 1;
    System.out.println("LookupID " + position + ": " + lookupID);
}






ArrayList<Location> locations = importClientRequest.getClient().getLocations();
int count = 1;

for (Location location : locations) {
    String lookupID = location.getLookupID();
    System.out.println("LookupID " + count + ": " + lookupID);
    count++;
}




ArrayList<Location> locations = importClientRequest.getClient().getLocations();

for (Location location : locations) {
    String lookupID = location.getLookupID();
    System.out.println("LookupID: " + lookupID);
}






package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;

public class ValidationServiceImplTestb {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @InjectMocks
    private ValidationServiceImpl validationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(true);

        String json = "\"John\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(Mockito.any())).thenReturn(false);

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(true);

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(true);

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithObjectThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(Mockito.any())).thenReturn(true);

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }
}

//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class ValidationServiceImplTesta {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @InjectMocks
    private ValidationServiceImpl validationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJson() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "\"John\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();
        when(validationServiceImpl.isEmptyObject(any())).thenCallRealMethod();

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithSingleValueJson() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithObject() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();
        when(validationServiceImpl.isEmptyObject(any())).thenCallRealMethod();

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }
}




///
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class ValidationServiceImplTestC {
    @InjectMocks
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ValidationServiceImpl mockValidationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(mockValidationService.isSingleValue(any())).thenReturn(true);
        doCallRealMethod().when(mockValidationService).processJson(anyString());

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> mockValidationService.processJson(json));

        verify(mockValidationService).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(mockValidationService.isSingleValue(any())).thenReturn(true);
        doCallRealMethod().when(mockValidationService).processJson(anyString());

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> mockValidationService.processJson(json));

        verify(mockValidationService).isSingleValue(any());
    }

    // ... other test methods ...
}


//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;

public class ValidationServiceImplTestB {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @InjectMocks
    private ValidationServiceImpl validationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJson() {
        String json = "\"John\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() {
        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithSingleValueJson() {
        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithObject() {
        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }
}

//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class ValidationServiceImplTestA {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @InjectMocks
    private ValidationServiceImpl realValidationServiceImpl;

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> realValidationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> realValidationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithObjectThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(true);

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(false);

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }
}


//////
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.mockito.Mockito.*;

public class ValidationServiceImplTest {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(true);

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(true);

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithObjectThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(true);

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(false);

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }
}
