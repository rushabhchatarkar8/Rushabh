import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

public class ValidationRestTest1 {

    @Mock
    private ValidationServiceImpl validationService;

    @Mock
    private ImportClientServiceImp importClientService;

    @InjectMocks
    private ValidationRest validationRest;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJson_ValidInput_Success() throws Exception {
        // Arrange
        String json = "{...}"; // Replace with valid JSON
        String correlationId = "correlationId";

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up mock behavior
        when(validationService.processJson(json)).thenReturn(json);
        when(importClientService.importClient(json, correlationId)).thenReturn(importClientResponse);
        importClientResponse.getResult().setSuccess(true);

        // Act
        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        // Assert
        assertEquals(HttpStatus.OK, response.getStatusCode());
        // Add more assertions if needed
    }

    @Test
    public void testProcessJson_ImportFailure_ReturnsUnprocessableEntity() throws Exception {
        // Arrange
        String json = "{...}"; // Replace with valid JSON
        String correlationId = "correlationId";

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up mock behavior
        when(validationService.processJson(json)).thenReturn(json);
        when(importClientService.importClient(json, correlationId)).thenReturn(importClientResponse);
        importClientResponse.getResult().setSuccess(false);
        importClientResponse.getResult().getErrors().add("Error message");

        // Act
        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        // Assert
        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        // Add more assertions if needed
    }

    @Test
    public void testProcessJson_InvalidJson_ReturnsBadRequest() throws Exception {
        // Arrange
        String json = "{...}"; // Replace with invalid JSON
        String correlationId = "correlationId";

        // Set up mock behavior
        when(validationService.processJson(json)).thenThrow(CustomException.class);

        // Act
        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        // Assert
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        // Add more assertions if needed
    }

    @Test
    public void testProcessJson_Exception_ReturnsInternalServerError() throws Exception {
        // Arrange
        String json = "{...}"; // Replace with valid JSON
        String correlationId = "correlationId";

        // Set up mock behavior
        when(validationService.processJson(json)).thenReturn(json);
        when(importClientService.importClient(json, correlationId)).thenThrow(Exception.class);

        // Act
        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        // Assert
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        // Add more assertions if needed
    }
}















import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class ValidationRestTest2 {

    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationService;

    @Mock
    private ImportClientServiceImp importClientService;

    @Mock
    private Logger logger;

    @Test
    public void testProcessJson_SuccessfulImport() throws CustomException, JsonProcessingException {
        String json = "{...}"; // Replace with your JSON data
        String correlationId = "123";

        // Mock validation service behavior
        when(validationService.processJson(json)).thenReturn(json);

        // Mock import client response
        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        importClientResponse.setResult(result);
        when(importClientService.importClient(json, correlationId)).thenReturn(importClientResponse);

        // Mock logger behavior
        when(logger.isInfoEnabled()).thenReturn(true);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Verify that the response entity is OK
        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());

        // Verify logger messages
        verify(logger).info(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_SUCCESS),
                " client imported Successfully in LC360 {}", HttpStatus.OK.value());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() throws CustomException, JsonProcessingException {
        String json = "{...}"; // Replace with your JSON data
        String correlationId = "123";

        // Mock validation service behavior
        when(validationService.processJson(json)).thenReturn(json);

        // Mock import client response
        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(Collections.singletonList("Invalid data"));
        importClientResponse.setResult(result);
        when(importClientService.importClient(json, correlationId)).thenReturn(importClientResponse);

        // Mock logger behavior
        when(logger.isInfoEnabled()).thenReturn(true);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Verify that the response entity is UNPROCESSABLE_ENTITY
        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, responseEntity.getStatusCode());

        // Verify logger messages
        verify(logger).info("Error: [Invalid data]");
        verify(logger).info(" client imported Unsuccessfully in LC360 {}", HttpStatus.UNPROCESSABLE_ENTITY);
    }

    @Test
    public void testProcessJson_InvalidJson() throws CustomException, JsonProcessingException {
        String json = ""; // Invalid JSON
        String correlationId = "123";

        // Mock logger behavior
        when(logger.isInfoEnabled()).thenReturn(true);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Verify that the response entity is BAD_REQUEST
        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());

        // Verify logger messages
        verify(logger).info("JSON is empty");
    }
}










import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class ValidationRestTest3 {

    @Mock
    private ValidationServiceImpl validationService;

    @Mock
    private ImportClientServiceImp importClientService;

    @InjectMocks
    private ValidationRest validationRest;

    @Test
    public void testProcessJson_Success() throws CustomException, JsonProcessingException {
        String json = "valid json data";
        String correlationId = "correlationId";

        String validateInput = "validated json data";
        ImportClientResponse importResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        importResponse.setResult(result);

        when(validationService.processJson(json)).thenReturn(validateInput);
        when(importClientService.importClient(validateInput, correlationId)).thenReturn(importResponse);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
        assertEquals(importResponse, responseEntity.getBody());

        verify(validationService, times(1)).processJson(json);
        verify(importClientService, times(1)).importClient(validateInput, correlationId);
    }

    @Test
    public void testProcessJson_Failure() throws CustomException, JsonProcessingException {
        String json = "valid json data";
        String correlationId = "correlationId";

        String validateInput = "validated json data";
        ImportClientResponse importResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        importResponse.setResult(result);

        when(validationService.processJson(json)).thenReturn(validateInput);
        when(importClientService.importClient(validateInput, correlationId)).thenReturn(importResponse);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, responseEntity.getStatusCode());

        verify(validationService, times(1)).processJson(json);
        verify(importClientService, times(1)).importClient(validateInput, correlationId);
    }

    @Test
    public void testProcessJson_InvalidJson() throws CustomException, JsonProcessingException {
        String json = "invalid json data";
        String correlationId = "correlationId";

        when(validationService.processJson(json)).thenThrow(new CustomException("Invalid JSON format"));

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());

        verify(validationService, times(1)).processJson(json);
        verify(importClientService, never()).importClient(any(), any());
    }

    @Test
    public void testProcessJson_Exception() throws CustomException, JsonProcessingException {
        String json = "valid json data";
        String correlationId = "correlationId";

        when(validationService.processJson(json)).thenReturn(json);
        when(importClientService.importClient(json, correlationId)).thenThrow(new RuntimeException("Some error"));

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, responseEntity.getStatusCode());

        verify(validationService, times(1)).processJson(json);
        verify(importClientService, times(1)).importClient(json, correlationId);
    }
}








import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class ValidationRestTest4 {

    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @Test
    public void testValidJsonImportSuccess() {
        // Arrange
        String json = "{...}"; // valid JSON
        String correlationId = "correlation-id";

        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        importClientResponse.setResult(result);

        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importClientResponse);

        // Act
        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Assert
        assertNotNull(responseEntity);
        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
        // You can also perform additional assertions based on the expected response
    }

    @Test
    public void testValidJsonImportFailure() {
        // Arrange
        String json = "{...}"; // valid JSON
        String correlationId = "correlation-id";

        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(Arrays.asList("Error 1", "Error 2"));
        importClientResponse.setResult(result);

        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importClientResponse);

        // Act
        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Assert
        assertNotNull(responseEntity);
        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, responseEntity.getStatusCode());
        // You can also perform additional assertions based on the expected response
    }

    @Test
    public void testInvalidJson() {
        // Arrange
        String json = "invalid JSON";
        String correlationId = "correlation-id";

        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Invalid JSON"));

        // Act
        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Assert
        assertNotNull(responseEntity);
        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());
        // You can also perform additional assertions based on the expected response
    }

    @Test
    public void testInternalServerError() {
        // Arrange
        String json = "{...}"; // valid JSON
        String correlationId = "correlation-id";

        when(validationServiceImpl.processJson(json)).thenReturn(json);

        when(importClientServiceImp.importClient(json, correlationId)).thenThrow(new RuntimeException("Some error occurred"));

        // Act
        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Assert
        assertNotNull(responseEntity);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, responseEntity.getStatusCode());
        // You can also perform additional assertions based on the expected response
    }
}












import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class ValidationRestTest5 {

    @Mock
    private ValidationServiceImpl validationService;

    @Mock
    private ImportClientServiceImp importClientService;

    @InjectMocks
    private ValidationRest validationRest;

    @Test
    public void testProcessJson_SuccessfulImport() throws Exception {
        String json = "valid_json";
        String correlationId = "correlation_id";

        // Mocking validationService.processJson
        when(validationService.processJson(json)).thenReturn(json);

        // Mocking importClientService.importClient
        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        importClientResponse.setResult(result);
        when(importClientService.importClient(json, correlationId)).thenReturn(importClientResponse);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
        assertNotNull(responseEntity.getBody());
    }

    @Test
    public void testProcessJson_FailedImport() throws Exception {
        String json = "valid_json";
        String correlationId = "correlation_id";

        // Mocking validationService.processJson
        when(validationService.processJson(json)).thenReturn(json);

        // Mocking importClientService.importClient
        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        List<Object> errors = new ArrayList<>();
        errors.add("Error message");
        result.setErrors(errors);
        importClientResponse.setResult(result);
        when(importClientService.importClient(json, correlationId)).thenReturn(importClientResponse);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, responseEntity.getStatusCode());
        assertNotNull(responseEntity.getBody());
    }

    @Test
    public void testProcessJson_InvalidJson() throws Exception {
        String json = ""; // Invalid JSON
        String correlationId = "correlation_id";

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());
        assertNotNull(responseEntity.getBody());
    }

    @Test
    public void testProcessJson_CustomException() throws Exception {
        String json = "valid_json";
        String correlationId = "correlation_id";

        // Mocking validationService.processJson to throw CustomException
        when(validationService.processJson(json)).thenThrow(new CustomException("Custom error message"));

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());
        assertNotNull(responseEntity.getBody());
    }

    @Test
    public void testProcessJson_Exception() throws Exception {
        String json = "valid_json";
        String correlationId = "correlation_id";

        // Mocking validationService.processJson
        when(validationService.processJson(json)).thenReturn(json);

        // Mocking importClientService.importClient to throw Exception
        when(importClientService.importClient(json, correlationId)).thenThrow(new Exception("General exception"));

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, responseEntity.getStatusCode());
        assertNotNull(responseEntity.getBody());
    }
}













java.lang.NullPointerException: Cannot invoke "uk.co.allianz.rap.lc.service.ValidationServiceImpl.processJson(String)" because "this.validationServiceImpl" is null
        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));


        when(validationServiceImpl.processJson(json)).thenReturn(json);




import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest1 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(new ArrayList<>());
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_ValidationFailure() {
        String json = "{\"invalidJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation to throw an exception
        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}








import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest2 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        importClientResponse.setResult(result);

        when(validationServiceImpl.processJson(json)).thenReturn(json);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importClientResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(new ArrayList<>());
        importClientResponse.setResult(result);

        when(validationServiceImpl.processJson(json)).thenReturn(json);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importClientResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_ProcessedJsonNull() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        when(validationServiceImpl.processJson(json)).thenReturn(json);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(null);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertNull(response.getBody());
    }

    @Test
    public void testProcessJson_ProcessedJsonResultNull() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        ImportClientResponse importClientResponse = new ImportClientResponse();

        when(validationServiceImpl.processJson(json)).thenReturn(json);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importClientResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertNull(response.getBody());
    }

    @Test
    public void testProcessJson_CustomException() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}


///
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importclient.Result;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest3 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response with successful import
        ImportClientResponse importResponse = createSuccessfulImportResponse();
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response with unsuccessful import
        ImportClientResponse importResponse = createUnsuccessfulImportResponse();
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_ValidationFailure() {
        String json = "{\"invalidJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    // Helper method to create a successful ImportClientResponse
    private ImportClientResponse createSuccessfulImportResponse() {
        ImportClientResponse importResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        importResponse.setResult(result);
        return importResponse;
    }

    // Helper method to create an unsuccessful ImportClientResponse
    private ImportClientResponse createUnsuccessfulImportResponse() {
        ImportClientResponse importResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(new ArrayList<>());
        importResponse.setResult(result);
        return importResponse;
    }
}


















import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest3 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(new ArrayList<>());
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_ValidationFailure() {
        String json = "{\"invalidJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation to throw an exception
        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_GeneralException() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response to throw a general exception
        when(importClientServiceImp.importClient(json, correlationId)).thenThrow(new RuntimeException("Import failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}



//////////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest2 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(true);
        mockResponse.setResult(lookupResult);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(false);
        lookupResult.setErrors(new ArrayList<>()); // Simulating errors
        mockResponse.setResult(lookupResult);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }
    
    // Additional test case targeting specific ImportClientResponse scenarios
    @Test
    public void testProcessJson_ImportResponseIsNull() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response to be null
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(null);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertNotNull(response.getBody());
    }
    
    // Additional test case targeting specific Result scenarios
    @Test
    public void testProcessJson_ImportFailureWithErrors() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(false);
        lookupResult.setErrors(new ArrayList<>()); // Simulating errors
        mockResponse.setResult(lookupResult);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}






/////////////////////////////////////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importclient.Result;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest1 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(new ArrayList<>());
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_ValidationFailure() {
        String json = "{\"invalidJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation to throw an exception
        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_GeneralException() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response to throw a general exception
        when(importClientServiceImp.importClient(json, correlationId)).thenThrow(new RuntimeException("Import failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}










////////////////////////////////////
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

public class ValidationRestTest {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(true);
        mockResponse.setResult(lookupResult);

        when(importClientServiceImp.importClient(Mockito.any(), Mockito.any())).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(false);
        lookupResult.setErrors("Import failed");
        mockResponse.setResult(lookupResult);

        when(importClientServiceImp.importClient(Mockito.any(), Mockito.any())).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
    }
}





















if (processedJson != null && processedJson.getResult() != null) {
    if (processedJson.getResult().isSuccess()) {
        // ...
    } else {
        // ...
    }
}






public ArrayList<Location> locationResponse(ArrayList<Location> locations) {
    ArrayList<Location> validLocations = new ArrayList<>();
    
    for (Location location : locations) {
        if (location.getLookupID() != null) {
            validLocations.add(location);
        }
    }
    
    return validLocations;
}



////
public ArrayList<Location> locationResponse(ArrayList<Location> locations) {
    ArrayList<Location> validLocations = new ArrayList<>();

    for (Location location : locations) {
        String lookupID = location.getLookupID();
        System.out.println("LookupID: " + lookupID);

        if (lookupID != null) {
            validLocations.add(location);
        }
    }

    return validLocations;
}










// ... (existing imports)

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        if (clientResult != null) {
            LOGGER.info("Client is present");
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            importClientRequest.getClient().setLookupID(lc360ClientId);

            for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID());
                if (locationResult != null) {
                    LOGGER.info("Location is present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    location.setLookupID(lc360LocationId);
                }
            }

            objectMapper.writeValueAsString(importClientRequest);
            LOGGER.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                    System.out.println("lc360ClientId: " + lc360ClientId);
                }
            }
        } else {
            LOGGER.info("Client is not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
                }
            }
        }

        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}






// ... (import statements and annotations)

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);

    // Autowired fields...

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        if (clientResult != null) {
            LOGGER.info("Client is present");
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            importClientRequest.getClient().setLookupID(lc360ClientId);
            
            for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID());

                if (locationResult != null) {
                    LOGGER.info("Location is present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    location.setLookupID(lc360LocationId);
                }

                objectMapper.writeValueAsString(importClientRequest);
                LOGGER.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                    System.out.println("lc360ClientId: " + lc360ClientId);
                }
            }
        } else {
            LOGGER.info("Client is not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
                }
            }
        }
        
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}






// ... Existing imports ...

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        if (clientResult != null) {
            LOGGER.info("Client is present");
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            
            // Process each location
            for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID());
                
                if (locationResult != null) {
                    LOGGER.info("Location is present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    location.setLookupID(lc360LocationId);
                }
            }
            
            importClientRequest.getClient().setLookupID(lc360ClientId);
            objectMapper.writeValueAsString(importClientRequest);
            
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            
            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                }
            }
        } else {
            LOGGER.info("Client is not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.insertData(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
                }
            }
        }
        
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}










ArrayList<Location> locations = importClientRequest.getClient().getLocations();

for (int index = 0; index < locations.size(); index++) {
    String lookupID = locations.get(index).getLookupID();
    System.out.println("LookupID at index " + index + ": " + lookupID);
}









ArrayList<Location> locations = importClientRequest.getClient().getLocations();

for (int index = 0; index < locations.size(); index++) {
    String lookupID = locations.get(index).getLookupID();
    int position = index + 1;
    System.out.println("LookupID " + position + ": " + lookupID);
}






ArrayList<Location> locations = importClientRequest.getClient().getLocations();
int count = 1;

for (Location location : locations) {
    String lookupID = location.getLookupID();
    System.out.println("LookupID " + count + ": " + lookupID);
    count++;
}




ArrayList<Location> locations = importClientRequest.getClient().getLocations();

for (Location location : locations) {
    String lookupID = location.getLookupID();
    System.out.println("LookupID: " + lookupID);
}






package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;

public class ValidationServiceImplTestb {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @InjectMocks
    private ValidationServiceImpl validationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(true);

        String json = "\"John\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(Mockito.any())).thenReturn(false);

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(true);

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(true);

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithObjectThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(Mockito.any())).thenReturn(true);

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }
}

//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class ValidationServiceImplTesta {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @InjectMocks
    private ValidationServiceImpl validationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJson() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "\"John\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();
        when(validationServiceImpl.isEmptyObject(any())).thenCallRealMethod();

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithSingleValueJson() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithObject() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();
        when(validationServiceImpl.isEmptyObject(any())).thenCallRealMethod();

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }
}




///
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class ValidationServiceImplTestC {
    @InjectMocks
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ValidationServiceImpl mockValidationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(mockValidationService.isSingleValue(any())).thenReturn(true);
        doCallRealMethod().when(mockValidationService).processJson(anyString());

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> mockValidationService.processJson(json));

        verify(mockValidationService).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(mockValidationService.isSingleValue(any())).thenReturn(true);
        doCallRealMethod().when(mockValidationService).processJson(anyString());

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> mockValidationService.processJson(json));

        verify(mockValidationService).isSingleValue(any());
    }

    // ... other test methods ...
}


//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;

public class ValidationServiceImplTestB {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @InjectMocks
    private ValidationServiceImpl validationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJson() {
        String json = "\"John\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() {
        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithSingleValueJson() {
        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithObject() {
        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }
}

//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class ValidationServiceImplTestA {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @InjectMocks
    private ValidationServiceImpl realValidationServiceImpl;

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> realValidationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> realValidationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithObjectThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(true);

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(false);

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }
}


//////
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.mockito.Mockito.*;

public class ValidationServiceImplTest {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(true);

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(true);

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithObjectThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(true);

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(false);

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }
}
