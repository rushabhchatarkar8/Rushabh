 public String clientResponse(String clientLookupId){
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(clientLookupId);
        if(clientResult != null){
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            return lc360ClientId;
        }else {
            return clientLookupId;
        }
    }




















        String oci=importClientRequest.getClient().getLookupID();
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String clientId =clientResponse(importClientRequest.getClient().getLookupID());




























/home/rushabh.chatarkar/.jdks/corretto-17.0.7/bin/java -ea -Dorg.springframework.restdocs.outputDir=/home/rushabh.chatarkar/feature-DB/loss-control-service/target/generated-snippets -Dorg.springframework.restdocs.javadocJsonDir=/home/rushabh.chatarkar/feature-DB/loss-control-service/target/generated-javadoc-json -javaagent:/snap/intellij-idea-community/454/lib/intellij-coverage-agent-1.0.723.jar=/tmp/coverage661args -Didea.new.sampling.coverage=true -Didea.test.cyclic.buffer.size=1048576 -javaagent:/snap/intellij-idea-community/454/lib/idea_rt.jar=44187:/snap/intellij-idea-community/454/bin -Dfile.encoding=UTF-8 -classpath /snap/intellij-idea-community/454/lib/idea_rt.jar:/snap/intellij-idea-community/454/plugins/junit/lib/junit5-rt.jar:/snap/intellij-idea-community/454/plugins/junit/lib/junit-rt.jar:/home/rushabh.chatarkar/feature-DB/loss-control-service/target/test-classes:/home/rushabh.chatarkar/feature-DB/loss-control-service/target/classes:/home/rushabh.chatarkar/.m2/repository/com/mikesamuel/json-sanitizer/1.2.0/json-sanitizer-1.2.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter-webflux/3.1.0/spring-boot-starter-webflux-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter/3.1.0/spring-boot-starter-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot/3.1.0/spring-boot-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/3.1.0/spring-boot-autoconfigure-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter-logging/3.1.0/spring-boot-starter-logging-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/apache/logging/log4j/log4j-to-slf4j/2.20.0/log4j-to-slf4j-2.20.0.jar:/home/rushabh.chatarkar/.m2/repository/org/apache/logging/log4j/log4j-api/2.20.0/log4j-api-2.20.0.jar:/home/rushabh.chatarkar/.m2/repository/org/slf4j/jul-to-slf4j/2.0.7/jul-to-slf4j-2.0.7.jar:/home/rushabh.chatarkar/.m2/repository/jakarta/annotation/jakarta.annotation-api/2.1.1/jakarta.annotation-api-2.1.1.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter-json/3.1.0/spring-boot-starter-json-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/com/fasterxml/jackson/datatype/jackson-datatype-jdk8/2.15.0/jackson-datatype-jdk8-2.15.0.jar:/home/rushabh.chatarkar/.m2/repository/com/fasterxml/jackson/module/jackson-module-parameter-names/2.15.0/jackson-module-parameter-names-2.15.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter-reactor-netty/3.1.0/spring-boot-starter-reactor-netty-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/io/projectreactor/netty/reactor-netty-http/1.1.7/reactor-netty-http-1.1.7.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-codec-http/4.1.92.Final/netty-codec-http-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-common/4.1.92.Final/netty-common-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-buffer/4.1.92.Final/netty-buffer-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-transport/4.1.92.Final/netty-transport-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-codec/4.1.92.Final/netty-codec-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-handler/4.1.92.Final/netty-handler-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-codec-http2/4.1.92.Final/netty-codec-http2-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-resolver-dns/4.1.92.Final/netty-resolver-dns-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-resolver/4.1.92.Final/netty-resolver-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-codec-dns/4.1.92.Final/netty-codec-dns-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-resolver-dns-native-macos/4.1.92.Final/netty-resolver-dns-native-macos-4.1.92.Final-osx-x86_64.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-resolver-dns-classes-macos/4.1.92.Final/netty-resolver-dns-classes-macos-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-transport-native-epoll/4.1.92.Final/netty-transport-native-epoll-4.1.92.Final-linux-x86_64.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-transport-native-unix-common/4.1.92.Final/netty-transport-native-unix-common-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-transport-classes-epoll/4.1.92.Final/netty-transport-classes-epoll-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/projectreactor/netty/reactor-netty-core/1.1.7/reactor-netty-core-1.1.7.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-handler-proxy/4.1.92.Final/netty-handler-proxy-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/netty/netty-codec-socks/4.1.92.Final/netty-codec-socks-4.1.92.Final.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-web/6.0.9/spring-web-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-beans/6.0.9/spring-beans-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-webflux/6.0.9/spring-webflux-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/io/projectreactor/reactor-core/3.5.6/reactor-core-3.5.6.jar:/home/rushabh.chatarkar/.m2/repository/org/reactivestreams/reactive-streams/1.0.4/reactive-streams-1.0.4.jar:/home/rushabh.chatarkar/.m2/repository/com/google/code/gson/gson/2.8.9/gson-2.8.9.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter-cache/3.1.0/spring-boot-starter-cache-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-context-support/6.0.9/spring-context-support-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-context/6.0.9/spring-context-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/com/github/ben-manes/caffeine/caffeine/3.0.4/caffeine-3.0.4.jar:/home/rushabh.chatarkar/.m2/repository/org/checkerframework/checker-qual/3.18.0/checker-qual-3.18.0.jar:/home/rushabh.chatarkar/.m2/repository/com/google/errorprone/error_prone_annotations/2.9.0/error_prone_annotations-2.9.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter-data-jpa/3.1.0/spring-boot-starter-data-jpa-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter-jdbc/3.1.0/spring-boot-starter-jdbc-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/com/zaxxer/HikariCP/5.0.1/HikariCP-5.0.1.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-jdbc/6.0.9/spring-jdbc-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/hibernate/orm/hibernate-core/6.2.2.Final/hibernate-core-6.2.2.Final.jar:/home/rushabh.chatarkar/.m2/repository/jakarta/persistence/jakarta.persistence-api/3.1.0/jakarta.persistence-api-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/jakarta/transaction/jakarta.transaction-api/2.0.1/jakarta.transaction-api-2.0.1.jar:/home/rushabh.chatarkar/.m2/repository/org/jboss/logging/jboss-logging/3.5.0.Final/jboss-logging-3.5.0.Final.jar:/home/rushabh.chatarkar/.m2/repository/org/hibernate/common/hibernate-commons-annotations/6.0.6.Final/hibernate-commons-annotations-6.0.6.Final.jar:/home/rushabh.chatarkar/.m2/repository/io/smallrye/jandex/3.0.5/jandex-3.0.5.jar:/home/rushabh.chatarkar/.m2/repository/com/fasterxml/classmate/1.5.1/classmate-1.5.1.jar:/home/rushabh.chatarkar/.m2/repository/net/bytebuddy/byte-buddy/1.14.4/byte-buddy-1.14.4.jar:/home/rushabh.chatarkar/.m2/repository/org/glassfish/jaxb/jaxb-runtime/4.0.2/jaxb-runtime-4.0.2.jar:/home/rushabh.chatarkar/.m2/repository/org/glassfish/jaxb/jaxb-core/4.0.2/jaxb-core-4.0.2.jar:/home/rushabh.chatarkar/.m2/repository/org/eclipse/angus/angus-activation/2.0.0/angus-activation-2.0.0.jar:/home/rushabh.chatarkar/.m2/repository/org/glassfish/jaxb/txw2/4.0.2/txw2-4.0.2.jar:/home/rushabh.chatarkar/.m2/repository/com/sun/istack/istack-commons-runtime/4.1.1/istack-commons-runtime-4.1.1.jar:/home/rushabh.chatarkar/.m2/repository/jakarta/inject/jakarta.inject-api/2.0.1/jakarta.inject-api-2.0.1.jar:/home/rushabh.chatarkar/.m2/repository/org/antlr/antlr4-runtime/4.10.1/antlr4-runtime-4.10.1.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/data/spring-data-jpa/3.1.0/spring-data-jpa-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/data/spring-data-commons/3.1.0/spring-data-commons-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-orm/6.0.9/spring-orm-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-tx/6.0.9/spring-tx-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-aspects/6.0.9/spring-aspects-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/liquibase/liquibase-core/4.23.0/liquibase-core-4.23.0.jar:/home/rushabh.chatarkar/.m2/repository/com/opencsv/opencsv/5.7.1/opencsv-5.7.1.jar:/home/rushabh.chatarkar/.m2/repository/org/apache/commons/commons-text/1.10.0/commons-text-1.10.0.jar:/home/rushabh.chatarkar/.m2/repository/org/apache/commons/commons-collections4/4.4/commons-collections4-4.4.jar:/home/rushabh.chatarkar/.m2/repository/org/yaml/snakeyaml/1.33/snakeyaml-1.33.jar:/home/rushabh.chatarkar/.m2/repository/javax/xml/bind/jaxb-api/2.3.1/jaxb-api-2.3.1.jar:/home/rushabh.chatarkar/.m2/repository/javax/activation/javax.activation-api/1.2.0/javax.activation-api-1.2.0.jar:/home/rushabh.chatarkar/.m2/repository/org/postgresql/postgresql/42.6.0/postgresql-42.6.0.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-spring-boot2/1.6.1/resilience4j-spring-boot2-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/io/vavr/vavr/0.10.3/vavr-0.10.3.jar:/home/rushabh.chatarkar/.m2/repository/io/vavr/vavr-match/0.10.3/vavr-match-0.10.3.jar:/home/rushabh.chatarkar/.m2/repository/org/slf4j/slf4j-api/2.0.7/slf4j-api-2.0.7.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-spring/1.6.1/resilience4j-spring-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-annotations/1.6.1/resilience4j-annotations-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-consumer/1.6.1/resilience4j-consumer-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-core/1.6.1/resilience4j-core-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-circularbuffer/1.6.1/resilience4j-circularbuffer-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-framework-common/1.6.1/resilience4j-framework-common-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-circuitbreaker/1.6.1/resilience4j-circuitbreaker-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-ratelimiter/1.6.1/resilience4j-ratelimiter-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-retry/1.6.1/resilience4j-retry-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-bulkhead/1.6.1/resilience4j-bulkhead-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-timelimiter/1.6.1/resilience4j-timelimiter-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/io/github/resilience4j/resilience4j-micrometer/1.6.1/resilience4j-micrometer-1.6.1.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter-web/3.1.0/spring-boot-starter-web-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter-tomcat/3.1.0/spring-boot-starter-tomcat-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/apache/tomcat/embed/tomcat-embed-core/10.1.8/tomcat-embed-core-10.1.8.jar:/home/rushabh.chatarkar/.m2/repository/org/apache/tomcat/embed/tomcat-embed-el/10.1.8/tomcat-embed-el-10.1.8.jar:/home/rushabh.chatarkar/.m2/repository/org/apache/tomcat/embed/tomcat-embed-websocket/10.1.8/tomcat-embed-websocket-10.1.8.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-webmvc/6.0.9/spring-webmvc-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-expression/6.0.9/spring-expression-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter-test/3.1.0/spring-boot-starter-test-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-test/3.1.0/spring-boot-test-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-test-autoconfigure/3.1.0/spring-boot-test-autoconfigure-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/com/jayway/jsonpath/json-path/2.8.0/json-path-2.8.0.jar:/home/rushabh.chatarkar/.m2/repository/jakarta/xml/bind/jakarta.xml.bind-api/4.0.0/jakarta.xml.bind-api-4.0.0.jar:/home/rushabh.chatarkar/.m2/repository/jakarta/activation/jakarta.activation-api/2.1.2/jakarta.activation-api-2.1.2.jar:/home/rushabh.chatarkar/.m2/repository/net/minidev/json-smart/2.4.10/json-smart-2.4.10.jar:/home/rushabh.chatarkar/.m2/repository/net/minidev/accessors-smart/2.4.9/accessors-smart-2.4.9.jar:/home/rushabh.chatarkar/.m2/repository/org/ow2/asm/asm/9.3/asm-9.3.jar:/home/rushabh.chatarkar/.m2/repository/org/assertj/assertj-core/3.24.2/assertj-core-3.24.2.jar:/home/rushabh.chatarkar/.m2/repository/org/hamcrest/hamcrest/2.2/hamcrest-2.2.jar:/home/rushabh.chatarkar/.m2/repository/org/junit/jupiter/junit-jupiter/5.9.0/junit-jupiter-5.9.0.jar:/home/rushabh.chatarkar/.m2/repository/org/junit/jupiter/junit-jupiter-params/5.9.0/junit-jupiter-params-5.9.0.jar:/home/rushabh.chatarkar/.m2/repository/org/mockito/mockito-core/5.3.1/mockito-core-5.3.1.jar:/home/rushabh.chatarkar/.m2/repository/net/bytebuddy/byte-buddy-agent/1.14.4/byte-buddy-agent-1.14.4.jar:/home/rushabh.chatarkar/.m2/repository/org/objenesis/objenesis/3.3/objenesis-3.3.jar:/home/rushabh.chatarkar/.m2/repository/org/skyscreamer/jsonassert/1.5.1/jsonassert-1.5.1.jar:/home/rushabh.chatarkar/.m2/repository/com/vaadin/external/google/android-json/0.0.20131108.vaadin1/android-json-0.0.20131108.vaadin1.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-core/6.0.9/spring-core-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-jcl/6.0.9/spring-jcl-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-test/6.0.9/spring-test-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/xmlunit/xmlunit-core/2.9.1/xmlunit-core-2.9.1.jar:/home/rushabh.chatarkar/.m2/repository/org/springdoc/springdoc-openapi-ui/1.6.15/springdoc-openapi-ui-1.6.15.jar:/home/rushabh.chatarkar/.m2/repository/org/springdoc/springdoc-openapi-webmvc-core/1.6.15/springdoc-openapi-webmvc-core-1.6.15.jar:/home/rushabh.chatarkar/.m2/repository/org/springdoc/springdoc-openapi-common/1.6.15/springdoc-openapi-common-1.6.15.jar:/home/rushabh.chatarkar/.m2/repository/io/swagger/core/v3/swagger-core/2.2.8/swagger-core-2.2.8.jar:/home/rushabh.chatarkar/.m2/repository/com/fasterxml/jackson/dataformat/jackson-dataformat-yaml/2.15.0/jackson-dataformat-yaml-2.15.0.jar:/home/rushabh.chatarkar/.m2/repository/io/swagger/core/v3/swagger-annotations/2.2.8/swagger-annotations-2.2.8.jar:/home/rushabh.chatarkar/.m2/repository/io/swagger/core/v3/swagger-models/2.2.8/swagger-models-2.2.8.jar:/home/rushabh.chatarkar/.m2/repository/jakarta/validation/jakarta.validation-api/3.0.2/jakarta.validation-api-3.0.2.jar:/home/rushabh.chatarkar/.m2/repository/org/webjars/swagger-ui/4.17.1/swagger-ui-4.17.1.jar:/home/rushabh.chatarkar/.m2/repository/org/webjars/webjars-locator-core/0.52/webjars-locator-core-0.52.jar:/home/rushabh.chatarkar/.m2/repository/com/fasterxml/jackson/core/jackson-core/2.15.0/jackson-core-2.15.0.jar:/home/rushabh.chatarkar/.m2/repository/io/github/classgraph/classgraph/4.8.149/classgraph-4.8.149.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter-actuator/3.1.0/spring-boot-starter-actuator-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-actuator-autoconfigure/3.1.0/spring-boot-actuator-autoconfigure-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-actuator/3.1.0/spring-boot-actuator-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/io/micrometer/micrometer-observation/1.11.0/micrometer-observation-1.11.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/boot/spring-boot-starter-aop/3.1.0/spring-boot-starter-aop-3.1.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/spring-aop/6.0.9/spring-aop-6.0.9.jar:/home/rushabh.chatarkar/.m2/repository/org/aspectj/aspectjweaver/1.9.19/aspectjweaver-1.9.19.jar:/home/rushabh.chatarkar/.m2/repository/io/micrometer/micrometer-core/1.11.0/micrometer-core-1.11.0.jar:/home/rushabh.chatarkar/.m2/repository/io/micrometer/micrometer-commons/1.11.0/micrometer-commons-1.11.0.jar:/home/rushabh.chatarkar/.m2/repository/org/hdrhistogram/HdrHistogram/2.1.12/HdrHistogram-2.1.12.jar:/home/rushabh.chatarkar/.m2/repository/org/latencyutils/LatencyUtils/2.0.3/LatencyUtils-2.0.3.jar:/home/rushabh.chatarkar/.m2/repository/io/micrometer/micrometer-registry-prometheus/1.11.0/micrometer-registry-prometheus-1.11.0.jar:/home/rushabh.chatarkar/.m2/repository/io/prometheus/simpleclient_common/0.16.0/simpleclient_common-0.16.0.jar:/home/rushabh.chatarkar/.m2/repository/io/prometheus/simpleclient/0.16.0/simpleclient-0.16.0.jar:/home/rushabh.chatarkar/.m2/repository/io/prometheus/simpleclient_tracer_otel/0.16.0/simpleclient_tracer_otel-0.16.0.jar:/home/rushabh.chatarkar/.m2/repository/io/prometheus/simpleclient_tracer_common/0.16.0/simpleclient_tracer_common-0.16.0.jar:/home/rushabh.chatarkar/.m2/repository/io/prometheus/simpleclient_tracer_otel_agent/0.16.0/simpleclient_tracer_otel_agent-0.16.0.jar:/home/rushabh.chatarkar/.m2/repository/uk/co/allianz/ds/common/coreeventprocessorlib/1.0.43/coreeventprocessorlib-1.0.43.jar:/home/rushabh.chatarkar/.m2/repository/com/fasterxml/jackson/core/jackson-annotations/2.15.0/jackson-annotations-2.15.0.jar:/home/rushabh.chatarkar/.m2/repository/ch/qos/logback/logback-classic/1.4.8/logback-classic-1.4.8.jar:/home/rushabh.chatarkar/.m2/repository/ch/qos/logback/logback-core/1.4.8/logback-core-1.4.8.jar:/home/rushabh.chatarkar/.m2/repository/com/allianz/cisl/com.allianz.cisl.ext.uk.springjackson/2.44.5/com.allianz.cisl.ext.uk.springjackson-2.44.5.jar:/home/rushabh.chatarkar/.m2/repository/org/joda/joda-money/0.11/joda-money-0.11.jar:/home/rushabh.chatarkar/.m2/repository/com/google/guava/guava/30.0-jre/guava-30.0-jre.jar:/home/rushabh.chatarkar/.m2/repository/com/google/guava/failureaccess/1.0.1/failureaccess-1.0.1.jar:/home/rushabh.chatarkar/.m2/repository/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/home/rushabh.chatarkar/.m2/repository/com/google/code/findbugs/jsr305/3.0.2/jsr305-3.0.2.jar:/home/rushabh.chatarkar/.m2/repository/com/google/j2objc/j2objc-annotations/1.3/j2objc-annotations-1.3.jar:/home/rushabh.chatarkar/.m2/repository/com/fasterxml/jackson/datatype/jackson-datatype-jsr310/2.15.0/jackson-datatype-jsr310-2.15.0.jar:/home/rushabh.chatarkar/.m2/repository/com/allianz/cisl/com.allianz.cisl.ext.uk.jackson.model/2.44.5/com.allianz.cisl.ext.uk.jackson.model-2.44.5.jar:/home/rushabh.chatarkar/.m2/repository/com/allianz/cisl/com.allianz.cisl.ext.uk.events/2.44.5/com.allianz.cisl.ext.uk.events-2.44.5.jar:/home/rushabh.chatarkar/.m2/repository/org/codehaus/janino/janino/3.1.6/janino-3.1.6.jar:/home/rushabh.chatarkar/.m2/repository/org/codehaus/janino/commons-compiler/3.1.6/commons-compiler-3.1.6.jar:/home/rushabh.chatarkar/.m2/repository/org/projectlombok/lombok/1.18.28/lombok-1.18.28.jar:/home/rushabh.chatarkar/.m2/repository/net/logstash/logback/logstash-logback-encoder/7.4/logstash-logback-encoder-7.4.jar:/home/rushabh.chatarkar/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.15.0/jackson-databind-2.15.0.jar:/home/rushabh.chatarkar/.m2/repository/org/junit/jupiter/junit-jupiter-engine/5.9.0/junit-jupiter-engine-5.9.0.jar:/home/rushabh.chatarkar/.m2/repository/org/junit/platform/junit-platform-engine/1.9.0/junit-platform-engine-1.9.0.jar:/home/rushabh.chatarkar/.m2/repository/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar:/home/rushabh.chatarkar/.m2/repository/org/junit/jupiter/junit-jupiter-api/5.9.0/junit-jupiter-api-5.9.0.jar:/home/rushabh.chatarkar/.m2/repository/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar:/home/rushabh.chatarkar/.m2/repository/org/junit/platform/junit-platform-commons/1.9.0/junit-platform-commons-1.9.0.jar:/home/rushabh.chatarkar/.m2/repository/org/junit/platform/junit-platform-launcher/1.9.0/junit-platform-launcher-1.9.0.jar:/home/rushabh.chatarkar/.m2/repository/org/mockito/mockito-junit-jupiter/4.8.0/mockito-junit-jupiter-4.8.0.jar:/home/rushabh.chatarkar/.m2/repository/org/junit/vintage/junit-vintage-engine/5.9.0/junit-vintage-engine-5.9.0.jar:/home/rushabh.chatarkar/.m2/repository/junit/junit/4.13.2/junit-4.13.2.jar:/home/rushabh.chatarkar/.m2/repository/org/hamcrest/hamcrest-core/2.2/hamcrest-core-2.2.jar:/home/rushabh.chatarkar/.m2/repository/com/shazam/shazamcrest/0.11/shazamcrest-0.11.jar:/home/rushabh.chatarkar/.m2/repository/net/javacrumbs/json-unit/json-unit/2.35.0/json-unit-2.35.0.jar:/home/rushabh.chatarkar/.m2/repository/net/javacrumbs/json-unit/json-unit-core/2.35.0/json-unit-core-2.35.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/restdocs/spring-restdocs-mockmvc/3.0.0/spring-restdocs-mockmvc-3.0.0.jar:/home/rushabh.chatarkar/.m2/repository/org/springframework/restdocs/spring-restdocs-core/3.0.0/spring-restdocs-core-3.0.0.jar:/home/rushabh.chatarkar/.m2/repository/jakarta/servlet/jakarta.servlet-api/6.0.0/jakarta.servlet-api-6.0.0.jar:/home/rushabh.chatarkar/.m2/repository/capital/scalable/spring-auto-restdocs-core/2.0.11/spring-auto-restdocs-core-2.0.11.jar:/home/rushabh.chatarkar/.m2/repository/capital/scalable/spring-auto-restdocs-annotations/2.0.11/spring-auto-restdocs-annotations-2.0.11.jar:/home/rushabh.chatarkar/.m2/repository/org/apache/commons/commons-lang3/3.12.0/commons-lang3-3.12.0.jar com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 uk.co.allianz.rap.lc.service.ImportClientServiceImpTest2
---- IntelliJ IDEA coverage runner ---- 
Line coverage ...
include patterns:
uk\.co\.allianz\.rap\.lc\.service\..*
exclude patterns:
exclude annotations patterns:
.*Generated.*
OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended

java.lang.NullPointerException: Cannot invoke "uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest.getClient()" because "importClientRequest" is null

	at uk.co.allianz.rap.lc.service.ImportClientServiceImp.importClient(ImportClientServiceImp.java:39)
	at uk.co.allianz.rap.lc.service.ImportClientServiceImpTest2.testImportClient(ImportClientServiceImpTest2.java:58)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:727)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:156)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:147)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:86)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(InterceptingExecutableInvoker.java:103)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.lambda$invoke$0(InterceptingExecutableInvoker.java:93)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:92)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:86)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:217)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:213)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:138)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:147)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:127)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:90)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:55)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:102)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:54)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86)
	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86)
	at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53)
	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:57)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)

Class transformation time: 0.066464304s for 3248 classes or 2.0463147783251233E-5s per class

Process finished with exit code 255


















import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.fasterxml.jackson.databind.ObjectMapper;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;
import java.util.ArrayList;
import java.util.Map;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class ImportClientServiceImpTest {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @Mock
    private ObjectMapper objectMapper; // Mock the ObjectMapper

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClient() throws Exception {
        ImportClientRequest request = new ImportClientRequest();
        // Set up your request object
        
        String correlationId = "correlationId";
        String token = "testToken";
        String clientId = "testClientId";
        
        ImportClientResponse response = new ImportClientResponse();
        // Set up your response object
        
        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn(token);
        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(Map.of("key", clientId));
        when(lossControlServiceImpl.clientPost(any(), eq(token))).thenReturn(response);

        ImportClientResponse result = importClientService.importClient("jsonString", correlationId);
        
        assertNotNull(result); // Check that the result is not null
        // Add more assertions based on the expected results and the 'result' variable
    }

    // Add more test methods for other functions in the ImportClientServiceImp class
}










java.lang.NullPointerException: Cannot invoke "com.fasterxml.jackson.databind.ObjectMapper.readValue(String, java.lang.Class)" because "this.objectMapper" is null





import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;
import java.util.ArrayList;
import java.util.Map;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class ImportClientServiceImpTest1 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClient() throws Exception {
        ImportClientRequest request = new ImportClientRequest();
        // Set up your request object
        
        String correlationId = "correlationId";
        String token = "testToken";
        String clientId = "testClientId";
        
        ImportClientResponse response = new ImportClientResponse();
        // Set up your response object
        
        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn(token);
        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(Map.of("key", clientId));
        when(lossControlServiceImpl.clientPost(any(), eq(token))).thenReturn(response);

        ImportClientResponse result = importClientService.importClient("jsonString", correlationId);
        
        // Assertions
        assertNotNull(result);
        // Add more assertions based on the expected results and the 'result' variable
    }

    // Add more test methods for other functions in the ImportClientServiceImp class
}






import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;
import java.util.ArrayList;
import java.util.Map;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class ImportClientServiceImpTest2 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClient() throws Exception {
        ImportClientRequest request = new ImportClientRequest();
        // Set up your request object
        
        String correlationId = "correlationId";
        String token = "testToken";
        String clientId = "testClientId";
        
        ImportClientResponse response = new ImportClientResponse();
        // Set up your response object
        
        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn(token);
        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(Map.of("key", clientId));
        when(lossControlServiceImpl.clientPost(any(), eq(token))).thenReturn(response);

        ImportClientResponse result = importClientService.importClient("jsonString", correlationId);
        
        // Assert the results
        assertNotNull(result);
        assertEquals(response, result);

        // Verify that the methods were called with expected parameters
        verify(tokenCache).retrieveTokenFromCache(correlationId);
        verify(lossControlDao).findLc360ClientID(anyString());
        verify(lossControlServiceImpl).clientPost(any(), eq(token));
    }

    // Add more test methods for other functions in the ImportClientServiceImp class
}





import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;
import java.util.ArrayList;
import java.util.Map;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class ImportClientServiceImpTest3 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClient() throws Exception {
        ImportClientRequest request = new ImportClientRequest();
        // Set up your request object
        
        String correlationId = "correlationId";
        String token = "testToken";
        String clientId = "testClientId";
        
        ImportClientResponse response = new ImportClientResponse();
        // Set up your response object
        
        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn(token);
        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(Map.of("key", clientId));
        when(lossControlServiceImpl.clientPost(any(), eq(token))).thenReturn(response);

        ImportClientResponse result = importClientService.importClient("jsonString", correlationId);
        
        assertNotNull(result);  // Check that the result is not null
        // Add more specific assertions based on your expected results and the 'result' variable
    }

    // Add more test methods for other functions in the ImportClientServiceImp class
}

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;
import java.util.ArrayList;
import java.util.Map;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class ImportClientServiceImpTest4 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClient() throws Exception {
        ImportClientRequest request = new ImportClientRequest();
        // Set up your request object
        
        String correlationId = "correlationId";
        String token = "testToken";
        String clientId = "testClientId";
        
        ImportClientResponse response = new ImportClientResponse();
        // Set up your response object
        
        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn(token);
        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(Map.of("key", clientId));
        when(lossControlServiceImpl.clientPost(any(), eq(token))).thenReturn(response);

        ImportClientResponse result = importClientService.importClient("jsonString", correlationId);
        
        assertEquals(response, result); // Assert that the response matches the expected result
        
        verify(tokenCache).retrieveTokenFromCache(correlationId);
        verify(lossControlDao).findLc360ClientID(anyString());
        verify(lossControlServiceImpl).clientPost(any(), eq(token));
    }

    // Add more test methods for other functions in the ImportClientServiceImp class
}

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;
import java.util.ArrayList;
import java.util.Map;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class ImportClientServiceImpTest5 {

    @InjectMocks
    private ImportClientServiceImp importClientService;

    @Mock
    private TokenCache tokenCache;

    @Mock
    private LossControlDao lossControlDao;

    @Mock
    private LossControlServiceImpl lossControlServiceImpl;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testImportClient() throws Exception {
        ImportClientRequest request = new ImportClientRequest();
        // Set up your request object
        
        String correlationId = "correlationId";
        String token = "testToken";
        String clientId = "testClientId";
        
        ImportClientResponse response = new ImportClientResponse();
        // Set up your response object
        
        when(tokenCache.retrieveTokenFromCache(correlationId)).thenReturn(token);
        when(lossControlDao.findLc360ClientID(anyString())).thenReturn(Map.of("key", clientId));
        when(lossControlServiceImpl.clientPost(any(), eq(token))).thenReturn(response);

        ImportClientResponse result = importClientService.importClient("jsonString", correlationId);
        
        assertNotNull(result); // Check that the result is not null
        // Add more assertions based on the expected results and the 'result' variable
    }

    // Add more test methods for other functions in the ImportClientServiceImp class
}

//////////////
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

public class ValidationRestTest1 {

    @Mock
    private ValidationServiceImpl validationService;

    @Mock
    private ImportClientServiceImp importClientService;

    @InjectMocks
    private ValidationRest validationRest;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJson_ValidInput_Success() throws Exception {
        // Arrange
        String json = "{...}"; // Replace with valid JSON
        String correlationId = "correlationId";

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up mock behavior
        when(validationService.processJson(json)).thenReturn(json);
        when(importClientService.importClient(json, correlationId)).thenReturn(importClientResponse);
        importClientResponse.getResult().setSuccess(true);

        // Act
        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        // Assert
        assertEquals(HttpStatus.OK, response.getStatusCode());
        // Add more assertions if needed
    }

    @Test
    public void testProcessJson_ImportFailure_ReturnsUnprocessableEntity() throws Exception {
        // Arrange
        String json = "{...}"; // Replace with valid JSON
        String correlationId = "correlationId";

        ImportClientResponse importClientResponse = new ImportClientResponse();
        // Set up mock behavior
        when(validationService.processJson(json)).thenReturn(json);
        when(importClientService.importClient(json, correlationId)).thenReturn(importClientResponse);
        importClientResponse.getResult().setSuccess(false);
        importClientResponse.getResult().getErrors().add("Error message");

        // Act
        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        // Assert
        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        // Add more assertions if needed
    }

    @Test
    public void testProcessJson_InvalidJson_ReturnsBadRequest() throws Exception {
        // Arrange
        String json = "{...}"; // Replace with invalid JSON
        String correlationId = "correlationId";

        // Set up mock behavior
        when(validationService.processJson(json)).thenThrow(CustomException.class);

        // Act
        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        // Assert
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        // Add more assertions if needed
    }

    @Test
    public void testProcessJson_Exception_ReturnsInternalServerError() throws Exception {
        // Arrange
        String json = "{...}"; // Replace with valid JSON
        String correlationId = "correlationId";

        // Set up mock behavior
        when(validationService.processJson(json)).thenReturn(json);
        when(importClientService.importClient(json, correlationId)).thenThrow(Exception.class);

        // Act
        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        // Assert
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        // Add more assertions if needed
    }
}















import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class ValidationRestTest2 {

    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationService;

    @Mock
    private ImportClientServiceImp importClientService;

    @Mock
    private Logger logger;

    @Test
    public void testProcessJson_SuccessfulImport() throws CustomException, JsonProcessingException {
        String json = "{...}"; // Replace with your JSON data
        String correlationId = "123";

        // Mock validation service behavior
        when(validationService.processJson(json)).thenReturn(json);

        // Mock import client response
        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        importClientResponse.setResult(result);
        when(importClientService.importClient(json, correlationId)).thenReturn(importClientResponse);

        // Mock logger behavior
        when(logger.isInfoEnabled()).thenReturn(true);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Verify that the response entity is OK
        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());

        // Verify logger messages
        verify(logger).info(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_SUCCESS),
                " client imported Successfully in LC360 {}", HttpStatus.OK.value());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() throws CustomException, JsonProcessingException {
        String json = "{...}"; // Replace with your JSON data
        String correlationId = "123";

        // Mock validation service behavior
        when(validationService.processJson(json)).thenReturn(json);

        // Mock import client response
        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(Collections.singletonList("Invalid data"));
        importClientResponse.setResult(result);
        when(importClientService.importClient(json, correlationId)).thenReturn(importClientResponse);

        // Mock logger behavior
        when(logger.isInfoEnabled()).thenReturn(true);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Verify that the response entity is UNPROCESSABLE_ENTITY
        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, responseEntity.getStatusCode());

        // Verify logger messages
        verify(logger).info("Error: [Invalid data]");
        verify(logger).info(" client imported Unsuccessfully in LC360 {}", HttpStatus.UNPROCESSABLE_ENTITY);
    }

    @Test
    public void testProcessJson_InvalidJson() throws CustomException, JsonProcessingException {
        String json = ""; // Invalid JSON
        String correlationId = "123";

        // Mock logger behavior
        when(logger.isInfoEnabled()).thenReturn(true);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Verify that the response entity is BAD_REQUEST
        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());

        // Verify logger messages
        verify(logger).info("JSON is empty");
    }
}










import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class ValidationRestTest3 {

    @Mock
    private ValidationServiceImpl validationService;

    @Mock
    private ImportClientServiceImp importClientService;

    @InjectMocks
    private ValidationRest validationRest;

    @Test
    public void testProcessJson_Success() throws CustomException, JsonProcessingException {
        String json = "valid json data";
        String correlationId = "correlationId";

        String validateInput = "validated json data";
        ImportClientResponse importResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        importResponse.setResult(result);

        when(validationService.processJson(json)).thenReturn(validateInput);
        when(importClientService.importClient(validateInput, correlationId)).thenReturn(importResponse);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
        assertEquals(importResponse, responseEntity.getBody());

        verify(validationService, times(1)).processJson(json);
        verify(importClientService, times(1)).importClient(validateInput, correlationId);
    }

    @Test
    public void testProcessJson_Failure() throws CustomException, JsonProcessingException {
        String json = "valid json data";
        String correlationId = "correlationId";

        String validateInput = "validated json data";
        ImportClientResponse importResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        importResponse.setResult(result);

        when(validationService.processJson(json)).thenReturn(validateInput);
        when(importClientService.importClient(validateInput, correlationId)).thenReturn(importResponse);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, responseEntity.getStatusCode());

        verify(validationService, times(1)).processJson(json);
        verify(importClientService, times(1)).importClient(validateInput, correlationId);
    }

    @Test
    public void testProcessJson_InvalidJson() throws CustomException, JsonProcessingException {
        String json = "invalid json data";
        String correlationId = "correlationId";

        when(validationService.processJson(json)).thenThrow(new CustomException("Invalid JSON format"));

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());

        verify(validationService, times(1)).processJson(json);
        verify(importClientService, never()).importClient(any(), any());
    }

    @Test
    public void testProcessJson_Exception() throws CustomException, JsonProcessingException {
        String json = "valid json data";
        String correlationId = "correlationId";

        when(validationService.processJson(json)).thenReturn(json);
        when(importClientService.importClient(json, correlationId)).thenThrow(new RuntimeException("Some error"));

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, responseEntity.getStatusCode());

        verify(validationService, times(1)).processJson(json);
        verify(importClientService, times(1)).importClient(json, correlationId);
    }
}








import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class ValidationRestTest4 {

    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @Test
    public void testValidJsonImportSuccess() {
        // Arrange
        String json = "{...}"; // valid JSON
        String correlationId = "correlation-id";

        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        importClientResponse.setResult(result);

        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importClientResponse);

        // Act
        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Assert
        assertNotNull(responseEntity);
        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
        // You can also perform additional assertions based on the expected response
    }

    @Test
    public void testValidJsonImportFailure() {
        // Arrange
        String json = "{...}"; // valid JSON
        String correlationId = "correlation-id";

        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(Arrays.asList("Error 1", "Error 2"));
        importClientResponse.setResult(result);

        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importClientResponse);

        // Act
        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Assert
        assertNotNull(responseEntity);
        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, responseEntity.getStatusCode());
        // You can also perform additional assertions based on the expected response
    }

    @Test
    public void testInvalidJson() {
        // Arrange
        String json = "invalid JSON";
        String correlationId = "correlation-id";

        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Invalid JSON"));

        // Act
        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Assert
        assertNotNull(responseEntity);
        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());
        // You can also perform additional assertions based on the expected response
    }

    @Test
    public void testInternalServerError() {
        // Arrange
        String json = "{...}"; // valid JSON
        String correlationId = "correlation-id";

        when(validationServiceImpl.processJson(json)).thenReturn(json);

        when(importClientServiceImp.importClient(json, correlationId)).thenThrow(new RuntimeException("Some error occurred"));

        // Act
        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        // Assert
        assertNotNull(responseEntity);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, responseEntity.getStatusCode());
        // You can also perform additional assertions based on the expected response
    }
}












import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class ValidationRestTest5 {

    @Mock
    private ValidationServiceImpl validationService;

    @Mock
    private ImportClientServiceImp importClientService;

    @InjectMocks
    private ValidationRest validationRest;

    @Test
    public void testProcessJson_SuccessfulImport() throws Exception {
        String json = "valid_json";
        String correlationId = "correlation_id";

        // Mocking validationService.processJson
        when(validationService.processJson(json)).thenReturn(json);

        // Mocking importClientService.importClient
        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        importClientResponse.setResult(result);
        when(importClientService.importClient(json, correlationId)).thenReturn(importClientResponse);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
        assertNotNull(responseEntity.getBody());
    }

    @Test
    public void testProcessJson_FailedImport() throws Exception {
        String json = "valid_json";
        String correlationId = "correlation_id";

        // Mocking validationService.processJson
        when(validationService.processJson(json)).thenReturn(json);

        // Mocking importClientService.importClient
        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        List<Object> errors = new ArrayList<>();
        errors.add("Error message");
        result.setErrors(errors);
        importClientResponse.setResult(result);
        when(importClientService.importClient(json, correlationId)).thenReturn(importClientResponse);

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, responseEntity.getStatusCode());
        assertNotNull(responseEntity.getBody());
    }

    @Test
    public void testProcessJson_InvalidJson() throws Exception {
        String json = ""; // Invalid JSON
        String correlationId = "correlation_id";

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());
        assertNotNull(responseEntity.getBody());
    }

    @Test
    public void testProcessJson_CustomException() throws Exception {
        String json = "valid_json";
        String correlationId = "correlation_id";

        // Mocking validationService.processJson to throw CustomException
        when(validationService.processJson(json)).thenThrow(new CustomException("Custom error message"));

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());
        assertNotNull(responseEntity.getBody());
    }

    @Test
    public void testProcessJson_Exception() throws Exception {
        String json = "valid_json";
        String correlationId = "correlation_id";

        // Mocking validationService.processJson
        when(validationService.processJson(json)).thenReturn(json);

        // Mocking importClientService.importClient to throw Exception
        when(importClientService.importClient(json, correlationId)).thenThrow(new Exception("General exception"));

        ResponseEntity<?> responseEntity = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, responseEntity.getStatusCode());
        assertNotNull(responseEntity.getBody());
    }
}













java.lang.NullPointerException: Cannot invoke "uk.co.allianz.rap.lc.service.ValidationServiceImpl.processJson(String)" because "this.validationServiceImpl" is null
        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));


        when(validationServiceImpl.processJson(json)).thenReturn(json);




import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest1 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(new ArrayList<>());
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_ValidationFailure() {
        String json = "{\"invalidJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation to throw an exception
        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}








import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest2 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        importClientResponse.setResult(result);

        when(validationServiceImpl.processJson(json)).thenReturn(json);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importClientResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        ImportClientResponse importClientResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(new ArrayList<>());
        importClientResponse.setResult(result);

        when(validationServiceImpl.processJson(json)).thenReturn(json);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importClientResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_ProcessedJsonNull() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        when(validationServiceImpl.processJson(json)).thenReturn(json);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(null);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertNull(response.getBody());
    }

    @Test
    public void testProcessJson_ProcessedJsonResultNull() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        ImportClientResponse importClientResponse = new ImportClientResponse();

        when(validationServiceImpl.processJson(json)).thenReturn(json);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importClientResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertNull(response.getBody());
    }

    @Test
    public void testProcessJson_CustomException() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}


///
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importclient.Result;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest3 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response with successful import
        ImportClientResponse importResponse = createSuccessfulImportResponse();
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response with unsuccessful import
        ImportClientResponse importResponse = createUnsuccessfulImportResponse();
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(importResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_ValidationFailure() {
        String json = "{\"invalidJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    // Helper method to create a successful ImportClientResponse
    private ImportClientResponse createSuccessfulImportResponse() {
        ImportClientResponse importResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        importResponse.setResult(result);
        return importResponse;
    }

    // Helper method to create an unsuccessful ImportClientResponse
    private ImportClientResponse createUnsuccessfulImportResponse() {
        ImportClientResponse importResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(new ArrayList<>());
        importResponse.setResult(result);
        return importResponse;
    }
}


















import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest3 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(new ArrayList<>());
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_ValidationFailure() {
        String json = "{\"invalidJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation to throw an exception
        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_GeneralException() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response to throw a general exception
        when(importClientServiceImp.importClient(json, correlationId)).thenThrow(new RuntimeException("Import failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}



//////////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest2 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(true);
        mockResponse.setResult(lookupResult);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(false);
        lookupResult.setErrors(new ArrayList<>()); // Simulating errors
        mockResponse.setResult(lookupResult);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }
    
    // Additional test case targeting specific ImportClientResponse scenarios
    @Test
    public void testProcessJson_ImportResponseIsNull() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response to be null
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(null);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertNotNull(response.getBody());
    }
    
    // Additional test case targeting specific Result scenarios
    @Test
    public void testProcessJson_ImportFailureWithErrors() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(false);
        lookupResult.setErrors(new ArrayList<>()); // Simulating errors
        mockResponse.setResult(lookupResult);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}






/////////////////////////////////////
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importclient.Result;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class ValidationRestTest1 {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @BeforeEach
    void setUp() {
        // Initialize mocks if needed
    }

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(true);
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation and import responses
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        ImportClientResponse mockResponse = new ImportClientResponse();
        Result result = new Result();
        result.setSuccess(false);
        result.setErrors(new ArrayList<>());
        mockResponse.setResult(result);
        when(importClientServiceImp.importClient(json, correlationId)).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_ValidationFailure() {
        String json = "{\"invalidJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation to throw an exception
        when(validationServiceImpl.processJson(json)).thenThrow(new CustomException("Validation failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
    }

    @Test
    public void testProcessJson_GeneralException() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        // Mock validation response
        when(validationServiceImpl.processJson(json)).thenReturn(json);

        // Mock import response to throw a general exception
        when(importClientServiceImp.importClient(json, correlationId)).thenThrow(new RuntimeException("Import failed"));

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}










////////////////////////////////////
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.model.response.importclient.ClientLookupResult;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

public class ValidationRestTest {
    @InjectMocks
    private ValidationRest validationRest;

    @Mock
    private ImportClientServiceImp importClientServiceImp;

    @Test
    public void testProcessJson_SuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(true);
        mockResponse.setResult(lookupResult);

        when(importClientServiceImp.importClient(Mockito.any(), Mockito.any())).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.OK, response.getStatusCode());
    }

    @Test
    public void testProcessJson_UnsuccessfulImport() {
        String json = "{\"validJson\": \"data\"}";
        String correlationId = "correlationId";

        ImportClientResponse mockResponse = new ImportClientResponse();
        ClientLookupResult lookupResult = new ClientLookupResult();
        lookupResult.setSuccess(false);
        lookupResult.setErrors("Import failed");
        mockResponse.setResult(lookupResult);

        when(importClientServiceImp.importClient(Mockito.any(), Mockito.any())).thenReturn(mockResponse);

        ResponseEntity<?> response = validationRest.processJson(json, correlationId);

        assertEquals(HttpStatus.UNPROCESSABLE_ENTITY, response.getStatusCode());
    }
}





















if (processedJson != null && processedJson.getResult() != null) {
    if (processedJson.getResult().isSuccess()) {
        // ...
    } else {
        // ...
    }
}






public ArrayList<Location> locationResponse(ArrayList<Location> locations) {
    ArrayList<Location> validLocations = new ArrayList<>();
    
    for (Location location : locations) {
        if (location.getLookupID() != null) {
            validLocations.add(location);
        }
    }
    
    return validLocations;
}



////
public ArrayList<Location> locationResponse(ArrayList<Location> locations) {
    ArrayList<Location> validLocations = new ArrayList<>();

    for (Location location : locations) {
        String lookupID = location.getLookupID();
        System.out.println("LookupID: " + lookupID);

        if (lookupID != null) {
            validLocations.add(location);
        }
    }

    return validLocations;
}










// ... (existing imports)

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        if (clientResult != null) {
            LOGGER.info("Client is present");
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            importClientRequest.getClient().setLookupID(lc360ClientId);

            for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID());
                if (locationResult != null) {
                    LOGGER.info("Location is present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    location.setLookupID(lc360LocationId);
                }
            }

            objectMapper.writeValueAsString(importClientRequest);
            LOGGER.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                    System.out.println("lc360ClientId: " + lc360ClientId);
                }
            }
        } else {
            LOGGER.info("Client is not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
                }
            }
        }

        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}






// ... (import statements and annotations)

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);

    // Autowired fields...

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        if (clientResult != null) {
            LOGGER.info("Client is present");
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            importClientRequest.getClient().setLookupID(lc360ClientId);
            
            for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID());

                if (locationResult != null) {
                    LOGGER.info("Location is present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    location.setLookupID(lc360LocationId);
                }

                objectMapper.writeValueAsString(importClientRequest);
                LOGGER.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                    System.out.println("lc360ClientId: " + lc360ClientId);
                }
            }
        } else {
            LOGGER.info("Client is not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
                }
            }
        }
        
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}






// ... Existing imports ...

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        if (clientResult != null) {
            LOGGER.info("Client is present");
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            
            // Process each location
            for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID());
                
                if (locationResult != null) {
                    LOGGER.info("Location is present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    location.setLookupID(lc360LocationId);
                }
            }
            
            importClientRequest.getClient().setLookupID(lc360ClientId);
            objectMapper.writeValueAsString(importClientRequest);
            
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            
            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                }
            }
        } else {
            LOGGER.info("Client is not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.insertData(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
                }
            }
        }
        
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}










ArrayList<Location> locations = importClientRequest.getClient().getLocations();

for (int index = 0; index < locations.size(); index++) {
    String lookupID = locations.get(index).getLookupID();
    System.out.println("LookupID at index " + index + ": " + lookupID);
}









ArrayList<Location> locations = importClientRequest.getClient().getLocations();

for (int index = 0; index < locations.size(); index++) {
    String lookupID = locations.get(index).getLookupID();
    int position = index + 1;
    System.out.println("LookupID " + position + ": " + lookupID);
}






ArrayList<Location> locations = importClientRequest.getClient().getLocations();
int count = 1;

for (Location location : locations) {
    String lookupID = location.getLookupID();
    System.out.println("LookupID " + count + ": " + lookupID);
    count++;
}




ArrayList<Location> locations = importClientRequest.getClient().getLocations();

for (Location location : locations) {
    String lookupID = location.getLookupID();
    System.out.println("LookupID: " + lookupID);
}






package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;

public class ValidationServiceImplTestb {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @InjectMocks
    private ValidationServiceImpl validationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(true);

        String json = "\"John\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(Mockito.any())).thenReturn(false);

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(true);

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(true);

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithObjectThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(Mockito.any())).thenReturn(true);

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }
}

//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class ValidationServiceImplTesta {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @InjectMocks
    private ValidationServiceImpl validationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJson() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "\"John\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();
        when(validationServiceImpl.isEmptyObject(any())).thenCallRealMethod();

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithSingleValueJson() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithObject() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();
        when(validationServiceImpl.isEmptyObject(any())).thenCallRealMethod();

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }
}




///
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class ValidationServiceImplTestC {
    @InjectMocks
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ValidationServiceImpl mockValidationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(mockValidationService.isSingleValue(any())).thenReturn(true);
        doCallRealMethod().when(mockValidationService).processJson(anyString());

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> mockValidationService.processJson(json));

        verify(mockValidationService).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(mockValidationService.isSingleValue(any())).thenReturn(true);
        doCallRealMethod().when(mockValidationService).processJson(anyString());

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> mockValidationService.processJson(json));

        verify(mockValidationService).isSingleValue(any());
    }

    // ... other test methods ...
}


//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;

public class ValidationServiceImplTestB {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @InjectMocks
    private ValidationServiceImpl validationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJson() {
        String json = "\"John\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() {
        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithSingleValueJson() {
        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithObject() {
        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }
}

//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class ValidationServiceImplTestA {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @InjectMocks
    private ValidationServiceImpl realValidationServiceImpl;

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> realValidationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> realValidationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithObjectThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(true);

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(false);

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }
}


//////
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.mockito.Mockito.*;

public class ValidationServiceImplTest {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(true);

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(true);

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithObjectThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(true);

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(false);

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }
}
