public ArrayList<Location> locationResponse(ArrayList<Location> locations) {
    ArrayList<Location> validLocations = new ArrayList<>();
    
    for (Location location : locations) {
        if (location.getLookupID() != null) {
            validLocations.add(location);
        }
    }
    
    return validLocations;
}



////
public ArrayList<Location> locationResponse(ArrayList<Location> locations) {
    ArrayList<Location> validLocations = new ArrayList<>();

    for (Location location : locations) {
        String lookupID = location.getLookupID();
        System.out.println("LookupID: " + lookupID);

        if (lookupID != null) {
            validLocations.add(location);
        }
    }

    return validLocations;
}










// ... (existing imports)

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        if (clientResult != null) {
            LOGGER.info("Client is present");
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            importClientRequest.getClient().setLookupID(lc360ClientId);

            for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID());
                if (locationResult != null) {
                    LOGGER.info("Location is present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    location.setLookupID(lc360LocationId);
                }
            }

            objectMapper.writeValueAsString(importClientRequest);
            LOGGER.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                    System.out.println("lc360ClientId: " + lc360ClientId);
                }
            }
        } else {
            LOGGER.info("Client is not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
                }
            }
        }

        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}






// ... (import statements and annotations)

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);

    // Autowired fields...

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        if (clientResult != null) {
            LOGGER.info("Client is present");
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            importClientRequest.getClient().setLookupID(lc360ClientId);
            
            for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID());

                if (locationResult != null) {
                    LOGGER.info("Location is present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    location.setLookupID(lc360LocationId);
                }

                objectMapper.writeValueAsString(importClientRequest);
                LOGGER.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                    System.out.println("lc360ClientId: " + lc360ClientId);
                }
            }
        } else {
            LOGGER.info("Client is not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
                }
            }
        }
        
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}






// ... Existing imports ...

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        
        if (clientResult != null) {
            LOGGER.info("Client is present");
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            
            // Process each location
            for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID());
                
                if (locationResult != null) {
                    LOGGER.info("Location is present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    location.setLookupID(lc360LocationId);
                }
            }
            
            importClientRequest.getClient().setLookupID(lc360ClientId);
            objectMapper.writeValueAsString(importClientRequest);
            
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            
            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                }
            }
        } else {
            LOGGER.info("Client is not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.insertData(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());

            for (Location location : locations) {
                if (location.getLookupID() != null) {
                    LOGGER.info("Location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(location.getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
                }
            }
        }
        
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}










ArrayList<Location> locations = importClientRequest.getClient().getLocations();

for (int index = 0; index < locations.size(); index++) {
    String lookupID = locations.get(index).getLookupID();
    System.out.println("LookupID at index " + index + ": " + lookupID);
}









ArrayList<Location> locations = importClientRequest.getClient().getLocations();

for (int index = 0; index < locations.size(); index++) {
    String lookupID = locations.get(index).getLookupID();
    int position = index + 1;
    System.out.println("LookupID " + position + ": " + lookupID);
}






ArrayList<Location> locations = importClientRequest.getClient().getLocations();
int count = 1;

for (Location location : locations) {
    String lookupID = location.getLookupID();
    System.out.println("LookupID " + count + ": " + lookupID);
    count++;
}




ArrayList<Location> locations = importClientRequest.getClient().getLocations();

for (Location location : locations) {
    String lookupID = location.getLookupID();
    System.out.println("LookupID: " + lookupID);
}






package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;

public class ValidationServiceImplTestb {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @InjectMocks
    private ValidationServiceImpl validationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(true);

        String json = "\"John\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(Mockito.any())).thenReturn(false);

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(true);

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(true);

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithObjectThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(Mockito.any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(Mockito.any())).thenReturn(true);

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }
}

//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class ValidationServiceImplTesta {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @InjectMocks
    private ValidationServiceImpl validationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJson() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "\"John\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();
        when(validationServiceImpl.isEmptyObject(any())).thenCallRealMethod();

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithSingleValueJson() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithObject() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();
        when(validationServiceImpl.isEmptyObject(any())).thenCallRealMethod();

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }
}




///
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class ValidationServiceImplTestC {
    @InjectMocks
    private ValidationServiceImpl validationServiceImpl;

    @Mock
    private ValidationServiceImpl mockValidationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(mockValidationService.isSingleValue(any())).thenReturn(true);
        doCallRealMethod().when(mockValidationService).processJson(anyString());

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> mockValidationService.processJson(json));

        verify(mockValidationService).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(mockValidationService.isSingleValue(any())).thenReturn(true);
        doCallRealMethod().when(mockValidationService).processJson(anyString());

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> mockValidationService.processJson(json));

        verify(mockValidationService).isSingleValue(any());
    }

    // ... other test methods ...
}


//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;

public class ValidationServiceImplTestB {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @InjectMocks
    private ValidationServiceImpl validationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJson() {
        String json = "\"John\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() {
        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithSingleValueJson() {
        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }

    @Test
    public void testProcessJsonWithObject() {
        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationService.processJson(json));
    }
}

//
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class ValidationServiceImplTestA {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @InjectMocks
    private ValidationServiceImpl realValidationServiceImpl;

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> realValidationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenCallRealMethod();

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> realValidationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithObjectThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(true);

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(false);

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }
}


//////
package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.mockito.Mockito.*;

public class ValidationServiceImplTest {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(true);

        String json = "\"value\"";
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithSingleValueJsonThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(true);

        String json = "123"; // Single value JSON
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
    }

    @Test
    public void testProcessJsonWithObjectThrowsCustomException() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(true);

        String json = "[]"; // Empty JSON Object / Array
        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }

    @Test
    public void testProcessJsonNoExceptionThrown() throws CustomException, JsonProcessingException {
        when(validationServiceImpl.isSingleValue(any())).thenReturn(false);
        when(validationServiceImpl.isEmptyObject(any())).thenReturn(false);

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationServiceImpl.processJson(json));

        verify(validationServiceImpl).isSingleValue(any());
        verify(validationServiceImpl).isEmptyObject(any());
    }
}
