ArrayList<Location> sameLocations = new ArrayList<>();
ArrayList<Location> differentLocations = new ArrayList<>();

for (int index = 0; index < importClientRequestLocations.size(); index++) {
    Location importClientRequestLocation = importClientRequestLocations.get(index);
    Location otherLocation = otherLocations.get(index);

    if (importClientRequestLocation.equals(otherLocation)) {
        sameLocations.add(importClientRequestLocation); // Add the same location to the sameLocations list
    } else {
        differentLocations.add(importClientRequestLocation); // Add the different location to the differentLocations list
    }
}

if (!sameLocations.isEmpty()) {
    // Return the list of same locations in the if block
    return sameLocations;
} else {
    // Return the list of different locations in the else block
    return differentLocations;
}














boolean isValid = true; // Initialize the isValid flag to true

if (importClientRequest.getClient() == null) {
    LOGGER.info("Client is null");
    isValid = false; // Set the flag to false if client is null
}

for (Location location : locations) {
    if (location == null) {
        LOGGER.info("Location is null");
        isValid = false; // Set the flag to false if any location is null
    }




// for validation
for (Location location : locations) {
    if (importClientRequest.getClient() == null) {
        throw new CustomValidationException("Client is null");
    }
    
    if (location == null) {
        throw new CustomValidationException("Location is null");
    }











for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID() + "_" + clientID);
                if (locationResult != null) {
                    //            //3a. If lookup value exists for the loc,
                    LOGGER.info("Location are present in DB");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    //3a.1 Update the lc360 loc id in request.
                    location.setLookupID(lc360LocationId);
                    objectMapper.writeValueAsString(importClientRequest);
                    LOGGER.info("Received JSON");
//                    3a.3 Send the modified request back
                    importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
                } else {
                    //look up doesn’t exist)
                    objectMapper.writeValueAsString(importClientRequest);
                    LOGGER.info("Received JSON");
                    LOGGER.info("Location are not present in DB");
                    //3a.1 Use the same JSON request
//                    Send the same request back
                    //. Invoke LC360
                    importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
                    for (int index = 0; index < locations.size(); index++) {
                        String lookupID = locations.get(index).getLookupID();
                        if (locations.get(index).getLookupID() != null) {
                            LOGGER.info("location LookUpID is not null");// location not present in DB
                            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                            //4a. Process Response
                            lossControlDao.insertLocationData(locations.get(index).getLookupID() + "_" + clientID, locationsResponse.get(index).getLocationLookupID());
                        }
                    }
                }
            }

/////////////////////////////////////


package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        Map<String, Object> locationResult = lossControlDao.findLc360LocationID(locations.get(0).getLookupID());
        if (clientResult != null) {
            LOGGER.info("Client are present");
            //performed locationLookup
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            //set client id and location id in pojo
            importClientRequest.getClient().setLookupID(lc360ClientId);//
            //location
            if (locationResult != null) {
                LOGGER.info("Location are present");
                String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                locations.get(0).setLookupID(lc360LocationId);
            }
            objectMapper.writeValueAsString(importClientRequest);
            LOGGER.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            if (locations.get(0).getLookupID() != null ) {
                LOGGER.info("location LookUpID is not null");
                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                lossControlDao.insertLocationData(locations.get(0).getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                System.out.println("lc360ClientId:"+lc360ClientId);
            }
        }

            return importClientResponse;
        } else {
            LOGGER.info("Client are not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));//check condition if null not come here
            lossControlDao.insertData(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());

            if (locations.get(0).getLookupID() != null) {
                LOGGER.info("location LookUpID is not null");
                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                lossControlDao.insertLocationData(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
            }
        }
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}



































//Fixed my code //find bugs //detect the error in code

package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        String clientID = importClientRequest.getClient().getLookupID();

        if (clientResult != null) {
            LOGGER.info("Client are present");
            ArrayList<Location> locations = importClientRequest.getClient().getLocations();

            for (int index = 0; index < locations.size(); index++) {
                String lookupID = locations.get(index).getLookupID();
                System.out.println("LookupID at index " + index + ": " + lookupID);
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(locations.get(index).getLookupID());
                //performed locationLookup
                String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
                //set client id and location id in pojo
                importClientRequest.getClient().setLookupID(lc360ClientId);

                if (locationResult != null) {
                    LOGGER.info("Location are present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    locations.get(index).setLookupID(lc360LocationId);
                }
                objectMapper.writeValueAsString(importClientRequest);
                LOGGER.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
                if (locations.get(index).getLookupID() != null) {
                    LOGGER.info("location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(locations.get(index).getLookupID() + "_" + clientID, locationsResponse.get(index).getLocationLookupID());
                    System.out.println("lc360ClientId:" + lc360ClientId);
                }
            }

//            if(locationResult != null){
//                LOGGER.info("location not present ");
//                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
//                lossControlDao.insertLocationData(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());            }

            return importClientResponse;
        } else {
            LOGGER.info("Client are not present");

            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));//check condition if null not come here
            lossControlDao.insertData(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            //
            ArrayList<Location> locations1 = importClientRequest.getClient().getLocations();

            for (int index = 0; index < locations1.size(); index++) {
                String lookupID = locations1.get(index).getLookupID();
                System.out.println("LookupID at index " + index + ": " + lookupID);
                //
                if (locations1.get(index).getLookupID() != null) {
                    LOGGER.info("location LookUpID is not null");//location not present in DB
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(locations1.get(index).getLookupID() + "_" + clientID, locationsResponse.get(index).getLocationLookupID());
                }
            }
        }
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}





































for (int index = 0; index < locations.size(); index++) {
                String lookupID = locations.get(index).getLookupID();
                System.out.println("LookupID at index " + index + ": " + lookupID);
                //
            if (locations.get(index).getLookupID() != null) {
                LOGGER.info("location LookUpID is not null");
                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                lossControlDao.insertLocationData(locations.get(index).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(index).getLocationLookupID());
                }
            }










package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory
            .getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        //checking value already in DB or not ?
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        //need flag...Client ID really exits in DB..Do i need to update ?

        if (clientResult != null) {//Instead of flag here we used clientResult...Client and Location are present ? ... no need to insert in DB
            LOGGER.info("Client and Location are present"); // so no need to insert ... line 53
            //performed locationLookup
            for (int index = 0; index < locations.size(); index++) {
                String lookupID = locations.get(index).getLookupID();
                System.out.println("LookupID at index " + index + ": " + lookupID);
                Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(lookupID + "_" + importClientRequest.getClient().getLookupID());
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                locations.get(index).setLookupID(lc360LocationId);
            }

            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            //set client id and location id in pojo
            importClientRequest.getClient().setLookupID(lc360ClientId);
            objectMapper.writeValueAsString(importClientRequest);
            LOGGER.info("Received JSON");
            //passing enriched importClientRequest file ...request contains updated Client + Location >>invoking LC360
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            return importClientResponse;
        } else {
            LOGGER.info("Client and Location are not present");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.insertData(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();

            for (int index = 0; index < locations.size(); index++) {
                String lookupID = locations.get(index).getLookupID();
                System.out.println("LookupID at index " + index + ": " + lookupID);
                lossControlDao.insertLocationData(locations.get(index).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(index).getLocationLookupID());
            }
        }
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}
















//    public ImportClientResponse getClientResponse(final ImportClientRequest importClientRequest, final ArrayList<Location> locations, final String correlationId) throws CustomException {
//        LOGGER.info("Client and Location are not present");
//        ImportClientResponse importClientResponse = null;
//        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
//        lossControlDao.insertData(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
//        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
//        lossControlDao.insertLocationData(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
//        return importClientResponse;
//    }


//    public ImportClientResponse ifClientIsPresent(final ImportClientRequest importClientRequest, final ArrayList<Location> locations, final String correlationId) throws CustomException, JsonProcessingException {
//        if (importClientRequest == null) {
//            return null;
//        }
//        //finding LC360 client id in DB exist or not
//        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
//        ImportClientResponse importClientResponse = null;
//        //finding LC360 location id in DB exist or not(combined location lookup ID and client id)
//        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID());
//        if (lcClientId != null) {
//            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
//            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
//            //set client id and location id in pojo
//            importClientRequest.getClient().setLookupID(lc360ClientId);
//            locations.get(0).setLookupID(lc360LocationId);
//            objectMapper.writeValueAsString(importClientRequest);
//            LOGGER.info("Received JSON");
//            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
//
//        }
//        return importClientResponse;
//    }
//}





//package uk.co.allianz.rap.lc.service;
//
//import com.fasterxml.jackson.core.JsonProcessingException;
//import com.fasterxml.jackson.databind.ObjectMapper;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.stereotype.Service;
//import uk.co.allianz.rap.lc.cache.TokenCache;
//import uk.co.allianz.rap.lc.dao.LossControlDao;
//import uk.co.allianz.rap.lc.exception.CustomException;
//import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
//import uk.co.allianz.rap.lc.model.request.importclient.Location;
//import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
//
//import java.util.ArrayList;
//import java.util.Map;
//
//import ch.qos.logback.classic.Logger;
//import org.slf4j.LoggerFactory;
//
///**
// * Extracting fields and data from the "data model".
// * sent from loss-control-adapter and building the API request: ImportClient
// */
//
//@Service
//public class ImportClientServiceImp implements ImportClientService {
//    private static final Logger LOGGER = (Logger) LoggerFactory
//            .getLogger(ImportClientServiceImp.class);
//    @Autowired
//    private TokenCache tokenCache;
//    @Autowired
//    private LossControlDao lossControlDao;
//    @Autowired
//    private LossControlServiceImpl lossControlServiceImpl;
//    @Autowired
//    private ObjectMapper objectMapper;
//
//    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
//        ImportClientResponse importClientResponse = null;
//        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
//        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
//        //finding client id in DB exist or not
//        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
//        if (clientResult != null) {
//            importClientResponse = ifClientIsPresent(importClientRequest, locations, correlationId);// changed the method name ifClientIsPresent
//        } else {
//            importClientResponse = getClientResponse(importClientRequest, locations, correlationId);
//        }
//        LOGGER.info("importClientResponse Successfully Received");
//        return importClientResponse;
//
//    }
//
//    public ImportClientResponse getClientResponse(final ImportClientRequest importClientRequest, final ArrayList<Location> locations, final String correlationId) throws CustomException {
//        LOGGER.info("Client and Location are not present");
//        ImportClientResponse importClientResponse = null;
//        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
//        lossControlDao.insertLocationId(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID());
//        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
//        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
//        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
//        // Lookup ID Response
//        lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
////boiller plate code here.. smae code again and again// clint creation ekach method ni whawi.. client creation importclient method madhun whavi
//        return importClientResponse;
//    }
//
//
//    public ImportClientResponse ifClientIsPresent(final ImportClientRequest importClientRequest, final ArrayList<Location> locations, final String correlationId) throws CustomException, JsonProcessingException {
//        if (importClientRequest == null) {
//            return null;
//        }
//        //finding LC360 client id in DB exist or not
//        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
//        ImportClientResponse importClientResponse = null;
//        //finding LC360 location id in DB exist or not(combined location lookup ID and client id)
//        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID());
//        if (lcClientId != null) {
//            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
//            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
//            //set client id and location id in pojo
//            importClientRequest.getClient().setLookupID(lc360ClientId);
//            locations.get(0).setLookupID(lc360LocationId);
//            objectMapper.writeValueAsString(importClientRequest);
//            LOGGER.info("Received JSON");
//            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
//
//        }
//        return importClientResponse;
//    }
//}








///////

ArrayList<Location> locations = importClientRequest.getClient().getLocations();
            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID());
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());








{
    "divisionLookupID": "AZ_UK",
    "client": {
        "LookupID": "C008032901",
        "ContactFirstName": null,
        "ContactLastName": null,
        "PolicyNumber": "SP26853149",
        "Name": "CLIENT CI Test",
        "Phone": null,
        "Email": null,
        "Address": {
            "Country": "United Kingdom",
            "OverseasTerritories": null,
            "Street1": null,
            "Street2": null,
            "City": null,
            "Region1": null,
            "Region2": null,
            "Region3": null,
            "Region4": null,
            "ZipCode": null
        },
        "Agent": {
            "AgencyCode": "22576",
            "AgencyName": "Arthur J. Gallagher",
            "AgentCode": "13332",
            "AgentName": null,
            "Email": null,
            "FaxNumber": null,
            "PhoneNumber": null,
            "Address": {
                "Country": "GB",
                "OverseasTerritories": null,
                "Street1": null,
                "Street2": null,
                "City": null,
                "Region1": null,
                "Region2": null,
                "Region3": null,
                "Region4": null,
                "ZipCode": null
            },
            "AgentType": "Broker"
        },
        "Underwriter": null,
        "Locations": [
            {
                "genericFields": null,
                "LookupID": "111901",
                "Name": null,
                "PolicyNumber": "SP26853148",
                "PolicyEffectiveDate": null,
                "PolicyExpirationDate": null,
                "PolicyRenewalDate": null,
                "Address": {
                    "Country": "United Kingdom",
                    "OverseasTerritories": null,
                    "Street1": "NEW CROSS DEWEL",
                    "Street2": "SD 11 JEW TOWN",
                    "City": "MM KEMSTONE",
                    "Region1": "UK",
                    "Region2": null,
                    "Region3": null,
                    "Region4": null,
                    "ZipCode": "GU1 1DB"
                },
                "OriginalEffectiveDate": null,
                "EffectiveDate": null,
                "ExpirationDate": null,
                "RenewalDate": "2024-07-17",
                "LastInspectedDate": null,
                "Coverages": [
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "CoverageReference": "Coverage 1",
                        "GenericFields": [
                            {
                                "Number": "1123",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "0",
                                "Key": "04. PD Other",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": null,
                                "Key": "05. PD Other Description",
                                "GenericFieldValueType": 0,
                                "Text": ""
                            },
                            {
                                "Number": "1123",
                                "Key": "06. TIV PD",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "332198",
                                "Key": "07. TIV BI",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "",
                                "Key": "08. BI Base Period (Months)",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "332198",
                                "Key": "09. TIV (PD + BI )",
                                "GenericFieldValueType": 1,
                                "Text": null
                            }
                        ]
                    }
                ],
                "Contact": null
            },
            {
                "genericFields": null,
                "LookupID": "111902",
                "Name": null,
                "PolicyNumber": "SP26853148",
                "PolicyEffectiveDate": null,
                "PolicyExpirationDate": null,
                "PolicyRenewalDate": null,
                "Address": {
                    "Country": "United Kingdom",
                    "OverseasTerritories": null,
                    "Street1": "NEW CROSS DEWEL",
                    "Street2": "SD 11 JEW TOWN",
                    "City": "MM KEMSTONE",
                    "Region1": "UK",
                    "Region2": null,
                    "Region3": null,
                    "Region4": null,
                    "ZipCode": "GU1 1DB"
                },
                "OriginalEffectiveDate": null,
                "EffectiveDate": null,
                "ExpirationDate": null,
                "RenewalDate": "2024-07-17",
                "LastInspectedDate": null,
                "Coverages": [
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "CoverageReference": "Coverage 1",
                        "GenericFields": [
                            {
                                "Number": "1123",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "0",
                                "Key": "04. PD Other",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": null,
                                "Key": "05. PD Other Description",
                                "GenericFieldValueType": 0,
                                "Text": ""
                            },
                            {
                                "Number": "1123",
                                "Key": "06. TIV PD",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "332198",
                                "Key": "07. TIV BI",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "",
                                "Key": "08. BI Base Period (Months)",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "332198",
                                "Key": "09. TIV (PD + BI )",
                                "GenericFieldValueType": 1,
                                "Text": null
                            }
                        ]
                    }
                ],
                "Contact": null
            }
        ]
    }
}







package uk.co.allianz.rap.lc.rest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;
import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;


@RestController
public class ValidationRest {
    private static final Logger LOGGER = (Logger) LoggerFactory
            .getLogger(ValidationRest.class);
    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    /***
     * Build the end point/Resource path: POST: surveySubmission
     *     Build standard JSON validation on incoming data
     *     Consumed the correlation id.
     */
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<?> processJson(@RequestBody(required = false) final String json, @RequestHeader("Correlation-ID") final String correlationId) {
        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            LOGGER.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");
        }
        try {
            //for validate JSON
            String validateInput = validationServiceImpl.processJson(json);
            //For import only client
            ImportClientResponse processedJson = importClientServiceImp.importClient(validateInput, correlationId);
            //log.info("JSON received successfully");
//           int httpStatusCode= processedJson.get("statusCode").ge
            LOGGER.info(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_SUCCESS), " client imported Successfully in LC360 {}", HttpStatus.OK.value());
            return ResponseEntity.ok(processedJson);
        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            if (LOGGER.isErrorEnabled()) {
                LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Import Client request Failed in LC360 {}", HttpStatus.BAD_REQUEST.value());
            }
            return ResponseEntity.badRequest().body(e.getMessage());
        } catch (Exception e) {
            // Other exceptions
            LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Invalid JSON: {} ", HttpStatus.INTERNAL_SERVER_ERROR.value());
            return ResponseEntity.internalServerError().body("Invalid JSON format");
        }
    }
}




























ImportClientResponse processedJson = importClientServiceImp.importClient(validateInput, correlationId);







issues:

Issue Detail
Below is an enumeration of all issues found in the project. The issues are organized by priority and
category and then broken down by the package, namespace, or location in which they occur.
The priority of an issue can be Critical, High, Medium, or Low.
Issues from static analysis reported on at same line number with the same category originate from
different taint sources.
7.1.1 Dockerfile Misconfiguration: Default User Privilege
CWE-20
OWASP Top 10: A6
PCI 3.2: 6.5.6 High Risk Vulnerabilities
Summary
The Dockerfile does not specify a USER, so it defaults to running with a root user.
Explanation
When a Dockerfile does not specify a USER , Docker containers run with super user privileges by
default. These super user privileges are propagated to the code running inside the container, which is
usually more permission than necessary. Running the Docker container with super user privileges
broadens the attack surface which might enable attackers to perform more serious forms of
exploitation.
Recommendation
It is good practice to run your containers as a non-root user when possible.
To modify a docker container to use a non-root user, the Dockerfile needs to specify a different user,
such as:
RUN useradd myLowPrivilegeUser
USER myLowPrivilegeUser




...............
7.1.2 Dockerfile Misconfiguration: Dependency Confusion High
CWE-20
OWASP Top 10: A6
PCI 3.2: 6.5.6 High Risk Vulnerabilities
Summary
Retrieving build dependencies using a non-specific version can leave the build system vulnerable to
malicious binaries or cause the system to experience unexpected behavior.
Explanation
Dockerfiles can specify an unbound range of versions for dependencies and base images. If an
attacker is able to add malicious versions of dependencies to a repository or trick the build system
into downloading dependencies from a repository under the attacker's control, if docker is configured
without specific versions of dependencies, then docker will silently download and run the
compromised dependency.
This type of weakness would be exploitable as a result of a supply chain attack where attackers can
leverage misconfiguration by developers, typosquatting and can add malicious packages to open
source repositories. An attack of this type exploits the trust in the published packages to gain access
and exfiltrate data.
In docker, the latest tag automatically indicates the version level of an image that doesn't use a
digest or unique tag to provide a version for it. Docker automatically assigns the latest tag as
mechanism to point to the most recent image manifest file. Because tags are mutable, an attacker
can replace an image or layer using a latest (or weak tags such as imagename-lst, imagenamelast,
myimage ).
Example 1: The following configuration instructs Docker to pick the base image using the latest
version of ubuntu .
FROM ubuntu:Latest
...
Docker does not validate whether the repository configured to support the package manager is
trustworthy.
Example 2: The following configuration instructs the package manager zypper to retrive the latest
version of the given package.
...
zypper install package
...
In Example 2 , if the repository is compromised, an attacker could simply upload a version that meets
the dynamic criteria and cause zypper to download a malicious version of the dependency.
Recommendation
Perform version pinning or simple pinning. Version pinning explicitly specifies the version of images,
libraries and support packages an application or system depends on. The primary goal of pinning is to
ensure system stability to achieve repeatable deployments. Pinning ensures that end-users,
This report contains Micro Focus CONFIDENTIAL information, including but not limited to Micro Focus's analysis, techniques for analysis and
recommendations. This report may not be made public, used for competitive or consulting purposes or used outside of the recipient.
10
developers, and testers all use the same code base. Pinning can additionally ensure the use of safe
dependencies; those which have gone through the rigorous process of application security validation
and malware detection.
When you invoke zypper (or other package managers) from docker, use the following formats:
RUN zypper install <package_name>=<version> \
RUN gem install <package_name> --version <version>
RUN gem install <package_name> -v <version>
RUN apk add <package_name>=<version>
RUN apt-get update && apt-get install -y \
<package_name>=<version> \
<package_name>=<version> \
<package_name>=<version> \
&& rm -rf /var/lib/apt/lists/*
Where <package_name> is the name of the dependency to install and <version> is the exact version
or release the application should use.
Fortify also recommends:
- Ensure the repositories that the package managers use are trustworthy or that they are properly
kept, and there is no install package substitution possible, including the addition of malicious code
onto the package.
- Avoid using public or untrusted repositories.
- Scan packages for malware and security vulnerabilities prior to executing any regression tests.
- Use digitally signed images.
- Avoid using image tags such as latest or weak tags such as imagename-lst, imagename-last,
myimage for deployments in production environments.
- Stick to more stable tags, like specific version tags, although there is no guarantee that these
cannot mutate either.
- Do not create mutant tags.
- Implement strict control over the source of images and their layers.
............







please explain line by line from given Docker file:

FROM docker.allianzuk.cloud/azuk/azuk-corretto-17:latest

ARG user=rap
ARG group=rap
ARG uid=2000
ARG gid=2000

RUN addgroup -g ${gid} ${group} && adduser -h "/home/${user}" -u ${uid} -G ${group} -s /bin/bash -D ${user}

VOLUME /tmp

ADD ./deployment/certs/*  /usr/local/share/ca-certificates/

COPY ./deployment/certs/rootca3_base64.crt /usr/lib/jvm/java-17-amazon-corretto/lib/security

RUN cd /usr/lib/jvm/java-17-amazon-corretto/lib/security && keytool -import -trustcacerts -keystore cacerts -storepass changeit -noprompt -alias roor -file rootca3_base64.crt

ARG VERSION

WORKDIR /etc/app

ENV LOG_FORMAT=json

ADD target/service.jar /etc/app/service.jar

EXPOSE 8080 8080

RUN echo '#!/bin/sh' >  ./entrypoint.sh \
 && echo 'exec java -Djavax.net.ssl.trustStore=/etc/apps/cacerts.jks -Djavax.net.ssl.trustStorePassword=changeit -jar /etc/app/service.jar'   >> ./entrypoint.sh

RUN chmod +x ./entrypoint.sh
ENTRYPOINT ["./entrypoint.sh"]





















.................................................

Fortify on Demand Security Review

sink: From in Dockerfile:1 Enclosing method

Dockerfile Misconfiguration: Dependency Confusion


FROM docker.allianzuk.cloud/azuk/azuk-corretto-17:latest

ARG user=rap
ARG group=rap
ARG uid=2000
ARG gid=2000

RUN addgroup -g ${gid} ${group} && adduser -h "/home/${user}" -u ${uid} -G ${group} -s /bin/bash -D ${user}

VOLUME /tmp

ADD ./deployment/certs/*  /usr/local/share/ca-certificates/

COPY ./deployment/certs/rootca3_base64.crt /usr/lib/jvm/java-17-amazon-corretto/lib/security

RUN cd /usr/lib/jvm/java-17-amazon-corretto/lib/security && keytool -import -trustcacerts -keystore cacerts -storepass changeit -noprompt -alias roor -file rootca3_base64.crt

ARG VERSION

WORKDIR /etc/app

ENV LOG_FORMAT=json

ADD target/service.jar /etc/app/service.jar

EXPOSE 8080 8080

RUN echo '#!/bin/sh' >  ./entrypoint.sh \
 && echo 'exec java -Djavax.net.ssl.trustStore=/etc/apps/cacerts.jks -Djavax.net.ssl.trustStorePassword=changeit -jar /etc/app/service.jar'   >> ./entrypoint.sh

RUN chmod +x ./entrypoint.sh
ENTRYPOINT ["./entrypoint.sh"]

...............................................................................................
JUnit



package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;


public class ValidationServiceImplTest {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @BeforeEach
    void setUp() {
        validationServiceImpl = new ValidationServiceImpl();
    }

    @Test
    public void testProcessJsonSingleValueJson() {

        String json = "\"John\"";
        Assertions.assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() {

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationServiceImpl.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() {

        String json = "\"value\"";

        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));
    }


    @Test
    public void testProcessJsonWithSingleValueJson() {

        String json = "123"; // Single value JSON

        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));
    }

    @Test
    public void testProcessJsonWithObject() {

        String json = "[]"; // Empty JSON Object / Array

        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));
    }
}




package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import com.google.json.JsonSanitizer;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.exception.CustomException;

/***
 * Build standard JSON validation on incoming data.
 */
@Service
public class ValidationServiceImpl implements ValidationService {
    public String processJson(final String json) throws CustomException, JsonProcessingException {
        System.out.println("In ValidationServiceImpl");
        // Parse the JSON string into a JsonElement
        JsonElement jsonElement;
        jsonElement = JsonParser.parseString(json);
        // Check if the JSON is a single value (string or number) or empty object/array
        if (isSingleValue(jsonElement)) {
            throw new CustomException("JSON is a single value. ");
        } else if (isEmptyObject(jsonElement) || isEmptyArray(jsonElement)) {
            throw new CustomException("JSON is empty object/array. ");
        }
        String sanitizedJson = JsonSanitizer.sanitize(json);
        return sanitizedJson;
    }

    // Helper method to check if the JSON element is a single value
    private boolean isSingleValue(final JsonElement jsonElement) {
        return !jsonElement.isJsonObject() && !jsonElement.isJsonArray();
    }

    // Helper method to check if the JSON element is an empty object ({})
    private boolean isEmptyObject(final JsonElement jsonElement) {
        return jsonElement.isJsonObject() && jsonElement.getAsJsonObject().entrySet().isEmpty();
    }

    // Helper method to check if the JSON element is an empty array ([])
    private boolean isEmptyArray(final JsonElement jsonElement) {
        return jsonElement.isJsonArray() && jsonElement.getAsJsonArray().size() == 0;
    }
}
