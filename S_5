package uk.co.allianz.rap.lc.rest;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Assert;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.Client;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importclient.Result;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.LossControlServiceImpl;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;
import static org.mockito.MockitoAnnotations.openMocks;

class ValidationRestTest1 {
    @Mock
    private ImportClientServiceImp importClientServiceImpl;
    @Mock
    private ValidationServiceImpl validationServiceImpl;
//    @InjectMocks
//    private ValidationRest validationRest;

    @BeforeEach
    void setUp() {
        validationServiceImpl = new ValidationServiceImpl();
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testProcessJson_Success() throws Exception {
        ValidationRest validationRest = new ValidationRest(validationServiceImpl);
//        String correlationId = "123";
        String json = "{\n" +
                "    \"divisionLookupID\": \"AZ_UK\",\n" +
                "    \"client\": {\n" +
                "        \"LookupID\": \"C00803031\",\n" +
                "        \"ContactFirstName\": null,\n" +
                "        \"ContactLastName\": null,\n" +
                "        \"PolicyNumber\": \"SP26853150\",\n" +
                "        \"Name\": \"CLIENT CI Test1\",\n" +
                "        \"Phone\": null,\n" +
                "        \"Email\": null,\n" +
                "        \"Address\": {\n" +
                "            \"Country\": \"United Kingdom\",\n" +
                "            \"OverseasTerritories\": null,\n" +
                "            \"Street1\": null,\n" +
                "            \"Street2\": null,\n" +
                "            \"City\": null,\n" +
                "            \"Region1\": null,\n" +
                "            \"Region2\": null,\n" +
                "            \"Region3\": null,\n" +
                "            \"Region4\": null,\n" +
                "            \"ZipCode\": null\n" +
                "        },\n" +
                "        \"Agent\": {\n" +
                "            \"AgencyCode\": \"22576\",\n" +
                "            \"AgencyName\": \"Arthur J. Gallagher\",\n" +
                "            \"AgentCode\": \"13332\",\n" +
                "            \"AgentName\": null,\n" +
                "            \"Email\": null,\n" +
                "            \"FaxNumber\": null,\n" +
                "            \"PhoneNumber\": null,\n" +
                "            \"Address\": {\n" +
                "                \"Country\": \"GB\",\n" +
                "                \"OverseasTerritories\": null,\n" +
                "                \"Street1\": null,\n" +
                "                \"Street2\": null,\n" +
                "                \"City\": null,\n" +
                "                \"Region1\": null,\n" +
                "                \"Region2\": null,\n" +
                "                \"Region3\": null,\n" +
                "                \"Region4\": null,\n" +
                "                \"ZipCode\": null\n" +
                "            },\n" +
                "            \"AgentType\": \"Broker\"\n" +
                "        },\n" +
                "        \"Underwriter\": null,\n" +
                "        \"Locations\": [\n" +
                "            {\n" +
                "                \"genericFields\": null,\n" +
                "                \"LookupID\": \"8080\",\n" +
                "                \"Name\": null,\n" +
                "                \"PolicyNumber\": \"SP26853148\",\n" +
                "                \"PolicyEffectiveDate\": null,\n" +
                "                \"PolicyExpirationDate\": null,\n" +
                "                \"PolicyRenewalDate\": null,\n" +
                "                \"Address\": {\n" +
                "                    \"Country\": \"United Kingdom\",\n" +
                "                    \"OverseasTerritories\": null,\n" +
                "                    \"Street1\": \"NEW CROSS DEWEL\",\n" +
                "                    \"Street2\": \"SD 11 JEW TOWN\",\n" +
                "                    \"City\": \"MM KEMSTONE\",\n" +
                "                    \"Region1\": \"UK\",\n" +
                "                    \"Region2\": null,\n" +
                "                    \"Region3\": null,\n" +
                "                    \"Region4\": null,\n" +
                "                    \"ZipCode\": \"GU1 10DB\"\n" +
                "                },\n" +
                "                \"OriginalEffectiveDate\": null,\n" +
                "                \"EffectiveDate\": null,\n" +
                "                \"ExpirationDate\": null,\n" +
                "                \"RenewalDate\": \"2024-07-17\",\n" +
                "                \"LastInspectedDate\": null,\n" +
                "                \"Coverages\": [\n" +
                "                    {\n" +
                "                        \"CoverageTypeLookup\": \"PD_TIV\",\n" +
                "                        \"CoverageReference\": \"Coverage 1\",\n" +
                "                        \"GenericFields\": [\n" +
                "                            {\n" +
                "                                \"Number\": \"1123\",\n" +
                "                                \"Key\": \"01. PD Building\",\n" +
                "                                \"GenericFieldValueType\": 1,\n" +
                "                                \"Text\": null\n" +
                "                            },\n" +
                "                            {\n" +
                "                                \"Number\": \"0\",\n" +
                "                                \"Key\": \"04. PD Other\",\n" +
                "                                \"GenericFieldValueType\": 1,\n" +
                "                                \"Text\": null\n" +
                "                            },\n" +
                "                            {\n" +
                "                                \"Number\": null,\n" +
                "                                \"Key\": \"05. PD Other Description\",\n" +
                "                                \"GenericFieldValueType\": 0,\n" +
                "                                \"Text\": \"\"\n" +
                "                            },\n" +
                "                            {\n" +
                "                                \"Number\": \"1123\",\n" +
                "                                \"Key\": \"06. TIV PD\",\n" +
                "                                \"GenericFieldValueType\": 1,\n" +
                "                                \"Text\": null\n" +
                "                            },\n" +
                "                            {\n" +
                "                                \"Number\": \"332198\",\n" +
                "                                \"Key\": \"07. TIV BI\",\n" +
                "                                \"GenericFieldValueType\": 1,\n" +
                "                                \"Text\": null\n" +
                "                            },\n" +
                "                            {\n" +
                "                                \"Number\": \"\",\n" +
                "                                \"Key\": \"08. BI Base Period (Months)\",\n" +
                "                                \"GenericFieldValueType\": 1,\n" +
                "                                \"Text\": null\n" +
                "                            },\n" +
                "                            {\n" +
                "                                \"Number\": \"332198\",\n" +
                "                                \"Key\": \"09. TIV (PD + BI )\",\n" +
                "                                \"GenericFieldValueType\": 1,\n" +
                "                                \"Text\": null\n" +
                "                            }\n" +
                "                        ]\n" +
                "                    }\n" +
                "                ],\n" +
                "                \"Contact\": null\n" +
                "            },\n" +
                "            \n" +
                "            {\n" +
                "                \"genericFields\": null,\n" +
                "                \"LookupID\": \"8081\",\n" +
                "                \"Name\": null,\n" +
                "                \"PolicyNumber\": \"SP26853148\",\n" +
                "                \"PolicyEffectiveDate\": null,\n" +
                "                \"PolicyExpirationDate\": null,\n" +
                "                \"PolicyRenewalDate\": null,\n" +
                "                \"Address\": {\n" +
                "                    \"Country\": \"United Kingdom\",\n" +
                "                    \"OverseasTerritories\": null,\n" +
                "                    \"Street1\": \"NEW CROSS DEWEL\",\n" +
                "                    \"Street2\": \"SD 11 JEW TOWN\",\n" +
                "                    \"City\": \"MM KEMSTONE\",\n" +
                "                    \"Region1\": \"UK\",\n" +
                "                    \"Region2\": null,\n" +
                "                    \"Region3\": null,\n" +
                "                    \"Region4\": null,\n" +
                "                    \"ZipCode\": \"GU1 13DB\"\n" +
                "                },\n" +
                "                \"OriginalEffectiveDate\": null,\n" +
                "                \"EffectiveDate\": null,\n" +
                "                \"ExpirationDate\": null,\n" +
                "                \"RenewalDate\": \"2024-07-17\",\n" +
                "                \"LastInspectedDate\": null,\n" +
                "                \"Coverages\": [\n" +
                "                    {\n" +
                "                        \"CoverageTypeLookup\": \"PD_TIV\",\n" +
                "                        \"CoverageReference\": \"Coverage 1\",\n" +
                "                        \"GenericFields\": [\n" +
                "                            {\n" +
                "                                \"Number\": \"1123\",\n" +
                "                                \"Key\": \"01. PD Building\",\n" +
                "                                \"GenericFieldValueType\": 1,\n" +
                "                                \"Text\": null\n" +
                "                            },\n" +
                "                            {\n" +
                "                                \"Number\": \"0\",\n" +
                "                                \"Key\": \"04. PD Other\",\n" +
                "                                \"GenericFieldValueType\": 1,\n" +
                "                                \"Text\": null\n" +
                "                            },\n" +
                "                            {\n" +
                "                                \"Number\": null,\n" +
                "                                \"Key\": \"05. PD Other Description\",\n" +
                "                                \"GenericFieldValueType\": 0,\n" +
                "                                \"Text\": \"\"\n" +
                "                            },\n" +
                "                            {\n" +
                "                                \"Number\": \"1123\",\n" +
                "                                \"Key\": \"06. TIV PD\",\n" +
                "                                \"GenericFieldValueType\": 1,\n" +
                "                                \"Text\": null\n" +
                "                            },\n" +
                "                            {\n" +
                "                                \"Number\": \"332198\",\n" +
                "                                \"Key\": \"07. TIV BI\",\n" +
                "                                \"GenericFieldValueType\": 1,\n" +
                "                                \"Text\": null\n" +
                "                            },\n" +
                "                            {\n" +
                "                                \"Number\": \"\",\n" +
                "                                \"Key\": \"08. BI Base Period (Months)\",\n" +
                "                                \"GenericFieldValueType\": 1,\n" +
                "                                \"Text\": null\n" +
                "                            },\n" +
                "                            {\n" +
                "                                \"Number\": \"332198\",\n" +
                "                                \"Key\": \"09. TIV (PD + BI )\",\n" +
                "                                \"GenericFieldValueType\": 1,\n" +
                "                                \"Text\": null\n" +
                "                            }\n" +
                "                        ]\n" +
                "                    }\n" +
                "                ],\n" +
                "                \"Contact\": null\n" +
                "            }\n" +
                "        ]\n" +
                "    }\n" +
                "}";
        String validateInput = json;
        when(validationServiceImpl.processJson(json)).thenReturn(validateInput);
        ImportClientResponse importClientResponse = mock(ImportClientResponse.class);
        ResponseEntity<?> response = validationRest.processJson(json, "1233");
    }
}

























package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@SuppressWarnings("unused")
@Data
public class ImportClientResponse {
    @JsonProperty("Result")
    private Result result;
    @JsonProperty("ImportRequestID")
    private String importRequestID;
}




package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;
@SuppressWarnings("unused")
@Data
public class Result {
    @JsonProperty("ClientID")
    private String clientID;
    @JsonProperty("ClientLookupID")
    private String clientLookupID;
    @JsonProperty("IsDeleted")
    private boolean isDeleted;
    @JsonProperty("Errors")
    private ArrayList<Object> errors;
    @JsonProperty("Warnings")
    private Object warnings;
    @JsonProperty("Success")
    private boolean success;
    @JsonProperty("Locations")
    private ArrayList<Location> locations;
    @JsonProperty("CommercialCoverages")
    private ArrayList<Object> commercialCoverages;
    @JsonProperty("Messages")
    private ArrayList<Object> messages;
}

\
\

package uk.co.allianz.rap.lc.service;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import java.util.ArrayList;
import java.util.Map;
import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        String clientLookupID = importClientRequest.getClient().getLookupID();
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String clientId = clientResponse(importClientRequest.getClient().getLookupID());
        ArrayList<Location> updatedLocation = locationResponse(locations);
        ImportClientRequest updatedImportClientRequest = preImportClientRequest(importClientRequest, clientId, updatedLocation, importClientRequest.getClient().getLookupID());
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(updatedImportClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
        updateLookUpTable(clientId, importClientResponse.getResult().getClientLookupID(), updatedLocation, clientLookupID, importClientResponse);
        return importClientResponse;
    }

    //checking client is present or not in client lookup Table
    public String clientResponse(final String clientLookupId) {
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(clientLookupId);
        if (clientResult != null) {
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            LOGGER.info("Client is present in Client lookup Table.");
            return lc360ClientId;
        } else {
            LOGGER.info("Client is not present in Client lookup Table.");
            return clientLookupId;
        }
    }

    //checking location lookupID null or not
    public ArrayList<Location> locationResponse(final ArrayList<Location> locations) {
        LOGGER.info("checking Location lookupID null or not.");
    ArrayList<Location> validLocations = new ArrayList<>();
    for (Location location : locations) {
        String lookupID = location.getLookupID();
        if (lookupID != null) {
            validLocations.add(location);
        }
    }
    return validLocations;
    }

    // Enriched Import Client Request
    public ImportClientRequest preImportClientRequest(final ImportClientRequest importClientRequest, final String clientId, final ArrayList<Location> updatedLocation, final String updatedClientID) throws JsonProcessingException {
        LOGGER.info("start Enriched Import Client Request");
        for (Location location : updatedLocation) {
            Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID() + "_" + updatedClientID);
            if (locationResult != null) {
                LOGGER.info("Location are present");
                String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                location.setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
            }
        }
        if (clientId.equals(importClientRequest.getClient().getLookupID())) {
            LOGGER.info("client is not present");
            return importClientRequest;
        } else {
            importClientRequest.getClient().setLookupID(clientId);
            LOGGER.info("setting clientLookupID in importClientRequest");
            objectMapper.writeValueAsString(importClientRequest);
            return importClientRequest;
        }
    }
    public void updateLookUpTable(final String clientId, final String lc360ClientId, final ArrayList<Location> updatedLocation, final String clientLookupID, final ImportClientResponse importClientResponse) {
        LOGGER.info("start updating LookUpTable");
        if (clientId.equals(lc360ClientId)) {
            LOGGER.info("client is present in lookup table");
        } else {
            lossControlDao.insertClinetData(clientId, lc360ClientId);
            LOGGER.info("updated client in lookup table");
        }
        for (int index = 0; index < updatedLocation.size(); index++) {
            String lookupID = updatedLocation.get(index).getLookupID();
            Map<String, Object> locationResult = lossControlDao.findLocationID(lookupID);
            if (locationResult == null) {
                LOGGER.info("location is not present in lookup table");
                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                lossControlDao.insertLocationData(updatedLocation.get(index).getLookupID() + "_" + clientLookupID, locationsResponse.get(index).getLocationLookupID());
                LOGGER.info("location is updated in lookup table");
            }
        }
    }
}




















package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import com.google.json.JsonSanitizer;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.exception.CustomException;

/***
 * Build standard JSON validation on incoming data.
 */
@Service
public class ValidationServiceImpl implements ValidationService {
    public String processJson(final String json) throws CustomException, JsonProcessingException {
        // Parse the JSON string into a JsonElement
        JsonElement jsonElement;
        jsonElement = JsonParser.parseString(json);
        // Check if the JSON is a single value (string or number) or empty object/array
        if (isSingleValue(jsonElement)) {
            throw new CustomException("JSON is a single value. ");
        } else if (isEmptyObject(jsonElement) || isEmptyArray(jsonElement)) {
            throw new CustomException("JSON is empty object/array. ");
        }
        String sanitizedJson = JsonSanitizer.sanitize(json);
        return sanitizedJson;
    }

    // Helper method to check if the JSON element is a single value
    public boolean isSingleValue(final JsonElement jsonElement) {
        return !jsonElement.isJsonObject() && !jsonElement.isJsonArray();
    }

    // Helper method to check if the JSON element is an empty object ({})
    public boolean isEmptyObject(final JsonElement jsonElement) {
        return jsonElement.isJsonObject() && jsonElement.getAsJsonObject().entrySet().isEmpty();
    }

    // Helper method to check if the JSON element is an empty array ([])
    private boolean isEmptyArray(final JsonElement jsonElement) {
        return jsonElement.isJsonArray() && jsonElement.getAsJsonArray().size() == 0;
    }
}



























package uk.co.allianz.rap.lc.rest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;
import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

@RestController
public class ValidationRest {
    private static final Logger LOGGER = (Logger) LoggerFactory
            .getLogger(ValidationRest.class);
    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    /***
     * Build the end point/Resource path: POST: surveySubmission
     *     Build standard JSON validation on incoming data
     *     Consumed the correlation id.
     */
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<?> processJson(@RequestBody(required = false) final String json, @RequestHeader("Correlation-ID") final String correlationId) {
        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            LOGGER.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");
        }
        try {
            //for validate JSON
            String validateInput = validationServiceImpl.processJson(json);
            //For import only client
            ImportClientResponse processedJson = importClientServiceImp.importClient(validateInput, correlationId);
            //checking processedJson is not null processedJson.getResult() is also not null
            if (processedJson != null && processedJson.getResult() != null) {
                if (processedJson.getResult().isSuccess()) {
                    LOGGER.info(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_SUCCESS), " client imported Successfully in LC360 {}", HttpStatus.OK.value());
                } else {
                    LOGGER.info("Error: " + processedJson.getResult().getErrors());
                    LOGGER.info(" client imported Unsuccessfully in LC360 {}", HttpStatus.UNPROCESSABLE_ENTITY);
                    return ResponseEntity.unprocessableEntity().body(processedJson.getResult().getErrors());
                }
            }
            return ResponseEntity.ok(processedJson);
        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            if (LOGGER.isErrorEnabled()) {
                LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Import Client request Failed in LC360 {}", HttpStatus.BAD_REQUEST.value());
            }
            return ResponseEntity.badRequest().body(e.getMessage());
        } catch (Exception e) {
            // Other exceptions
            LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Invalid JSON: {} ", HttpStatus.INTERNAL_SERVER_ERROR.value());
            return ResponseEntity.internalServerError().body("Invalid JSON format");
        }
    }
}


































public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
            ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        String oci=importClientRequest.getClient().getLookupID();
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String clientId =clientResponse(importClientRequest.getClient().getLookupID());
//        System.out.println(clientId);
        ArrayList<Location> updatedLocation = locationResponse(locations);
        ImportClientRequest importClientRequest1 = preImportClientRequest(importClientRequest,clientId,updatedLocation,importClientRequest.getClient().getLookupID());
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest1, tokenCache.retrieveTokenFromCache(correlationId));
        updateLookUpTable(clientId, importClientResponse.getResult().getClientLookupID(),updatedLocation,oci,importClientResponse);
        return importClientResponse;
    }










    public void updateLookUpTable(String clientId, String lc360ClientId,ArrayList<Location> updatedLocation ,String originalClientId,ImportClientResponse importClientResponse) {
        String id =originalClientId;
        if (clientId.equals(lc360ClientId)) {
            LOGGER.info("client is present in lookup table");
        } else {
            lossControlDao.insertClinetData(clientId, lc360ClientId);
        }
        for (int index = 0; index < updatedLocation.size(); index++) {
            String lookupID = updatedLocation.get(index).getLookupID();
            Map<String, Object> locationResult = lossControlDao.findLocationID(lookupID);
//            System.out.println("locationResult"+locationResult);
            if (locationResult == null) {
                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
//                System.out.println("locationsResponse"+locationsResponse);
                lossControlDao.insertLocationData(updatedLocation.get(index).getLookupID() + "_" + originalClientId, locationsResponse.get(index).getLocationLookupID());
            }
        }
    }



































public ImportClientRequest preImportClientRequest(ImportClientRequest importClientRequest,String clientId,ArrayList<Location> updatedLocation,String orignalClientID) throws JsonProcessingException {
        for (Location location : updatedLocation) {
            Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID() + "_" + orignalClientID);
            if (locationResult != null) {
                LOGGER.info("Location are present");
                String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                location.setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
//                System.out.println(importClientRequest);
            }
        }
        if(clientId.equals(importClientRequest.getClient().getLookupID())){
            LOGGER.info("client is not present");
//            System.out.println(importClientRequest);
            return importClientRequest;
        }else {
            importClientRequest.getClient().setLookupID(clientId);
            objectMapper.writeValueAsString(importClientRequest);
//            System.out.println(importClientRequest);
            return importClientRequest;
        }
    }

































public ArrayList<Location> locationResponse(ArrayList<Location> locations) {
    ArrayList<Location> validLocations = new ArrayList<>();
    for (Location location : locations) {
        String lookupID = location.getLookupID();
//        System.out.println("LookupID: " + lookupID);
        if (lookupID != null) {
            validLocations.add(location);
        }
    }
    return validLocations;
}



















package uk.co.allianz.rap.lc.service;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import java.util.ArrayList;
import java.util.Map;
import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
            ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        String oci=importClientRequest.getClient().getLookupID();
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String clientId =clientResponse(importClientRequest.getClient().getLookupID());
        System.out.println(clientId);
        ArrayList<Location> updatedLocation = locationResponse(locations);
        ImportClientRequest importClientRequest1 = preImportClientRequest(importClientRequest,clientId,updatedLocation,importClientRequest.getClient().getLookupID());
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest1, tokenCache.retrieveTokenFromCache(correlationId));
        updateLookUpTable(clientId, importClientResponse.getResult().getClientLookupID(),updatedLocation,oci,importClientResponse);
        return importClientResponse;
    }

    public String clientResponse(String clientLookupId){
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(clientLookupId);
        if(clientResult != null){
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            return lc360ClientId;
        }else {
            return clientLookupId;
        }
    }

public ArrayList<Location> locationResponse(ArrayList<Location> locations) {
    ArrayList<Location> validLocations = new ArrayList<>();
    for (Location location : locations) {
        String lookupID = location.getLookupID();
        System.out.println("LookupID: " + lookupID);
        if (lookupID != null) {
            validLocations.add(location);
        }
    }
    return validLocations;
}

    public ImportClientRequest preImportClientRequest(ImportClientRequest importClientRequest,String clientId,ArrayList<Location> updatedLocation,String orignalClientID) throws JsonProcessingException {
        for (Location location : updatedLocation) {
            Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID() + "_" + orignalClientID);
            if (locationResult != null) {
                LOGGER.info("Location are present");
                String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                location.setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
                System.out.println(importClientRequest);
            }
        }
        if(clientId.equals(importClientRequest.getClient().getLookupID())){
            LOGGER.info("client is not present");
            System.out.println(importClientRequest);
            return importClientRequest;
        }else {
            importClientRequest.getClient().setLookupID(clientId);
            objectMapper.writeValueAsString(importClientRequest);
            System.out.println(importClientRequest);
            return importClientRequest;
        }
    }
    public void updateLookUpTable(String clientId, String lc360ClientId,ArrayList<Location> updatedLocation ,String originalClientId,ImportClientResponse importClientResponse) {
        String id =originalClientId;
        if (clientId.equals(lc360ClientId)) {
            LOGGER.info("client is present in lookup table");
        } else {
            lossControlDao.insertClinetData(clientId, lc360ClientId);
        }
        for (int index = 0; index < updatedLocation.size(); index++) {
            String lookupID = updatedLocation.get(index).getLookupID();
            Map<String, Object> locationResult = lossControlDao.findLocationID(lookupID);
            System.out.println("locationResult"+locationResult);
            if (locationResult == null) {
                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                System.out.println("locationsResponse"+locationsResponse);
                lossControlDao.insertLocationData(updatedLocation.get(index).getLookupID() + "_" + originalClientId, locationsResponse.get(index).getLocationLookupID());
            }
        }
    }
}






package uk.co.allianz.rap.lc.cache;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.util.JwtUtil;
import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;
//1. Implement a  token caching logic within loss-control-service
@Component
public class TokenCache {
    private static final Logger LOGGER = (Logger) LoggerFactory
            .getLogger(TokenCache.class);
    private static final String TOKEN_CACHE_NAME = "tokens";
    @Autowired
    protected JwtUtil jwtUtil;
    @Autowired
    protected CacheManager cacheManager;

    @Cacheable(value = TOKEN_CACHE_NAME)
    public String getToken() throws CustomException {

        // Retrieve the token from the cache or data source
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            Cache.ValueWrapper valueWrapper = cache.get(TOKEN_CACHE_NAME);
            if (valueWrapper != null) {
                return (String) valueWrapper.get();
            }
        }
        String tokenFromDataSource = retrieveTokenFromDataSource();
        // Cache the token for future use
        cacheToken(tokenFromDataSource);
        return tokenFromDataSource;
    }

    public String retrieveTokenFromDataSource() throws CustomException {
        // Perform the actual retrieval of the token from the jwtUtil class
        String jwtToken = jwtUtil.getAuthToken();
        return jwtToken;
    }

    //token store in cache
    public void cacheToken(final String token) {
        Cache cache = cacheManager.getCache(TOKEN_CACHE_NAME);
        if (cache != null) {
            cache.put(TOKEN_CACHE_NAME, token);
        }
    }

    //retrieve Token From Cache & request contains the correlation id
    public String retrieveTokenFromCache(final String correlationId) {
        try {
            String token = getToken();
            if (LOGGER.isInfoEnabled()) {
                LOGGER.info("Token successfully retrieved from the cache, Correlation ID: {}", correlationId);
            }
            return token;
        } catch (Exception e) {
            LOGGER.error(e.getMessage());
            throw new CustomException("Failed to retrieve token from the cache");
        }
    }
}





package uk.co.allianz.rap.lc.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import uk.co.allianz.rap.lc.model.ServiceCallUrlModel;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importinspections.ImportInspectionsRequest;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.model.response.importinspections.ImportInspectionResponse;

import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;
@Component
public class LossControlServiceImpl implements LossControlService {
    private static final Logger LOGGER = (Logger) LoggerFactory
            .getLogger(LossControlServiceImpl.class);
    @Autowired
    private ServiceCallUrlModel seviceCallUrlModel;
    private WebClient webClient = WebClient.create();

    /***
     *     method used for invoke second LC360 api
     *     post http request
     *     input bearer token and related json data
     */
    @Override
    public ImportClientResponse clientPost(final ImportClientRequest importClientRequest, final String bearerToken) {
        //passing jwt bearer token into header
        HttpHeaders headers = new HttpHeaders();
        headers.add("Authorization", "Bearer " + bearerToken);
        LOGGER.info("Token set in header.");
        ImportClientResponse importClientResponse =
                webClient.post()
                        .uri(seviceCallUrlModel.getImportClientUrl())
                        .headers(httpHeaders -> httpHeaders.addAll(headers))
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(importClientRequest)
                        .retrieve()
                        .bodyToMono(ImportClientResponse.class)
                        .block();
        return importClientResponse;
    }

    /***
     *     method used for invoke third LC360 api
     *     post http request
     *     input bearer token and related json data
     */
    @Override
    public ImportInspectionResponse inspectionsPost(final ImportInspectionsRequest importInspectionsRequest, final String bearerToken) {
        //passing jwt bearer token into header
        HttpHeaders headers = new HttpHeaders();
        headers.add("Authorization", "Bearer " + bearerToken);
        LOGGER.info("Token set in header.");
        ImportInspectionResponse importInspectionResponse =
                webClient.post()
                        .uri(seviceCallUrlModel.getImportInspectionsUrl())
                        .headers(httpHeaders -> httpHeaders.addAll(headers))
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(importInspectionsRequest)
                        .retrieve()
                        .bodyToMono(ImportInspectionResponse.class)
                        .block();
        return importInspectionResponse;
    }
}






package uk.co.allianz.rap.lc.dao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;



import java.util.Map;



@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;



    //client methods



    @Override
    public void insertClinetData(final String clientId, final String lc360ClientId) {
        String insertClient = "insert into client_lookup (client_id, lc360_client_id) values (?, ?)";
        this.jdbcTemplate.update(insertClient, clientId, lc360ClientId);
    }



    @Override
    public void insertLocationData(String locationId, String lc360LocationId) {
        String insertLocation = "insert into location_lookup (location_id, lc360_location_id) values (?, ?)";
        this.jdbcTemplate.update(insertLocation, locationId, lc360LocationId);
    }



    @Override
    public Map<String, Object> findLc360ClientID(final String clientId) {
        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360ClientId, clientId);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }



    @Override
    public Map<String, Object> findLc360LocationID(final String locationId) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, locationId);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }



    @Override
    public Map<String, Object> findLocationID(String lc360LocationId) {
        String location = "select location_id from location_lookup where lc360_location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(location, lc360LocationId);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



package uk.co.allianz.rap.lc.service;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import java.util.ArrayList;
import java.util.Map;
import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
            ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        String oci=importClientRequest.getClient().getLookupID();
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String clientId =clientResponse(importClientRequest.getClient().getLookupID());
        System.out.println(clientId);
        ArrayList<Location> updatedLocation = locationResponse(locations);
        ImportClientRequest importClientRequest1 = preImportClientRequest(importClientRequest,clientId,updatedLocation,importClientRequest.getClient().getLookupID());
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest1, tokenCache.retrieveTokenFromCache(correlationId));
        updateLookUpTable(clientId, importClientResponse.getResult().getClientLookupID(),updatedLocation,oci,importClientResponse);
        return importClientResponse;
    }

    public String clientResponse(String clientLookupId){
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(clientLookupId);
        if(clientResult != null){
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            return lc360ClientId;
        }else {
            return clientLookupId;
        }
    }

public ArrayList<Location> locationResponse(ArrayList<Location> locations) {
    ArrayList<Location> validLocations = new ArrayList<>();
    for (Location location : locations) {
        String lookupID = location.getLookupID();
        System.out.println("LookupID: " + lookupID);
        if (lookupID != null) {
            validLocations.add(location);
        }
    }
    return validLocations;
}

    public ImportClientRequest preImportClientRequest(ImportClientRequest importClientRequest,String clientId,ArrayList<Location> updatedLocation,String orignalClientID) throws JsonProcessingException {
        for (Location location : updatedLocation) {
            Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID() + "_" + orignalClientID);
            if (locationResult != null) {
                LOGGER.info("Location are present");
                String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                location.setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
                System.out.println(importClientRequest);
            }
        }
        if(clientId.equals(importClientRequest.getClient().getLookupID())){
            LOGGER.info("client is not present");
            System.out.println(importClientRequest);
            return importClientRequest;
        }else {
            importClientRequest.getClient().setLookupID(clientId);
            objectMapper.writeValueAsString(importClientRequest);
            System.out.println(importClientRequest);
            return importClientRequest;
        }
    }
    public void updateLookUpTable(String clientId, String lc360ClientId,ArrayList<Location> updatedLocation ,String originalClientId,ImportClientResponse importClientResponse) {
        String id =originalClientId;
        if (clientId.equals(lc360ClientId)) {
            LOGGER.info("client is present in lookup table");
        } else {
            lossControlDao.insertClinetData(clientId, lc360ClientId);
        }
        for (int index = 0; index < updatedLocation.size(); index++) {
            String lookupID = updatedLocation.get(index).getLookupID();
            Map<String, Object> locationResult = lossControlDao.findLocationID(lookupID);
            System.out.println("locationResult"+locationResult);
            if (locationResult == null) {
                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                System.out.println("locationsResponse"+locationsResponse);
                lossControlDao.insertLocationData(updatedLocation.get(index).getLookupID() + "_" + originalClientId, locationsResponse.get(index).getLocationLookupID());
            }
        }
    }
}





















package uk.co.allianz.rap.lc.rest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;
import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

@RestController
public class ValidationRest {
    private static final Logger LOGGER = (Logger) LoggerFactory
            .getLogger(ValidationRest.class);
    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    /***
     * Build the end point/Resource path: POST: surveySubmission
     *     Build standard JSON validation on incoming data
     *     Consumed the correlation id.
     */
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<?> processJson(@RequestBody(required = false) final String json, @RequestHeader("Correlation-ID") final String correlationId) {
        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            LOGGER.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");
        }
        try {
            //for validate JSON
            String validateInput = validationServiceImpl.processJson(json);
            //For import only client
            ImportClientResponse processedJson = importClientServiceImp.importClient(validateInput, correlationId);
            //checking processedJson is not null processedJson.getResult() is also not null
            if (processedJson != null && processedJson.getResult() != null) {
                if (processedJson.getResult().isSuccess()) {
                    LOGGER.info(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_SUCCESS), " client imported Successfully in LC360 {}", HttpStatus.OK.value());
                } else {
                    LOGGER.info("Error: " + processedJson.getResult().getErrors());
                    LOGGER.info(" client imported Unsuccessfully in LC360 {}", HttpStatus.UNPROCESSABLE_ENTITY);
                    return ResponseEntity.unprocessableEntity().body(processedJson.getResult().getErrors());
                }
            }
            return ResponseEntity.ok(processedJson);
        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            if (LOGGER.isErrorEnabled()) {
                LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Import Client request Failed in LC360 {}", HttpStatus.BAD_REQUEST.value());
            }
            return ResponseEntity.badRequest().body(e.getMessage());
        } catch (Exception e) {
            // Other exceptions
            LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Invalid JSON: {} ", HttpStatus.INTERNAL_SERVER_ERROR.value());
            return ResponseEntity.internalServerError().body("Invalid JSON format");
        }
    }
}




















////////////////////////













package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@SuppressWarnings("unused")
@Data
public class ImportClientResponse {
    @JsonProperty("Result")
    private Result result;
    @JsonProperty("ImportRequestID")
    private String importRequestID;
}







package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;
@SuppressWarnings("unused")
@Data
public class Result {
    @JsonProperty("ClientID")
    private String clientID;
    @JsonProperty("ClientLookupID")
    private String clientLookupID;
    @JsonProperty("IsDeleted")
    private boolean isDeleted;
    @JsonProperty("Errors")
    private ArrayList<Object> errors;
    @JsonProperty("Warnings")
    private Object warnings;
    @JsonProperty("Success")
    private boolean success;
    @JsonProperty("Locations")
    private ArrayList<Location> locations;
    @JsonProperty("CommercialCoverages")
    private ArrayList<Object> commercialCoverages;
    @JsonProperty("Messages")
    private ArrayList<Object> messages;
}




























package uk.co.allianz.rap.lc.rest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;
import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

@RestController
public class ValidationRest {
    private static final Logger LOGGER = (Logger) LoggerFactory
            .getLogger(ValidationRest.class);
    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    /***
     * Build the end point/Resource path: POST: surveySubmission
     *     Build standard JSON validation on incoming data
     *     Consumed the correlation id.
     */
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<?> processJson(@RequestBody(required = false) final String json, @RequestHeader("Correlation-ID") final String correlationId) {
        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            LOGGER.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");
        }
        try {
            //for validate JSON
            String validateInput = validationServiceImpl.processJson(json);
            //For import only client
            ImportClientResponse processedJson = importClientServiceImp.importClient(validateInput, correlationId);
            //checking processedJson is not null processedJson.getResult() is also not null
            if (processedJson != null && processedJson.getResult() != null) {
                if (processedJson.getResult().isSuccess()) {
                    LOGGER.info(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_SUCCESS), " client imported Successfully in LC360 {}", HttpStatus.OK.value());
                } else {
                    LOGGER.info("Error: " + processedJson.getResult().getErrors());
                    LOGGER.info(" client imported Unsuccessfully in LC360 {}", HttpStatus.UNPROCESSABLE_ENTITY);
                    return ResponseEntity.unprocessableEntity().body(processedJson.getResult().getErrors());
                }
            }
            return ResponseEntity.ok(processedJson);
        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            if (LOGGER.isErrorEnabled()) {
                LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Import Client request Failed in LC360 {}", HttpStatus.BAD_REQUEST.value());
            }
            return ResponseEntity.badRequest().body(e.getMessage());
        } catch (Exception e) {
            // Other exceptions
            LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Invalid JSON: {} ", HttpStatus.INTERNAL_SERVER_ERROR.value());
            return ResponseEntity.internalServerError().body("Invalid JSON format");
        }
    }
}



package uk.co.allianz.rap.lc.rest;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class ValidationRestTest {
    private ValidationServiceImpl validationServiceImpl;

    @BeforeEach
    void setUp() {
        validationServiceImpl = new ValidationServiceImpl();
    }

    //Invalid JSON format : Not related to client. as import-client required
    @Test
    public void testProcessJson_Invalid() {
        ValidationRest validationRest = new ValidationRest(validationServiceImpl);
        String json = "{\"name\": \"John\", \"age\": 26}";
        ResponseEntity<?> response = validationRest.processJson(json, "1233");

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertEquals("Invalid JSON format", response.getBody());
    }

    @Test
    public void testProcessJson_InvalidJson() {
        ValidationRest validationRest = new ValidationRest(validationServiceImpl);
        String json = "{\"name\": \"John\", :26}";

        ResponseEntity<?> response = validationRest.processJson(json, "123");

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertEquals("Invalid JSON format", response.getBody());
    }

    @Test
    public void testProcessJson_EmptyJson() {
        ValidationRest validationRest = new ValidationRest(validationServiceImpl);
        String json = "";

        ResponseEntity<?> response = validationRest.processJson(json, "123");

        Assertions.assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        Assertions.assertEquals("JSON is empty", response.getBody());
    }

    @Test
    public void testProcessJson_InvalidJsonObject_ReturnsBadRequestResponse() {
        ValidationRest validationRest = new ValidationRest(validationServiceImpl);
        String json = "[]";

        ResponseEntity<?> response = validationRest.processJson(json, "123");

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
    }

    @Test
    public void testProcessJson_NullJson() {
        ValidationRest validationRest = new ValidationRest(validationServiceImpl);
        String json = null;
        ResponseEntity<?> response = validationRest.processJson(json, "123");

        Assertions.assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        Assertions.assertEquals("JSON is empty", response.getBody());
    }

    //Invalid JSON format : Not related to client. as import-client required
    @Test
    public void testProcessJson() {
        ValidationRest validationRest = new ValidationRest(validationServiceImpl);
        String json = "{\"key\": \"value\"}";
        ResponseEntity<?> response = validationRest.processJson(json, "123");

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertEquals("Invalid JSON format", response.getBody());
    }


    @Test
    public void testProcessJson_InvalidJson_ReturnsBadRequestResponse() {
        ValidationRest validationRest = new ValidationRest(validationServiceImpl);
        String json = "invalid";

        ResponseEntity<?> response = validationRest.processJson(json, "123");

        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertEquals("JSON is a single value. ", response.getBody());
    }


    @Test
    public void testProcessJson_ExceptionThrown_ReturnsBadRequestResponse() {
        ValidationRest validationRest = new ValidationRest(validationServiceImpl);
        String json = "[ {\n";

        ResponseEntity<?> response = validationRest.processJson(json, "123");

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertEquals("Invalid JSON format", response.getBody());
    }


    @Test
    public void testProcessJsonWithInvalidJson() {
        ValidationRest validationRest = new ValidationRest(validationServiceImpl);
        String json = "{\"key\": \"value\","; // Invalid JSON

        ResponseEntity<?> response = validationRest.processJson(json, "123");


        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertEquals("Invalid JSON format", response.getBody());
    }


    @Test
    public void testProcessJson_InvalidJson_BadRequest() {
        ValidationRest validationRest = new ValidationRest(validationServiceImpl);
        String json = "invalid json";

        ResponseEntity<?> response = validationRest.processJson(json, "123");

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        Assertions.assertEquals("Invalid JSON format", response.getBody());

    }

    @Test
    public void testProcessJson_SingleValueJson_BadRequest() {
        ValidationRest validationRest = new ValidationRest(validationServiceImpl);
        String json = "123";

        ResponseEntity<?> response = validationRest.processJson(json, "123");

        Assertions.assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertEquals("JSON is a single value. ", response.getBody());
    }

    
}

















/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        try {
            ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        String oci=importClientRequest.getClient().getLookupID();
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String clientId =clientResponse(importClientRequest.getClient().getLookupID());
        System.out.println(clientId);
        ArrayList<Location> updatedLocation = locationResponse(locations);
        ImportClientRequest importClientRequest1 = preImportClientRequest(importClientRequest,clientId,updatedLocation,importClientRequest.getClient().getLookupID());
        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest1, tokenCache.retrieveTokenFromCache(correlationId));
        updateLookUpTable(clientId, importClientResponse.getResult().getClientLookupID(),updatedLocation,oci,importClientResponse);
        return importClientResponse;
        } catch (CustomException e) {
            if (LOGGER.isErrorEnabled()) {
                LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Import Client request Failed in LC360 {}", HttpStatus.BAD_REQUEST.value());
            }
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }















package uk.co.allianz.rap.lc.rest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;
import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;


@RestController
public class ValidationRest {
    private static final Logger LOGGER = (Logger) LoggerFactory
            .getLogger(ValidationRest.class);
    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    /***
     * Build the end point/Resource path: POST: surveySubmission
     *     Build standard JSON validation on incoming data
     *     Consumed the correlation id.
     */
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<?> processJson(@RequestBody(required = false) final String json, @RequestHeader("Correlation-ID") final String correlationId) {
        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            LOGGER.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");
        }
        ImportClientResponse processedJson = null;
        try {
            //for validate JSON
            String validateInput = validationServiceImpl.processJson(json);
            //For import only client
            processedJson = importClientServiceImp.importClient(validateInput, correlationId);
            //checking result
            if (processedJson.getResult().isSuccess() == true) {
                LOGGER.info(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_SUCCESS), " client imported Successfully in LC360 {}", HttpStatus.OK.value());
            } else {
                LOGGER.info("Error :" + processedJson.getResult().getErrors());
                LOGGER.info(" client imported Unsuccessfully in LC360 {}", HttpStatus.UNPROCESSABLE_ENTITY.value());
                return ResponseEntity.unprocessableEntity().body(processedJson.getResult().getErrors());
            }
            return ResponseEntity.ok(processedJson);
        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            if (LOGGER.isErrorEnabled()) {
                LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Import Client request Failed in LC360 {}", HttpStatus.BAD_REQUEST.value());
            }
            return ResponseEntity.badRequest().body(e.getMessage());
        } catch (Exception e) {
            // Other exceptions
            LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Invalid JSON: {} ", HttpStatus.INTERNAL_SERVER_ERROR.value());
            return ResponseEntity.internalServerError().body("Invalid JSON format");
        }
    }
}



















package uk.co.allianz.rap.lc.rest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;
import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;


@RestController
public class ValidationRest {
    private static final Logger LOGGER = (Logger) LoggerFactory
            .getLogger(ValidationRest.class);
    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    /***
     * Build the end point/Resource path: POST: surveySubmission
     *     Build standard JSON validation on incoming data
     *     Consumed the correlation id.
     */
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<?> processJson(@RequestBody(required = false) final String json, @RequestHeader("Correlation-ID") final String correlationId) {
        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            LOGGER.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");
        }
        try {
            //for validate JSON
            String validateInput = validationServiceImpl.processJson(json);
            //For import only client
            ImportClientResponse processedJson = importClientServiceImp.importClient(validateInput, correlationId);
            //log.info("JSON received successfully");
            LOGGER.info(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_SUCCESS), " client imported Successfully in LC360 {}", HttpStatus.OK.value());
            return ResponseEntity.ok(processedJson);
        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            if (LOGGER.isErrorEnabled()) {
                LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Import Client request Failed in LC360 {}", HttpStatus.BAD_REQUEST.value());
            }
            return ResponseEntity.badRequest().body(e.getMessage());
        } catch (Exception e) {
            // Other exceptions
            LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Invalid JSON: {} ", HttpStatus.INTERNAL_SERVER_ERROR.value());
            return ResponseEntity.internalServerError().body("Invalid JSON format");
        }
    }
}















///////////////////////////
package uk.co.allianz.rap.lc.model.response.importclient;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.ArrayList;
@SuppressWarnings("unused")
@Data
public class Result {
    @JsonProperty("ClientID")
    private String clientID;
    @JsonProperty("ClientLookupID")
    private String clientLookupID;
    @JsonProperty("IsDeleted")
    private boolean isDeleted;
    @JsonProperty("Errors")
    private ArrayList<Object> errors;
    @JsonProperty("Warnings")
    private Object warnings;
    @JsonProperty("Success")
    private boolean success;
    @JsonProperty("Locations")
    private ArrayList<Location> locations;
    @JsonProperty("CommercialCoverages")
    private ArrayList<Object> commercialCoverages;
    @JsonProperty("Messages")
    private ArrayList<Object> messages;
}














package uk.co.allianz.rap.lc.dao;

import java.util.Map;

public interface LossControlDao {

    //client
    void insertClinetData(String clientId, String lc360ClientId);
    Map<String, Object> findLc360ClientID(String clientId);
    ;




    //location

    void insertLocationData(String locationId, String lc360LocationId);

    Map<String, Object> findLc360LocationID(String locationId);

    Map<String, Object> findLocationID(String locationId);

}



/////////////////////////////////////////////
package uk.co.allianz.rap.lc.service;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import java.util.ArrayList;
import java.util.Map;
import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;





/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */
@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;





    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {



        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        String oci=importClientRequest.getClient().getLookupID();
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        String clientId =clientResponse(importClientRequest.getClient().getLookupID());
        System.out.println(clientId);
        ArrayList<Location> updatedLocation = locationResponse(locations);



        ImportClientRequest importClientRequest1 = preImportClientRequest(importClientRequest,clientId,updatedLocation,importClientRequest.getClient().getLookupID());



        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest1, tokenCache.retrieveTokenFromCache(correlationId));
        updateLookUpTable(clientId, importClientResponse.getResult().getClientLookupID(),updatedLocation,oci,importClientResponse);
        return importClientResponse;
    }



    public String clientResponse(String clientLookupId){
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(clientLookupId);
        if(clientResult != null){
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            return lc360ClientId;
        }else {
            return clientLookupId;
        }
    }
    public ArrayList<Location>  locationResponse(ArrayList<Location> locations){
        for (int index = 0; index < locations.size(); index++) {
            String lookupID = locations.get(index).getLookupID();
            System.out.println("LookupID at index " + index + ": " + lookupID);
            if (locations.get(index).getLookupID() == null) {
                locations.remove(index);
            }
        }
        return locations;
    }
    public ImportClientRequest preImportClientRequest(ImportClientRequest importClientRequest,String clientId,ArrayList<Location> updatedLocation,String orignalClientID) throws JsonProcessingException {



        for (Location location : updatedLocation) {
            Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID() + "_" + orignalClientID);
            if (locationResult != null) {
                LOGGER.info("Location are present");
                String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                location.setLookupID(lc360LocationId);
                objectMapper.writeValueAsString(importClientRequest);
                System.out.println(importClientRequest);
            }
        }
        if(clientId.equals(importClientRequest.getClient().getLookupID())){
            LOGGER.info("client is not present");
            System.out.println(importClientRequest);
            return importClientRequest;
        }else {
            importClientRequest.getClient().setLookupID(clientId);
            objectMapper.writeValueAsString(importClientRequest);
            System.out.println(importClientRequest);
            return importClientRequest;
        }
    }
    public void updateLookUpTable(String clientId, String lc360ClientId,ArrayList<Location> updatedLocation ,String originalClientId,ImportClientResponse importClientResponse) {
        String id =originalClientId;
        if (clientId.equals(lc360ClientId)) {
            LOGGER.info("client is present in lookup table");
        } else {
            lossControlDao.insertClinetData(clientId, lc360ClientId);
        }

        for (int index = 0; index < updatedLocation.size(); index++) {
            String lookupID = updatedLocation.get(index).getLookupID();



            Map<String, Object> locationResult = lossControlDao.findLocationID(lookupID);
            if (locationResult == null) {
                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                lossControlDao.insertLocationData(updatedLocation.get(index).getLookupID() + "_" + originalClientId, locationsResponse.get(index).getLocationLookupID());
            }
        }
    }
}










//package uk.co.allianz.rap.lc.service;
//
//import com.fasterxml.jackson.core.JsonProcessingException;
//import com.fasterxml.jackson.databind.ObjectMapper;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.stereotype.Service;
//import uk.co.allianz.rap.lc.cache.TokenCache;
//import uk.co.allianz.rap.lc.dao.LossControlDao;
//import uk.co.allianz.rap.lc.exception.CustomException;
//import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
//import uk.co.allianz.rap.lc.model.request.importclient.Location;
//import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
//
//import java.util.ArrayList;
//import java.util.Map;
//
//import ch.qos.logback.classic.Logger;
//import org.slf4j.LoggerFactory;
//
//
///**
// * Extracting fields and data from the "data model".
// * sent from loss-control-adapter and building the API request: ImportClient
// */
//@Service
//public class ImportClientServiceImp implements ImportClientService {
//    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
//    @Autowired
//    private TokenCache tokenCache;
//    @Autowired
//    private LossControlDao lossControlDao;
//    @Autowired
//    private LossControlServiceImpl lossControlServiceImpl;
//    @Autowired
//    private ObjectMapper objectMapper;
//
//
//    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
//
//
//        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
//        String oci = importClientRequest.getClient().getLookupID();
//        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
//        String clientId = clientResponse(importClientRequest.getClient().getLookupID());
//        System.out.println(clientId);
//        ArrayList<Location> updatedLocation = locationResponse(locations);
//        ImportClientRequest importClientRequest1 = preImportClientRequest(importClientRequest, clientId, updatedLocation, importClientRequest.getClient().getLookupID());
//        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest1, tokenCache.retrieveTokenFromCache(correlationId));
//        updateLookUpTable(clientId, importClientResponse.getResult().getClientLookupID(), updatedLocation, oci, importClientResponse);
//        return importClientResponse;
//    }
//    public String clientResponse(String clientLookupId) {
//        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(clientLookupId);
//        if (clientResult != null) {
//            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
//            return lc360ClientId;
//        } else {
//            return clientLookupId;
//        }
//    }
//
//    public ArrayList<Location> locationResponse(ArrayList<Location> locations) {
//        for (int index = 0; index < locations.size(); index++) {
//            String lookupID = locations.get(index).getLookupID();
//            System.out.println("LookupID at index " + index + ": " + lookupID);
//            if (locations.get(index).getLookupID() == null) {
//                locations.remove(index);
//            }
//        }
//        return locations;
//    }
//
//    public ImportClientRequest preImportClientRequest(ImportClientRequest importClientRequest, String clientId, ArrayList<Location> updatedLocation, String orignalClientID) throws JsonProcessingException {
//
//
//        for (Location location : updatedLocation) {
//            Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID() + "_" + orignalClientID);
//            if (locationResult != null) {
//                LOGGER.info("Location are present");
//                String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
//                location.setLookupID(lc360LocationId);
//                objectMapper.writeValueAsString(importClientRequest);
//                System.out.println(importClientRequest);
//            }
//        }
//        if (clientId.equals(importClientRequest.getClient().getLookupID())) {
//            LOGGER.info("client is not present");
//            System.out.println(importClientRequest);
//            return importClientRequest;
//        } else {
//            importClientRequest.getClient().setLookupID(clientId);
//            objectMapper.writeValueAsString(importClientRequest);
//            System.out.println(importClientRequest);
//            return importClientRequest;
//        }
//    }
//
//    public void updateLookUpTable(String clientId, String lc360ClientId, ArrayList<Location> updatedLocation, String originalClientId, ImportClientResponse importClientResponse) {
//        String id = originalClientId;
//        if (clientId.equals(lc360ClientId)) {
//            LOGGER.info("client is present in lookup table");
//        } else {
//            lossControlDao.insertClinetData(clientId, lc360ClientId);
//        }
//
//        for (int index = 0; index < updatedLocation.size(); index++) {
//            String lookupID = updatedLocation.get(index).getLookupID();
//            Map<String, Object> locationResult = lossControlDao.findLc360LocationID(lookupID+"_"+id);// "select location_id from location_lookup where lc360_location_id = ? "
//            System.out.println("locationResult:"+locationResult);
//            if (locationResult == null) {//not inserting here if location_id present in DB
//                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
//                lossControlDao.insertLocationData(updatedLocation.get(index).getLookupID() + "_" + originalClientId, locationsResponse.get(index).getLocationLookupID());
//            }
//        }
//    }
//}


//package uk.co.allianz.rap.lc.service;
//import com.fasterxml.jackson.core.JsonProcessingException;
//import com.fasterxml.jackson.databind.ObjectMapper;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.stereotype.Service;
//import uk.co.allianz.rap.lc.cache.TokenCache;
//import uk.co.allianz.rap.lc.dao.LossControlDao;
//import uk.co.allianz.rap.lc.exception.CustomException;
//import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
//import uk.co.allianz.rap.lc.model.request.importclient.Location;
//import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
//import java.util.ArrayList;
//import java.util.Map;
//import ch.qos.logback.classic.Logger;
//import org.slf4j.LoggerFactory;
//
//
//
///**
// * Extracting fields and data from the "data model".
// * sent from loss-control-adapter and building the API request: ImportClient
// */
//@Service
//public class ImportClientServiceImp implements ImportClientService {
//    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
//    @Autowired
//    private TokenCache tokenCache;
//    @Autowired
//    private LossControlDao lossControlDao;
//    @Autowired
//    private LossControlServiceImpl lossControlServiceImpl;
//    @Autowired
//    private ObjectMapper objectMapper;
//
//
//    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
//
//        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
//        String oci=importClientRequest.getClient().getLookupID();
//        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
//        String clientId =clientResponse(importClientRequest.getClient().getLookupID());
//        System.out.println(clientId);
//        ArrayList<Location> updatedLocation = locationResponse(locations);
//
//        ImportClientRequest importClientRequest1 = preImportClientRequest(importClientRequest,clientId,updatedLocation,importClientRequest.getClient().getLookupID());
//
//        ImportClientResponse importClientResponse = lossControlServiceImpl.clientPost(importClientRequest1, tokenCache.retrieveTokenFromCache(correlationId));
//        updateLookUpTable(clientId, importClientResponse.getResult().getClientLookupID(),updatedLocation,oci,importClientResponse);
//        return importClientResponse;
//    }
//
//    public String clientResponse(String clientLookupId){
//        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(clientLookupId);
//        if(clientResult != null){
//            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
//            return lc360ClientId;
//        }else {
//            return clientLookupId;
//        }
//    }
//    public ArrayList<Location>  locationResponse(ArrayList<Location> locations){
//        for (int index = 0; index < locations.size(); index++) {
//            String lookupID = locations.get(index).getLookupID();
//            System.out.println("LookupID at index " + index + ": " + lookupID);
//            if (locations.get(index).getLookupID() == null) {
//                locations.remove(index);
//            }
//        }
//        return locations;
//    }
//    public ImportClientRequest preImportClientRequest(ImportClientRequest importClientRequest,String clientId,ArrayList<Location> updatedLocation,String orignalClientID) throws JsonProcessingException {
//
//        for (Location location : updatedLocation) {
//            Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID() + "_" + orignalClientID);
//            if (locationResult != null) {
//                LOGGER.info("Location are present");
//                String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
//                location.setLookupID(lc360LocationId);
//                objectMapper.writeValueAsString(importClientRequest);
//                System.out.println(importClientRequest);
//            }
//        }
//        if(clientId.equals(importClientRequest.getClient().getLookupID())){
//            LOGGER.info("client is not present");
//            System.out.println(importClientRequest);
//            return importClientRequest;
//        }else {
//            importClientRequest.getClient().setLookupID(clientId);
//            objectMapper.writeValueAsString(importClientRequest);
//            System.out.println(importClientRequest);
//            return importClientRequest;
//        }
//    }
//    public void updateLookUpTable(String clientId, String lc360ClientId,ArrayList<Location> updatedLocation ,String originalClientId,ImportClientResponse importClientResponse) {
//        String id =originalClientId;
//        if (clientId.equals(lc360ClientId)) {
//            LOGGER.info("client is present in lookup table");
//        } else {
//            lossControlDao.insertClinetData(clientId, lc360ClientId);
//        }
//        // String id =originalClientId;
//        for (int index = 0; index < updatedLocation.size(); index++) {
//            String lookupID = updatedLocation.get(index).getLookupID();
//            System.out.println(lookupID);
//            System.out.println(originalClientId);
//            System.out.println(updatedLocation.get(index).getLookupID() + "_" + id);
//            Map<String, Object> locationResult = lossControlDao.findLc360LocationID(updatedLocation.get(index).getLookupID() + "_" + id);
//            if (locationResult != null) {//
//                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
//                lossControlDao.insertLocationData(updatedLocation.get(index).getLookupID() + "_" + originalClientId, locationsResponse.get(index).getLocationLookupID());
//            }
//        }
//    }
//}















//////////////////////////////////////////////////////////////////

package uk.co.allianz.rap.lc.dao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;



import java.util.Map;



@Repository
public class LossControlDaoImpl implements LossControlDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;



    //client methods



    @Override
    public void insertClinetData(final String clientId, final String lc360ClientId) {
        String insertClient = "insert into client_lookup (client_id, lc360_client_id) values (?, ?)";
        this.jdbcTemplate.update(insertClient, clientId, lc360ClientId);
    }



    @Override
    public void insertLocationData(String locationId, String lc360LocationId) {
        String insertLocation = "insert into location_lookup (location_id, lc360_location_id) values (?, ?)";
        this.jdbcTemplate.update(insertLocation, locationId, lc360LocationId);
    }



    @Override
    public Map<String, Object> findLc360ClientID(final String clientId) {
        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360ClientId, clientId);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }



    @Override
    public Map<String, Object> findLc360LocationID(final String locationId) {
        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(lc360LocationId, locationId);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }



    @Override
    public Map<String, Object> findLocationID(String lc360LocationId) {
        String location = "select location_id from location_lookup where lc360_location_id = ? ";
        Map<String, Object> result;
        try {
            result = this.jdbcTemplate.queryForMap(location, lc360LocationId);
        } catch (EmptyResultDataAccessException exception) {
            return null;
        }
        return result;
    }
}



//package uk.co.allianz.rap.lc.dao;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.dao.EmptyResultDataAccessException;
//import org.springframework.jdbc.core.JdbcTemplate;
//import org.springframework.stereotype.Repository;
//
//
//
//import java.util.Map;
//
//
//
//@Repository
//public class LossControlDaoImpl implements LossControlDao {
//    @Autowired
//    private JdbcTemplate jdbcTemplate;
//
//
//
//    //client methods
//    ///////
//    public Map<String, Object> findLocationID1(String lc360LocationId) {
//        String location = "select location_id from location_lookup where lc360_location_id = ? ";
//
//        Map<String, Object> result;
//        try {
//            result = this.jdbcTemplate.queryForMap(location, lc360LocationId);
//        } catch (EmptyResultDataAccessException exception) {
//            return null;
//        }
//        return result;
//    }
///////////////////////////////////
//    @Override
//    public void insertClinetData(final String clientId, final String lc360ClientId) {
//        String insertClient = "insert into client_lookup (client_id, lc360_client_id) values (?, ?)";
//        this.jdbcTemplate.update(insertClient, clientId, lc360ClientId);
//    }
//
//
//
//    @Override
//    public void insertLocationData(String locationId, String lc360LocationId) {
//        String insertLocation = "insert into location_lookup (location_id, lc360_location_id) values (?, ?)";
//        this.jdbcTemplate.update(insertLocation, locationId, lc360LocationId);
//    }
//
//
//
//    @Override
//    public Map<String, Object> findLc360ClientID(final String clientId) {
//        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
//        Map<String, Object> result;
//        try {
//            result = this.jdbcTemplate.queryForMap(lc360ClientId, clientId);
//        } catch (EmptyResultDataAccessException exception) {
//            return null;
//        }
//        return result;
//    }
//
//
//
//    @Override
//    public Map<String, Object> findLc360LocationID(final String locationId) {
//        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
//        Map<String, Object> result;
//        try {
//            result = this.jdbcTemplate.queryForMap(lc360LocationId, locationId);
//        } catch (EmptyResultDataAccessException exception) {
//            return null;
//        }
//        return result;
//    }
//
//
//
//    @Override
//    public Map<String, Object> findLocationID(String lc360LocationId) {
//        String location = "select location_id from location_lookup where lc360_location_id = ? ";
//        Map<String, Object> result;
//        try {
//            result = this.jdbcTemplate.queryForMap(location, lc360LocationId);
//        } catch (EmptyResultDataAccessException exception) {
//            return null;
//        }
//        return result;
//    }
//}

//package uk.co.allianz.rap.lc.dao;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.dao.EmptyResultDataAccessException;
//import org.springframework.jdbc.core.JdbcTemplate;
//import org.springframework.stereotype.Repository;
//
//import java.util.Map;
//
//@Repository
//public class LossControlDaoImpl implements LossControlDao {
//    @Autowired
//    private JdbcTemplate jdbcTemplate;
//
//    //client methods
//
//    @Override
//    public void insertClinetData(final String clientId, final String lc360ClientId) {
//        String insertClient = "insert into client_lookup (client_id, lc360_client_id) values (?, ?)";
//        this.jdbcTemplate.update(insertClient, clientId, lc360ClientId);
//    }
//
//    @Override
//    public void insertLocationData(String locationId, String lc360LocationId) {
//        String insertLocation = "insert into location_lookup (location_id, lc360_location_id) values (?, ?)";
//        this.jdbcTemplate.update(insertLocation, locationId, lc360LocationId);
//    }
//
//    @Override
//    public Map<String, Object> findLc360ClientID(final String clientId) {
//        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";
//        Map<String, Object> result;
//        try {
//            result = this.jdbcTemplate.queryForMap(lc360ClientId, clientId);
//        } catch (EmptyResultDataAccessException exception) {
//            return null;//enable flag when u get LC360 response back.. u
//        }
//        return result;
//    }
//
//    @Override
//    public Map<String, Object> findLc360LocationID(final String locationId) {
//        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
//        Map<String, Object> result;
//        try {
//            result = this.jdbcTemplate.queryForMap(lc360LocationId, locationId);
//        } catch (EmptyResultDataAccessException exception) {
//            return null;
//        }
//        return result;
//    }
//
//    @Override
//    public Map<String, Object> findLocationID(String locationId) {
//
//     String combineLocationId = "select * from location_lookup where location_id = ? ";
//
//        Map<String, Object> result;
//        try {
//            result = this.jdbcTemplate.queryForMap(combineLocationId, locationId);
//        } catch (EmptyResultDataAccessException exception) {
//            return null;
//        }
//        return result;    }
//}




//package uk.co.allianz.rap.lc.dao;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.dao.EmptyResultDataAccessException;
//import org.springframework.jdbc.core.JdbcTemplate;
//import org.springframework.stereotype.Repository;
//
//import java.util.Map;
//
//@Repository
//public class LossControlDaoImpl implements LossControlDao {
//    @Autowired
//    private JdbcTemplate jdbcTemplate;
//
//    //client methods
//    @Override
//    public void insertClientId(final String clientId) {
//        String insert = "insert into client_lookup(client_id) values(?)";
//        this.jdbcTemplate.update(insert, clientId);
//    }
////1st and 2nd method combine
//    @Override
//    public void updateLcClientId(final String clientId, final String lc360ClientId) {
//        String update = "update client_lookup set lc360_client_id = ? where client_id = ?";
//        this.jdbcTemplate.update(update, lc360ClientId, clientId);
//    }
//
//    @Override
//    public Map<String, Object> findByClientId(final String clientId) {
//        String checkClientId = "select * from client_lookup where client_id =?";
//        Map<String, Object> result;
//        try {
//            result = this.jdbcTemplate.queryForMap(checkClientId, clientId);
//        } catch (EmptyResultDataAccessException exception) {
//            return null;
//        }
//        return result;
//    }
//// 3rd + 4th methods combuined
//    @Override
//    public Map<String, Object> findLc360ClientID(final String clientId) {
//        String lc360ClientId = "select lc360_client_id from client_lookup where client_id = ? ";//empty need to set flag..update client needed something(require an update) record need to be inserted..enabling flag for that......lc360 id not pressent
//        Map<String, Object> result;// for location : if lookupId corresponding not present LC360 ID.. enable flg locationIDUpdated...based on this flag value when u get response back.. flag TRUe..fire insert query..then it insert 2 records
//        try {
//            result = this.jdbcTemplate.queryForMap(lc360ClientId, clientId);
//        } catch (EmptyResultDataAccessException exception) {
//            return null;
//        }
//        return result;
//    }
//
//    // Locations methods
//    @Override
//    public void insertLocationId(final String locationId) {
//        String insert = "insert into location_lookup(location_id) values(?)";
//        this.jdbcTemplate.update(insert, locationId);
//    }
//
//    @Override
//    public void updateLcLocationId(final String locationId, final String lc360LocationId) {
//        String update = "update location_lookup set lc360_location_id = ? where location_id = ?";
//        this.jdbcTemplate.update(update, lc360LocationId, locationId);
//    }
//
//    @Override
//    public Map<String, Object> findByLocationId(final String locationId) {
//        String checkLocationId = "select * from location_lookup where location_id =?";
//        Map<String, Object> result;
//        try {
//            result = this.jdbcTemplate.queryForMap(checkLocationId, locationId);
//        } catch (EmptyResultDataAccessException exception) {
//            return null;
//        }
//        return result;
//    }
//
//    @Override
//    public Map<String, Object> findLc360LocationID(final String locationId) {
//        String lc360LocationId = "select lc360_location_id from location_lookup where location_id = ? ";
//        Map<String, Object> result;
//        try {
//            result = this.jdbcTemplate.queryForMap(lc360LocationId, locationId);
//        } catch (EmptyResultDataAccessException exception) {
//            return null;
//        }
//        return result;
//    }
//}
































///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





ArrayList<Location> sameLocations = new ArrayList<>();
ArrayList<Location> differentLocations = new ArrayList<>();

for (int index = 0; index < importClientRequestLocations.size(); index++) {
    Location importClientRequestLocation = importClientRequestLocations.get(index);
    Location otherLocation = otherLocations.get(index);

    if (importClientRequestLocation.equals(otherLocation)) {
        sameLocations.add(importClientRequestLocation); // Add the same location to the sameLocations list
    } else {
        differentLocations.add(importClientRequestLocation); // Add the different location to the differentLocations list
    }
}

if (!sameLocations.isEmpty()) {
    // Return the list of same locations in the if block
    return sameLocations;
} else {
    // Return the list of different locations in the else block
    return differentLocations;
}














boolean isValid = true; // Initialize the isValid flag to true

if (importClientRequest.getClient() == null) {
    LOGGER.info("Client is null");
    isValid = false; // Set the flag to false if client is null
}

for (Location location : locations) {
    if (location == null) {
        LOGGER.info("Location is null");
        isValid = false; // Set the flag to false if any location is null
    }




// for validation
for (Location location : locations) {
    if (importClientRequest.getClient() == null) {
        throw new CustomValidationException("Client is null");
    }
    
    if (location == null) {
        throw new CustomValidationException("Location is null");
    }











for (Location location : locations) {
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(location.getLookupID() + "_" + clientID);
                if (locationResult != null) {
                    //            //3a. If lookup value exists for the loc,
                    LOGGER.info("Location are present in DB");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    //3a.1 Update the lc360 loc id in request.
                    location.setLookupID(lc360LocationId);
                    objectMapper.writeValueAsString(importClientRequest);
                    LOGGER.info("Received JSON");
//                    3a.3 Send the modified request back
                    importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
                } else {
                    //look up doesnt exist)
                    objectMapper.writeValueAsString(importClientRequest);
                    LOGGER.info("Received JSON");
                    LOGGER.info("Location are not present in DB");
                    //3a.1 Use the same JSON request
//                    Send the same request back
                    //. Invoke LC360
                    importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
                    for (int index = 0; index < locations.size(); index++) {
                        String lookupID = locations.get(index).getLookupID();
                        if (locations.get(index).getLookupID() != null) {
                            LOGGER.info("location LookUpID is not null");// location not present in DB
                            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                            //4a. Process Response
                            lossControlDao.insertLocationData(locations.get(index).getLookupID() + "_" + clientID, locationsResponse.get(index).getLocationLookupID());
                        }
                    }
                }
            }

/////////////////////////////////////


package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
        Map<String, Object> locationResult = lossControlDao.findLc360LocationID(locations.get(0).getLookupID());
        if (clientResult != null) {
            LOGGER.info("Client are present");
            //performed locationLookup
            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            String clientID = importClientRequest.getClient().getLookupID();
            //set client id and location id in pojo
            importClientRequest.getClient().setLookupID(lc360ClientId);//
            //location
            if (locationResult != null) {
                LOGGER.info("Location are present");
                String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                locations.get(0).setLookupID(lc360LocationId);
            }
            objectMapper.writeValueAsString(importClientRequest);
            LOGGER.info("Received JSON");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            if (locations.get(0).getLookupID() != null ) {
                LOGGER.info("location LookUpID is not null");
                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                lossControlDao.insertLocationData(locations.get(0).getLookupID() + "_" + clientID, locationsResponse.get(0).getLocationLookupID());
                System.out.println("lc360ClientId:"+lc360ClientId);
            }
        }

            return importClientResponse;
        } else {
            LOGGER.info("Client are not present");
            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));//check condition if null not come here
            lossControlDao.insertData(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());

            if (locations.get(0).getLookupID() != null) {
                LOGGER.info("location LookUpID is not null");
                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                lossControlDao.insertLocationData(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
            }
        }
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}



































//Fixed my code //find bugs //detect the error in code

package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory.getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        String clientID = importClientRequest.getClient().getLookupID();

        if (clientResult != null) {
            LOGGER.info("Client are present");
            ArrayList<Location> locations = importClientRequest.getClient().getLocations();

            for (int index = 0; index < locations.size(); index++) {
                String lookupID = locations.get(index).getLookupID();
                System.out.println("LookupID at index " + index + ": " + lookupID);
                Map<String, Object> locationResult = lossControlDao.findLc360LocationID(locations.get(index).getLookupID());
                //performed locationLookup
                String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
                //set client id and location id in pojo
                importClientRequest.getClient().setLookupID(lc360ClientId);

                if (locationResult != null) {
                    LOGGER.info("Location are present");
                    String lc360LocationId = (String) locationResult.get(locationResult.keySet().iterator().next());
                    locations.get(index).setLookupID(lc360LocationId);
                }
                objectMapper.writeValueAsString(importClientRequest);
                LOGGER.info("Received JSON");
                importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
                if (locations.get(index).getLookupID() != null) {
                    LOGGER.info("location LookUpID is not null");
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(locations.get(index).getLookupID() + "_" + clientID, locationsResponse.get(index).getLocationLookupID());
                    System.out.println("lc360ClientId:" + lc360ClientId);
                }
            }

//            if(locationResult != null){
//                LOGGER.info("location not present ");
//                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
//                lossControlDao.insertLocationData(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());            }

            return importClientResponse;
        } else {
            LOGGER.info("Client are not present");

            if (importClientRequest.getClient().getLookupID() == null) {
                LOGGER.info("Client LookUpID is null");
            }
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));//check condition if null not come here
            lossControlDao.insertData(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            //
            ArrayList<Location> locations1 = importClientRequest.getClient().getLocations();

            for (int index = 0; index < locations1.size(); index++) {
                String lookupID = locations1.get(index).getLookupID();
                System.out.println("LookupID at index " + index + ": " + lookupID);
                //
                if (locations1.get(index).getLookupID() != null) {
                    LOGGER.info("location LookUpID is not null");//location not present in DB
                    ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                    lossControlDao.insertLocationData(locations1.get(index).getLookupID() + "_" + clientID, locationsResponse.get(index).getLocationLookupID());
                }
            }
        }
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}





































for (int index = 0; index < locations.size(); index++) {
                String lookupID = locations.get(index).getLookupID();
                System.out.println("LookupID at index " + index + ": " + lookupID);
                //
            if (locations.get(index).getLookupID() != null) {
                LOGGER.info("location LookUpID is not null");
                ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
                lossControlDao.insertLocationData(locations.get(index).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(index).getLocationLookupID());
                }
            }










package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.cache.TokenCache;
import uk.co.allianz.rap.lc.dao.LossControlDao;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
import uk.co.allianz.rap.lc.model.request.importclient.Location;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;

import java.util.ArrayList;
import java.util.Map;

import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;

/**
 * Extracting fields and data from the "data model".
 * sent from loss-control-adapter and building the API request: ImportClient
 */

@Service
public class ImportClientServiceImp implements ImportClientService {
    private static final Logger LOGGER = (Logger) LoggerFactory
            .getLogger(ImportClientServiceImp.class);
    @Autowired
    private TokenCache tokenCache;
    @Autowired
    private LossControlDao lossControlDao;
    @Autowired
    private LossControlServiceImpl lossControlServiceImpl;
    @Autowired
    private ObjectMapper objectMapper;

    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
        ImportClientResponse importClientResponse = null;
        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
        ArrayList<Location> locations = importClientRequest.getClient().getLocations();

        //checking value already in DB or not ?
        Map<String, Object> clientResult = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
        //need flag...Client ID really exits in DB..Do i need to update ?

        if (clientResult != null) {//Instead of flag here we used clientResult...Client and Location are present ? ... no need to insert in DB
            LOGGER.info("Client and Location are present"); // so no need to insert ... line 53
            //performed locationLookup
            for (int index = 0; index < locations.size(); index++) {
                String lookupID = locations.get(index).getLookupID();
                System.out.println("LookupID at index " + index + ": " + lookupID);
                Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(lookupID + "_" + importClientRequest.getClient().getLookupID());
                String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
                locations.get(index).setLookupID(lc360LocationId);
            }

            String lc360ClientId = (String) clientResult.get(clientResult.keySet().iterator().next());
            //set client id and location id in pojo
            importClientRequest.getClient().setLookupID(lc360ClientId);
            objectMapper.writeValueAsString(importClientRequest);
            LOGGER.info("Received JSON");
            //passing enriched importClientRequest file ...request contains updated Client + Location >>invoking LC360
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            return importClientResponse;
        } else {
            LOGGER.info("Client and Location are not present");
            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
            lossControlDao.insertData(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
            ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();

            for (int index = 0; index < locations.size(); index++) {
                String lookupID = locations.get(index).getLookupID();
                System.out.println("LookupID at index " + index + ": " + lookupID);
                lossControlDao.insertLocationData(locations.get(index).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(index).getLocationLookupID());
            }
        }
        LOGGER.info("importClientResponse Successfully Received");
        return importClientResponse;
    }
}
















//    public ImportClientResponse getClientResponse(final ImportClientRequest importClientRequest, final ArrayList<Location> locations, final String correlationId) throws CustomException {
//        LOGGER.info("Client and Location are not present");
//        ImportClientResponse importClientResponse = null;
//        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
//        lossControlDao.insertData(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
//        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
//        lossControlDao.insertLocationData(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
//        return importClientResponse;
//    }


//    public ImportClientResponse ifClientIsPresent(final ImportClientRequest importClientRequest, final ArrayList<Location> locations, final String correlationId) throws CustomException, JsonProcessingException {
//        if (importClientRequest == null) {
//            return null;
//        }
//        //finding LC360 client id in DB exist or not
//        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
//        ImportClientResponse importClientResponse = null;
//        //finding LC360 location id in DB exist or not(combined location lookup ID and client id)
//        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID());
//        if (lcClientId != null) {
//            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
//            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
//            //set client id and location id in pojo
//            importClientRequest.getClient().setLookupID(lc360ClientId);
//            locations.get(0).setLookupID(lc360LocationId);
//            objectMapper.writeValueAsString(importClientRequest);
//            LOGGER.info("Received JSON");
//            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
//
//        }
//        return importClientResponse;
//    }
//}





//package uk.co.allianz.rap.lc.service;
//
//import com.fasterxml.jackson.core.JsonProcessingException;
//import com.fasterxml.jackson.databind.ObjectMapper;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.stereotype.Service;
//import uk.co.allianz.rap.lc.cache.TokenCache;
//import uk.co.allianz.rap.lc.dao.LossControlDao;
//import uk.co.allianz.rap.lc.exception.CustomException;
//import uk.co.allianz.rap.lc.model.request.importclient.ImportClientRequest;
//import uk.co.allianz.rap.lc.model.request.importclient.Location;
//import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
//
//import java.util.ArrayList;
//import java.util.Map;
//
//import ch.qos.logback.classic.Logger;
//import org.slf4j.LoggerFactory;
//
///**
// * Extracting fields and data from the "data model".
// * sent from loss-control-adapter and building the API request: ImportClient
// */
//
//@Service
//public class ImportClientServiceImp implements ImportClientService {
//    private static final Logger LOGGER = (Logger) LoggerFactory
//            .getLogger(ImportClientServiceImp.class);
//    @Autowired
//    private TokenCache tokenCache;
//    @Autowired
//    private LossControlDao lossControlDao;
//    @Autowired
//    private LossControlServiceImpl lossControlServiceImpl;
//    @Autowired
//    private ObjectMapper objectMapper;
//
//    public ImportClientResponse importClient(final String json, final String correlationId) throws CustomException, JsonProcessingException {
//        ImportClientResponse importClientResponse = null;
//        ImportClientRequest importClientRequest = objectMapper.readValue(json, ImportClientRequest.class);
//        ArrayList<Location> locations = importClientRequest.getClient().getLocations();
//        //finding client id in DB exist or not
//        Map<String, Object> clientResult = lossControlDao.findByClientId(importClientRequest.getClient().getLookupID());
//        if (clientResult != null) {
//            importClientResponse = ifClientIsPresent(importClientRequest, locations, correlationId);// changed the method name ifClientIsPresent
//        } else {
//            importClientResponse = getClientResponse(importClientRequest, locations, correlationId);
//        }
//        LOGGER.info("importClientResponse Successfully Received");
//        return importClientResponse;
//
//    }
//
//    public ImportClientResponse getClientResponse(final ImportClientRequest importClientRequest, final ArrayList<Location> locations, final String correlationId) throws CustomException {
//        LOGGER.info("Client and Location are not present");
//        ImportClientResponse importClientResponse = null;
//        lossControlDao.insertClientId(importClientRequest.getClient().getLookupID());
//        lossControlDao.insertLocationId(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID());
//        importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
//        lossControlDao.updateLcClientId(importClientRequest.getClient().getLookupID(), importClientResponse.getResult().getClientLookupID());
//        ArrayList<uk.co.allianz.rap.lc.model.response.importclient.Location> locationsResponse = importClientResponse.getResult().getLocations();
//        // Lookup ID Response
//        lossControlDao.updateLcLocationId(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID(), locationsResponse.get(0).getLocationLookupID());
////boiller plate code here.. smae code again and again// clint creation ekach method ni whawi.. client creation importclient method madhun whavi
//        return importClientResponse;
//    }
//
//
//    public ImportClientResponse ifClientIsPresent(final ImportClientRequest importClientRequest, final ArrayList<Location> locations, final String correlationId) throws CustomException, JsonProcessingException {
//        if (importClientRequest == null) {
//            return null;
//        }
//        //finding LC360 client id in DB exist or not
//        Map<String, Object> lcClientId = lossControlDao.findLc360ClientID(importClientRequest.getClient().getLookupID());
//        ImportClientResponse importClientResponse = null;
//        //finding LC360 location id in DB exist or not(combined location lookup ID and client id)
//        Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID());
//        if (lcClientId != null) {
//            String lc360ClientId = (String) lcClientId.get(lcClientId.keySet().iterator().next());
//            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());
//            //set client id and location id in pojo
//            importClientRequest.getClient().setLookupID(lc360ClientId);
//            locations.get(0).setLookupID(lc360LocationId);
//            objectMapper.writeValueAsString(importClientRequest);
//            LOGGER.info("Received JSON");
//            importClientResponse = lossControlServiceImpl.clientPost(importClientRequest, tokenCache.retrieveTokenFromCache(correlationId));
//
//        }
//        return importClientResponse;
//    }
//}








///////

ArrayList<Location> locations = importClientRequest.getClient().getLocations();
            Map<String, Object> lcLocationId = lossControlDao.findLc360LocationID(locations.get(0).getLookupID() + "_" + importClientRequest.getClient().getLookupID());
            String lc360LocationId = (String) lcLocationId.get(lcLocationId.keySet().iterator().next());








{
    "divisionLookupID": "AZ_UK",
    "client": {
        "LookupID": "C008032901",
        "ContactFirstName": null,
        "ContactLastName": null,
        "PolicyNumber": "SP26853149",
        "Name": "CLIENT CI Test",
        "Phone": null,
        "Email": null,
        "Address": {
            "Country": "United Kingdom",
            "OverseasTerritories": null,
            "Street1": null,
            "Street2": null,
            "City": null,
            "Region1": null,
            "Region2": null,
            "Region3": null,
            "Region4": null,
            "ZipCode": null
        },
        "Agent": {
            "AgencyCode": "22576",
            "AgencyName": "Arthur J. Gallagher",
            "AgentCode": "13332",
            "AgentName": null,
            "Email": null,
            "FaxNumber": null,
            "PhoneNumber": null,
            "Address": {
                "Country": "GB",
                "OverseasTerritories": null,
                "Street1": null,
                "Street2": null,
                "City": null,
                "Region1": null,
                "Region2": null,
                "Region3": null,
                "Region4": null,
                "ZipCode": null
            },
            "AgentType": "Broker"
        },
        "Underwriter": null,
        "Locations": [
            {
                "genericFields": null,
                "LookupID": "111901",
                "Name": null,
                "PolicyNumber": "SP26853148",
                "PolicyEffectiveDate": null,
                "PolicyExpirationDate": null,
                "PolicyRenewalDate": null,
                "Address": {
                    "Country": "United Kingdom",
                    "OverseasTerritories": null,
                    "Street1": "NEW CROSS DEWEL",
                    "Street2": "SD 11 JEW TOWN",
                    "City": "MM KEMSTONE",
                    "Region1": "UK",
                    "Region2": null,
                    "Region3": null,
                    "Region4": null,
                    "ZipCode": "GU1 1DB"
                },
                "OriginalEffectiveDate": null,
                "EffectiveDate": null,
                "ExpirationDate": null,
                "RenewalDate": "2024-07-17",
                "LastInspectedDate": null,
                "Coverages": [
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "CoverageReference": "Coverage 1",
                        "GenericFields": [
                            {
                                "Number": "1123",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "0",
                                "Key": "04. PD Other",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": null,
                                "Key": "05. PD Other Description",
                                "GenericFieldValueType": 0,
                                "Text": ""
                            },
                            {
                                "Number": "1123",
                                "Key": "06. TIV PD",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "332198",
                                "Key": "07. TIV BI",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "",
                                "Key": "08. BI Base Period (Months)",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "332198",
                                "Key": "09. TIV (PD + BI )",
                                "GenericFieldValueType": 1,
                                "Text": null
                            }
                        ]
                    }
                ],
                "Contact": null
            },
            {
                "genericFields": null,
                "LookupID": "111902",
                "Name": null,
                "PolicyNumber": "SP26853148",
                "PolicyEffectiveDate": null,
                "PolicyExpirationDate": null,
                "PolicyRenewalDate": null,
                "Address": {
                    "Country": "United Kingdom",
                    "OverseasTerritories": null,
                    "Street1": "NEW CROSS DEWEL",
                    "Street2": "SD 11 JEW TOWN",
                    "City": "MM KEMSTONE",
                    "Region1": "UK",
                    "Region2": null,
                    "Region3": null,
                    "Region4": null,
                    "ZipCode": "GU1 1DB"
                },
                "OriginalEffectiveDate": null,
                "EffectiveDate": null,
                "ExpirationDate": null,
                "RenewalDate": "2024-07-17",
                "LastInspectedDate": null,
                "Coverages": [
                    {
                        "CoverageTypeLookup": "PD_TIV",
                        "CoverageReference": "Coverage 1",
                        "GenericFields": [
                            {
                                "Number": "1123",
                                "Key": "01. PD Building",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "0",
                                "Key": "04. PD Other",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": null,
                                "Key": "05. PD Other Description",
                                "GenericFieldValueType": 0,
                                "Text": ""
                            },
                            {
                                "Number": "1123",
                                "Key": "06. TIV PD",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "332198",
                                "Key": "07. TIV BI",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "",
                                "Key": "08. BI Base Period (Months)",
                                "GenericFieldValueType": 1,
                                "Text": null
                            },
                            {
                                "Number": "332198",
                                "Key": "09. TIV (PD + BI )",
                                "GenericFieldValueType": 1,
                                "Text": null
                            }
                        ]
                    }
                ],
                "Contact": null
            }
        ]
    }
}







package uk.co.allianz.rap.lc.rest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;
import uk.co.allianz.rap.lc.exception.CustomException;
import uk.co.allianz.rap.lc.log.LogContext;
import uk.co.allianz.rap.lc.log.LogType;
import uk.co.allianz.rap.lc.model.response.importclient.ImportClientResponse;
import uk.co.allianz.rap.lc.service.ImportClientServiceImp;
import uk.co.allianz.rap.lc.service.ValidationServiceImpl;
import ch.qos.logback.classic.Logger;
import org.slf4j.LoggerFactory;


@RestController
public class ValidationRest {
    private static final Logger LOGGER = (Logger) LoggerFactory
            .getLogger(ValidationRest.class);
    @Autowired
    private ValidationServiceImpl validationServiceImpl;
    @Autowired
    private ImportClientServiceImp importClientServiceImp;

    public ValidationRest(final ValidationServiceImpl validationServiceImpl) {
        this.validationServiceImpl = validationServiceImpl;
    }

    /***
     * Build the end point/Resource path: POST: surveySubmission
     *     Build standard JSON validation on incoming data
     *     Consumed the correlation id.
     */
    @PostMapping(path = "/survey-submission", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<?> processJson(@RequestBody(required = false) final String json, @RequestHeader("Correlation-ID") final String correlationId) {
        if (json == null || json.isEmpty()) {
            // JSON is empty or not present
            LOGGER.info("JSON is empty");
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("JSON is empty");
        }
        try {
            //for validate JSON
            String validateInput = validationServiceImpl.processJson(json);
            //For import only client
            ImportClientResponse processedJson = importClientServiceImp.importClient(validateInput, correlationId);
            //log.info("JSON received successfully");
//           int httpStatusCode= processedJson.get("statusCode").ge
            LOGGER.info(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_SUCCESS), " client imported Successfully in LC360 {}", HttpStatus.OK.value());
            return ResponseEntity.ok(processedJson);
        } catch (CustomException e) {
            // Invalid JSON format or single value detected CustomException.
            if (LOGGER.isErrorEnabled()) {
                LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Import Client request Failed in LC360 {}", HttpStatus.BAD_REQUEST.value());
            }
            return ResponseEntity.badRequest().body(e.getMessage());
        } catch (Exception e) {
            // Other exceptions
            LOGGER.error(LogType.mark(LogContext.ACTION_TYPE, LogContext.IMPORT_CLIENT_REQUEST_FAILED), "Invalid JSON: {} ", HttpStatus.INTERNAL_SERVER_ERROR.value());
            return ResponseEntity.internalServerError().body("Invalid JSON format");
        }
    }
}




























ImportClientResponse processedJson = importClientServiceImp.importClient(validateInput, correlationId);







issues:

Issue Detail
Below is an enumeration of all issues found in the project. The issues are organized by priority and
category and then broken down by the package, namespace, or location in which they occur.
The priority of an issue can be Critical, High, Medium, or Low.
Issues from static analysis reported on at same line number with the same category originate from
different taint sources.
7.1.1 Dockerfile Misconfiguration: Default User Privilege
CWE-20
OWASP Top 10: A6
PCI 3.2: 6.5.6 High Risk Vulnerabilities
Summary
The Dockerfile does not specify a USER, so it defaults to running with a root user.
Explanation
When a Dockerfile does not specify a USER , Docker containers run with super user privileges by
default. These super user privileges are propagated to the code running inside the container, which is
usually more permission than necessary. Running the Docker container with super user privileges
broadens the attack surface which might enable attackers to perform more serious forms of
exploitation.
Recommendation
It is good practice to run your containers as a non-root user when possible.
To modify a docker container to use a non-root user, the Dockerfile needs to specify a different user,
such as:
RUN useradd myLowPrivilegeUser
USER myLowPrivilegeUser




...............
7.1.2 Dockerfile Misconfiguration: Dependency Confusion High
CWE-20
OWASP Top 10: A6
PCI 3.2: 6.5.6 High Risk Vulnerabilities
Summary
Retrieving build dependencies using a non-specific version can leave the build system vulnerable to
malicious binaries or cause the system to experience unexpected behavior.
Explanation
Dockerfiles can specify an unbound range of versions for dependencies and base images. If an
attacker is able to add malicious versions of dependencies to a repository or trick the build system
into downloading dependencies from a repository under the attacker's control, if docker is configured
without specific versions of dependencies, then docker will silently download and run the
compromised dependency.
This type of weakness would be exploitable as a result of a supply chain attack where attackers can
leverage misconfiguration by developers, typosquatting and can add malicious packages to open
source repositories. An attack of this type exploits the trust in the published packages to gain access
and exfiltrate data.
In docker, the latest tag automatically indicates the version level of an image that doesn't use a
digest or unique tag to provide a version for it. Docker automatically assigns the latest tag as
mechanism to point to the most recent image manifest file. Because tags are mutable, an attacker
can replace an image or layer using a latest (or weak tags such as imagename-lst, imagenamelast,
myimage ).
Example 1: The following configuration instructs Docker to pick the base image using the latest
version of ubuntu .
FROM ubuntu:Latest
...
Docker does not validate whether the repository configured to support the package manager is
trustworthy.
Example 2: The following configuration instructs the package manager zypper to retrive the latest
version of the given package.
...
zypper install package
...
In Example 2 , if the repository is compromised, an attacker could simply upload a version that meets
the dynamic criteria and cause zypper to download a malicious version of the dependency.
Recommendation
Perform version pinning or simple pinning. Version pinning explicitly specifies the version of images,
libraries and support packages an application or system depends on. The primary goal of pinning is to
ensure system stability to achieve repeatable deployments. Pinning ensures that end-users,
This report contains Micro Focus CONFIDENTIAL information, including but not limited to Micro Focus's analysis, techniques for analysis and
recommendations. This report may not be made public, used for competitive or consulting purposes or used outside of the recipient.
10
developers, and testers all use the same code base. Pinning can additionally ensure the use of safe
dependencies those which have gone through the rigorous process of application security validation
and malware detection.
When you invoke zypper (or other package managers) from docker, use the following formats:
RUN zypper install <package_name>=<version> \
RUN gem install <package_name> --version <version>
RUN gem install <package_name> -v <version>
RUN apk add <package_name>=<version>
RUN apt-get update && apt-get install -y \
<package_name>=<version> \
<package_name>=<version> \
<package_name>=<version> \
&& rm -rf /var/lib/apt/lists/*
Where <package_name> is the name of the dependency to install and <version> is the exact version
or release the application should use.
Fortify also recommends:
- Ensure the repositories that the package managers use are trustworthy or that they are properly
kept, and there is no install package substitution possible, including the addition of malicious code
onto the package.
- Avoid using public or untrusted repositories.
- Scan packages for malware and security vulnerabilities prior to executing any regression tests.
- Use digitally signed images.
- Avoid using image tags such as latest or weak tags such as imagename-lst, imagename-last,
myimage for deployments in production environments.
- Stick to more stable tags, like specific version tags, although there is no guarantee that these
cannot mutate either.
- Do not create mutant tags.
- Implement strict control over the source of images and their layers.
............







please explain line by line from given Docker file:

FROM docker.allianzuk.cloud/azuk/azuk-corretto-17:latest

ARG user=rap
ARG group=rap
ARG uid=2000
ARG gid=2000

RUN addgroup -g ${gid} ${group} && adduser -h "/home/${user}" -u ${uid} -G ${group} -s /bin/bash -D ${user}

VOLUME /tmp

ADD ./deployment/certs/*  /usr/local/share/ca-certificates/

COPY ./deployment/certs/rootca3_base64.crt /usr/lib/jvm/java-17-amazon-corretto/lib/security

RUN cd /usr/lib/jvm/java-17-amazon-corretto/lib/security && keytool -import -trustcacerts -keystore cacerts -storepass changeit -noprompt -alias roor -file rootca3_base64.crt

ARG VERSION

WORKDIR /etc/app

ENV LOG_FORMAT=json

ADD target/service.jar /etc/app/service.jar

EXPOSE 8080 8080

RUN echo '#!/bin/sh' >  ./entrypoint.sh \
 && echo 'exec java -Djavax.net.ssl.trustStore=/etc/apps/cacerts.jks -Djavax.net.ssl.trustStorePassword=changeit -jar /etc/app/service.jar'   >> ./entrypoint.sh

RUN chmod +x ./entrypoint.sh
ENTRYPOINT ["./entrypoint.sh"]





















.................................................

Fortify on Demand Security Review

sink: From in Dockerfile:1 Enclosing method

Dockerfile Misconfiguration: Dependency Confusion


FROM docker.allianzuk.cloud/azuk/azuk-corretto-17:latest

ARG user=rap
ARG group=rap
ARG uid=2000
ARG gid=2000

RUN addgroup -g ${gid} ${group} && adduser -h "/home/${user}" -u ${uid} -G ${group} -s /bin/bash -D ${user}

VOLUME /tmp

ADD ./deployment/certs/*  /usr/local/share/ca-certificates/

COPY ./deployment/certs/rootca3_base64.crt /usr/lib/jvm/java-17-amazon-corretto/lib/security

RUN cd /usr/lib/jvm/java-17-amazon-corretto/lib/security && keytool -import -trustcacerts -keystore cacerts -storepass changeit -noprompt -alias roor -file rootca3_base64.crt

ARG VERSION

WORKDIR /etc/app

ENV LOG_FORMAT=json

ADD target/service.jar /etc/app/service.jar

EXPOSE 8080 8080

RUN echo '#!/bin/sh' >  ./entrypoint.sh \
 && echo 'exec java -Djavax.net.ssl.trustStore=/etc/apps/cacerts.jks -Djavax.net.ssl.trustStorePassword=changeit -jar /etc/app/service.jar'   >> ./entrypoint.sh

RUN chmod +x ./entrypoint.sh
ENTRYPOINT ["./entrypoint.sh"]

...............................................................................................
JUnit



package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import uk.co.allianz.rap.lc.exception.CustomException;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;


public class ValidationServiceImplTest {
    @Mock
    private ValidationServiceImpl validationServiceImpl;

    @BeforeEach
    void setUp() {
        validationServiceImpl = new ValidationServiceImpl();
    }

    @Test
    public void testProcessJsonSingleValueJson() {

        String json = "\"John\"";
        Assertions.assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));
    }

    @Test
    public void testProcessJsonNoExceptionThrown() {

        String json = "{\"key\": \"value\"}";
        assertDoesNotThrow(() -> validationServiceImpl.processJson(json));
    }

    @Test
    public void testProcessJsonSingleValueJsonThrowsCustomException() {

        String json = "\"value\"";

        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));
    }


    @Test
    public void testProcessJsonWithSingleValueJson() {

        String json = "123"; // Single value JSON

        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));
    }

    @Test
    public void testProcessJsonWithObject() {

        String json = "[]"; // Empty JSON Object / Array

        assertThrows(CustomException.class, () -> validationServiceImpl.processJson(json));
    }
}




package uk.co.allianz.rap.lc.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import com.google.json.JsonSanitizer;
import org.springframework.stereotype.Service;
import uk.co.allianz.rap.lc.exception.CustomException;

/***
 * Build standard JSON validation on incoming data.
 */
@Service
public class ValidationServiceImpl implements ValidationService {
    public String processJson(final String json) throws CustomException, JsonProcessingException {
        System.out.println("In ValidationServiceImpl");
        // Parse the JSON string into a JsonElement
        JsonElement jsonElement;
        jsonElement = JsonParser.parseString(json);
        // Check if the JSON is a single value (string or number) or empty object/array
        if (isSingleValue(jsonElement)) {
            throw new CustomException("JSON is a single value. ");
        } else if (isEmptyObject(jsonElement) || isEmptyArray(jsonElement)) {
            throw new CustomException("JSON is empty object/array. ");
        }
        String sanitizedJson = JsonSanitizer.sanitize(json);
        return sanitizedJson;
    }

    // Helper method to check if the JSON element is a single value
    private boolean isSingleValue(final JsonElement jsonElement) {
        return !jsonElement.isJsonObject() && !jsonElement.isJsonArray();
    }

    // Helper method to check if the JSON element is an empty object ({})
    private boolean isEmptyObject(final JsonElement jsonElement) {
        return jsonElement.isJsonObject() && jsonElement.getAsJsonObject().entrySet().isEmpty();
    }

    // Helper method to check if the JSON element is an empty array ([])
    private boolean isEmptyArray(final JsonElement jsonElement) {
        return jsonElement.isJsonArray() && jsonElement.getAsJsonArray().size() == 0;
    }
}
